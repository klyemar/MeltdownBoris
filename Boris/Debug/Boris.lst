
C:\Users\klyem\AppData\Local\Temp\VMBuilds\Boris\teensy31\Debug/Boris.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
  free(ptr);
}

void operator delete[](void * ptr)
{
  free(ptr);
       0:	00 80 00 20 bd 01 00 00 6d 49 00 00 25 49 00 00     ... ....mI..%I..
      10:	25 49 00 00 25 49 00 00 25 49 00 00 25 49 00 00     %I..%I..%I..%I..
      20:	25 49 00 00 25 49 00 00 25 49 00 00 6d 49 00 00     %I..%I..%I..mI..
      30:	6d 49 00 00 25 49 00 00 61 68 00 00 65 68 00 00     mI..%I..ah..eh..
      40:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      50:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      60:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      70:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      80:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      90:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      a0:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      b0:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      c0:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      d0:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      e0:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
      f0:	6d 49 00 00 55 57 00 00 6d 49 00 00 6d 49 00 00     mI..UW..mI..mI..
     100:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     110:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     120:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     130:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     140:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     150:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     160:	6d 49 00 00 99 5a 00 00 6d 49 00 00 6d 49 00 00     mI...Z..mI..mI..
     170:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     180:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     190:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     1a0:	6d 49 00 00 6d 49 00 00 6d 49 00 00 6d 49 00 00     mI..mI..mI..mI..
     1b0:	6d 49 00 00 6d 49 00 00 6d 49 00 00                 mI..mI..mI..

000001bc <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1bc:	4b56      	ldr	r3, [pc, #344]	; (318 <ResetHandler+0x15c>)
     1be:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1c2:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1c4:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1c6:	f64d 1228 	movw	r2, #55592	; 0xd928
     1ca:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1cc:	bf00      	nop
	__asm__ volatile ("nop");
     1ce:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1d0:	f004 fbd0 	bl	4974 <startup_early_hook>
	// enable clocks to always-used peripherals
#if defined(__MK20DX128__)
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
     1d4:	4b51      	ldr	r3, [pc, #324]	; (31c <ResetHandler+0x160>)
     1d6:	f04f 6210 	mov.w	r2, #150994944	; 0x9000000
     1da:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1dc:	4a50      	ldr	r2, [pc, #320]	; (320 <ResetHandler+0x164>)
     1de:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1e0:	4a50      	ldr	r2, [pc, #320]	; (324 <ResetHandler+0x168>)
     1e2:	60da      	str	r2, [r3, #12]
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     1e4:	4a50      	ldr	r2, [pc, #320]	; (328 <ResetHandler+0x16c>)
     1e6:	6813      	ldr	r3, [r2, #0]
     1e8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     1ec:	d104      	bne.n	1f8 <ResetHandler+0x3c>
		RTC_SR = 0;
     1ee:	494f      	ldr	r1, [pc, #316]	; (32c <ResetHandler+0x170>)
     1f0:	600b      	str	r3, [r1, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     1f2:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     1f6:	6013      	str	r3, [r2, #0]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     1f8:	4b4d      	ldr	r3, [pc, #308]	; (330 <ResetHandler+0x174>)
     1fa:	781a      	ldrb	r2, [r3, #0]
     1fc:	0711      	lsls	r1, r2, #28
     1fe:	d503      	bpl.n	208 <ResetHandler+0x4c>
     200:	781a      	ldrb	r2, [r3, #0]
     202:	f042 0208 	orr.w	r2, r2, #8
     206:	701a      	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     208:	4b4a      	ldr	r3, [pc, #296]	; (334 <ResetHandler+0x178>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     20a:	494b      	ldr	r1, [pc, #300]	; (338 <ResetHandler+0x17c>)
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     20c:	222a      	movs	r2, #42	; 0x2a
     20e:	701a      	strb	r2, [r3, #0]
     210:	4a4a      	ldr	r2, [pc, #296]	; (33c <ResetHandler+0x180>)
     212:	4b4b      	ldr	r3, [pc, #300]	; (340 <ResetHandler+0x184>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     214:	428b      	cmp	r3, r1
     216:	d204      	bcs.n	222 <ResetHandler+0x66>
     218:	f852 0f04 	ldr.w	r0, [r2, #4]!
     21c:	f843 0b04 	str.w	r0, [r3], #4
     220:	e7f8      	b.n	214 <ResetHandler+0x58>
     222:	4b48      	ldr	r3, [pc, #288]	; (344 <ResetHandler+0x188>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     224:	4948      	ldr	r1, [pc, #288]	; (348 <ResetHandler+0x18c>)
     226:	2200      	movs	r2, #0
     228:	428b      	cmp	r3, r1
     22a:	d202      	bcs.n	232 <ResetHandler+0x76>
     22c:	f843 2b04 	str.w	r2, [r3], #4
     230:	e7fa      	b.n	228 <ResetHandler+0x6c>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     232:	4946      	ldr	r1, [pc, #280]	; (34c <ResetHandler+0x190>)
     234:	4a46      	ldr	r2, [pc, #280]	; (350 <ResetHandler+0x194>)
     236:	2300      	movs	r3, #0
     238:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     23c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     240:	3301      	adds	r3, #1
     242:	2b6f      	cmp	r3, #111	; 0x6f
     244:	d1f8      	bne.n	238 <ResetHandler+0x7c>
     246:	4b43      	ldr	r3, [pc, #268]	; (354 <ResetHandler+0x198>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     248:	4a43      	ldr	r2, [pc, #268]	; (358 <ResetHandler+0x19c>)
     24a:	2180      	movs	r1, #128	; 0x80
     24c:	f803 1b01 	strb.w	r1, [r3], #1
     250:	4293      	cmp	r3, r2
     252:	d1fb      	bne.n	24c <ResetHandler+0x90>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     254:	4b41      	ldr	r3, [pc, #260]	; (35c <ResetHandler+0x1a0>)
     256:	4a3d      	ldr	r2, [pc, #244]	; (34c <ResetHandler+0x190>)
     258:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     25a:	4b41      	ldr	r3, [pc, #260]	; (360 <ResetHandler+0x1a4>)
     25c:	228a      	movs	r2, #138	; 0x8a
     25e:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     260:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     264:	2224      	movs	r2, #36	; 0x24
     266:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     268:	22a0      	movs	r2, #160	; 0xa0
     26a:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     26c:	799a      	ldrb	r2, [r3, #6]
     26e:	0792      	lsls	r2, r2, #30
     270:	d5fc      	bpl.n	26c <ResetHandler+0xb0>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     272:	799a      	ldrb	r2, [r3, #6]
     274:	06d4      	lsls	r4, r2, #27
     276:	d4fc      	bmi.n	272 <ResetHandler+0xb6>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     278:	4a3a      	ldr	r2, [pc, #232]	; (364 <ResetHandler+0x1a8>)
     27a:	7993      	ldrb	r3, [r2, #6]
     27c:	f003 030c 	and.w	r3, r3, #12
     280:	2b08      	cmp	r3, #8
     282:	4b38      	ldr	r3, [pc, #224]	; (364 <ResetHandler+0x1a8>)
     284:	d1f9      	bne.n	27a <ResetHandler+0xbe>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     286:	2203      	movs	r2, #3
     288:	711a      	strb	r2, [r3, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
     28a:	2240      	movs	r2, #64	; 0x40
     28c:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     28e:	799a      	ldrb	r2, [r3, #6]
     290:	0690      	lsls	r0, r2, #26
     292:	d5fc      	bpl.n	28e <ResetHandler+0xd2>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     294:	4a33      	ldr	r2, [pc, #204]	; (364 <ResetHandler+0x1a8>)
     296:	7991      	ldrb	r1, [r2, #6]
     298:	4b32      	ldr	r3, [pc, #200]	; (364 <ResetHandler+0x1a8>)
     29a:	0649      	lsls	r1, r1, #25
     29c:	d5fb      	bpl.n	296 <ResetHandler+0xda>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     29e:	4a32      	ldr	r2, [pc, #200]	; (368 <ResetHandler+0x1ac>)
     2a0:	4932      	ldr	r1, [pc, #200]	; (36c <ResetHandler+0x1b0>)
     2a2:	6011      	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2a4:	2102      	movs	r1, #2
     2a6:	6051      	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2a8:	2220      	movs	r2, #32
     2aa:	701a      	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ac:	799a      	ldrb	r2, [r3, #6]
     2ae:	f002 020c 	and.w	r2, r2, #12
     2b2:	2a0c      	cmp	r2, #12
     2b4:	d1fa      	bne.n	2ac <ResetHandler+0xf0>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2b6:	4b2e      	ldr	r3, [pc, #184]	; (370 <ResetHandler+0x1b4>)
     2b8:	4a2e      	ldr	r2, [pc, #184]	; (374 <ResetHandler+0x1b8>)
     2ba:	601a      	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2bc:	4b2e      	ldr	r3, [pc, #184]	; (378 <ResetHandler+0x1bc>)
     2be:	4a2f      	ldr	r2, [pc, #188]	; (37c <ResetHandler+0x1c0>)
     2c0:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2c2:	2200      	movs	r2, #0
     2c4:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2c6:	2207      	movs	r2, #7
     2c8:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2cc:	4a2c      	ldr	r2, [pc, #176]	; (380 <ResetHandler+0x1c4>)
     2ce:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2d2:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     2d4:	f004 fe10 	bl	4ef8 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2d8:	4b14      	ldr	r3, [pc, #80]	; (32c <ResetHandler+0x170>)
     2da:	681b      	ldr	r3, [r3, #0]
     2dc:	07da      	lsls	r2, r3, #31
     2de:	d505      	bpl.n	2ec <ResetHandler+0x130>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2e0:	4828      	ldr	r0, [pc, #160]	; (384 <ResetHandler+0x1c8>)
     2e2:	f004 fbeb 	bl	4abc <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     2e6:	4b28      	ldr	r3, [pc, #160]	; (388 <ResetHandler+0x1cc>)
     2e8:	4a28      	ldr	r2, [pc, #160]	; (38c <ResetHandler+0x1d0>)
     2ea:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     2ec:	4b28      	ldr	r3, [pc, #160]	; (390 <ResetHandler+0x1d4>)
     2ee:	781b      	ldrb	r3, [r3, #0]
     2f0:	065b      	lsls	r3, r3, #25
     2f2:	d509      	bpl.n	308 <ResetHandler+0x14c>
     2f4:	4c24      	ldr	r4, [pc, #144]	; (388 <ResetHandler+0x1cc>)
     2f6:	4b25      	ldr	r3, [pc, #148]	; (38c <ResetHandler+0x1d0>)
     2f8:	6822      	ldr	r2, [r4, #0]
     2fa:	429a      	cmp	r2, r3
     2fc:	d104      	bne.n	308 <ResetHandler+0x14c>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2fe:	4821      	ldr	r0, [pc, #132]	; (384 <ResetHandler+0x1c8>)
     300:	f004 fbdc 	bl	4abc <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     304:	2300      	movs	r3, #0
     306:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     308:	f007 fc50 	bl	7bac <__libc_init_array>

	startup_late_hook();
     30c:	f004 fb38 	bl	4980 <startup_late_hook>
	main();
     310:	f006 fb38 	bl	6984 <main>
     314:	e7fe      	b.n	314 <ResetHandler+0x158>
     316:	bf00      	nop
     318:	4005200e 	.word	0x4005200e
     31c:	40048030 	.word	0x40048030
     320:	00043f82 	.word	0x00043f82
     324:	2b000001 	.word	0x2b000001
     328:	4003d010 	.word	0x4003d010
     32c:	4003d014 	.word	0x4003d014
     330:	4007d002 	.word	0x4007d002
     334:	4007e000 	.word	0x4007e000
     338:	1fff91c0 	.word	0x1fff91c0
     33c:	0000986c 	.word	0x0000986c
     340:	1fff8720 	.word	0x1fff8720
     344:	1fff91c0 	.word	0x1fff91c0
     348:	1fffb658 	.word	0x1fffb658
     34c:	1fff8200 	.word	0x1fff8200
     350:	00000000 	.word	0x00000000
     354:	e000e400 	.word	0xe000e400
     358:	e000e45f 	.word	0xe000e45f
     35c:	e000ed08 	.word	0xe000ed08
     360:	40065000 	.word	0x40065000
     364:	40064000 	.word	0x40064000
     368:	40048044 	.word	0x40048044
     36c:	01030000 	.word	0x01030000
     370:	40048004 	.word	0x40048004
     374:	000510c0 	.word	0x000510c0
     378:	e000e014 	.word	0xe000e014
     37c:	000176ff 	.word	0x000176ff
     380:	20200000 	.word	0x20200000
     384:	630edc0c 	.word	0x630edc0c
     388:	4003e01c 	.word	0x4003e01c
     38c:	5a94c3a5 	.word	0x5a94c3a5
     390:	4007f000 	.word	0x4007f000
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fff91c0 	.word	0x1fff91c0
     42c:	00000000 	.word	0x00000000
     430:	00009868 	.word	0x00009868

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fff91c4 	.word	0x1fff91c4
     460:	00009868 	.word	0x00009868
     464:	1fff91c0 	.word	0x1fff91c0
     468:	00000000 	.word	0x00000000

0000046c <CLEDController::getMaxRefreshRate() const>:
              }

              return adj;
      #endif
    }
    virtual uint16_t getMaxRefreshRate() const { return 0; }
     46c:	2000      	movs	r0, #0
     46e:	4770      	bx	lr

00000470 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::init()>:
  }
public:
  COctoWS2811Controller() { pocto = NULL; }
  virtual int size() { return CLEDController::size() * 8; }

  virtual void init() { /* do nothing yet */ }
     470:	4770      	bx	lr
     472:	bf00      	nop

00000474 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::size()>:
      pocto->begin();
    }
  }
public:
  COctoWS2811Controller() { pocto = NULL; }
  virtual int size() { return CLEDController::size() * 8; }
     474:	6940      	ldr	r0, [r0, #20]
     476:	00c0      	lsls	r0, r0, #3
     478:	4770      	bx	lr
     47a:	bf00      	nop

0000047c <Meltdown::executeSpokes(int) [clone .part.55]>:
		}
	}

	void executeSpokes(int numLeds)
	{
		if (MeltdownLED.GetTop())
     47c:	b5f0      	push	{r4, r5, r6, r7, lr}
     47e:	4c40      	ldr	r4, [pc, #256]	; (580 <Meltdown::executeSpokes(int) [clone .part.55]+0x104>)
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Purple);
		}
		else if (MeltdownLED.GetFullYellow())
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Yellow);
     480:	f894 6035 	ldrb.w	r6, [r4, #53]	; 0x35
		}
	}

	void executeSpokes(int numLeds)
	{
		if (MeltdownLED.GetTop())
     484:	b083      	sub	sp, #12
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Purple);
		}
		else if (MeltdownLED.GetFullYellow())
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Yellow);
     486:	b19e      	cbz	r6, 4b0 <Meltdown::executeSpokes(int) [clone .part.55]+0x34>

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
     488:	2800      	cmp	r0, #0
     48a:	dd0f      	ble.n	4ac <Meltdown::executeSpokes(int) [clone .part.55]+0x30>
     48c:	4c3d      	ldr	r4, [pc, #244]	; (584 <Meltdown::executeSpokes(int) [clone .part.55]+0x108>)
     48e:	493e      	ldr	r1, [pc, #248]	; (588 <Meltdown::executeSpokes(int) [clone .part.55]+0x10c>)
     490:	eb04 0040 	add.w	r0, r4, r0, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     494:	26ff      	movs	r6, #255	; 0xff
        g = (colorcode >>  8) & 0xFF;
        b = (colorcode >>  0) & 0xFF;
     496:	2700      	movs	r7, #0
			  {
				  leds[indexes[i]] = color;
     498:	f834 2b02 	ldrh.w	r2, [r4], #2
     49c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
     4a0:	188d      	adds	r5, r1, r2

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
     4a2:	42a0      	cmp	r0, r4
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     4a4:	548e      	strb	r6, [r1, r2]
        g = (colorcode >>  8) & 0xFF;
     4a6:	706e      	strb	r6, [r5, #1]
        b = (colorcode >>  0) & 0xFF;
     4a8:	70af      	strb	r7, [r5, #2]
     4aa:	d1f5      	bne.n	498 <Meltdown::executeSpokes(int) [clone .part.55]+0x1c>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeLoop()
     4ac:	b003      	add	sp, #12
     4ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Yellow);
		}
		else if (MeltdownLED.GetFullBlue())
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Blue);
     4b0:	f894 5036 	ldrb.w	r5, [r4, #54]	; 0x36
     4b4:	b195      	cbz	r5, 4dc <Meltdown::executeSpokes(int) [clone .part.55]+0x60>
     4b6:	2800      	cmp	r0, #0
     4b8:	ddf8      	ble.n	4ac <Meltdown::executeSpokes(int) [clone .part.55]+0x30>
     4ba:	4c32      	ldr	r4, [pc, #200]	; (584 <Meltdown::executeSpokes(int) [clone .part.55]+0x108>)
     4bc:	4932      	ldr	r1, [pc, #200]	; (588 <Meltdown::executeSpokes(int) [clone .part.55]+0x10c>)
     4be:	eb04 0040 	add.w	r0, r4, r0, lsl #1
     4c2:	23ff      	movs	r3, #255	; 0xff
			  {
				  leds[indexes[i]] = color;
     4c4:	f834 2b02 	ldrh.w	r2, [r4], #2
     4c8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
     4cc:	188d      	adds	r5, r1, r2

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
     4ce:	4284      	cmp	r4, r0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     4d0:	548e      	strb	r6, [r1, r2]
        g = (colorcode >>  8) & 0xFF;
     4d2:	706e      	strb	r6, [r5, #1]
        b = (colorcode >>  0) & 0xFF;
     4d4:	70ab      	strb	r3, [r5, #2]
     4d6:	d1f5      	bne.n	4c4 <Meltdown::executeSpokes(int) [clone .part.55]+0x48>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeLoop()
     4d8:	b003      	add	sp, #12
     4da:	bdf0      	pop	{r4, r5, r6, r7, pc}
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Blue);
		}
		else if (MeltdownLED.GetFullGreen())
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Green);
     4dc:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
     4e0:	b193      	cbz	r3, 508 <Meltdown::executeSpokes(int) [clone .part.55]+0x8c>
     4e2:	2800      	cmp	r0, #0
     4e4:	dde2      	ble.n	4ac <Meltdown::executeSpokes(int) [clone .part.55]+0x30>
     4e6:	4c27      	ldr	r4, [pc, #156]	; (584 <Meltdown::executeSpokes(int) [clone .part.55]+0x108>)
     4e8:	4927      	ldr	r1, [pc, #156]	; (588 <Meltdown::executeSpokes(int) [clone .part.55]+0x10c>)
     4ea:	eb04 0040 	add.w	r0, r4, r0, lsl #1

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
        g = (colorcode >>  8) & 0xFF;
     4ee:	2680      	movs	r6, #128	; 0x80
			  {
				  leds[indexes[i]] = color;
     4f0:	f834 2b02 	ldrh.w	r2, [r4], #2
     4f4:	eb02 0242 	add.w	r2, r2, r2, lsl #1
     4f8:	188b      	adds	r3, r1, r2

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
     4fa:	4284      	cmp	r4, r0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     4fc:	548d      	strb	r5, [r1, r2]
        g = (colorcode >>  8) & 0xFF;
     4fe:	705e      	strb	r6, [r3, #1]
        b = (colorcode >>  0) & 0xFF;
     500:	709d      	strb	r5, [r3, #2]
     502:	d1f5      	bne.n	4f0 <Meltdown::executeSpokes(int) [clone .part.55]+0x74>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeLoop()
     504:	b003      	add	sp, #12
     506:	bdf0      	pop	{r4, r5, r6, r7, pc}
			  return SetPatternNumber(gCurrentPatternNumber + 1);
		  }

		  void ExecutePattern(CRGB leds[], uint16_t indexes[], int numLeds, int patternOffset = 0, int modeOffset = 0)
		  {
			  MeltdownPattern pattern = gPatterns[GetPatternNumber(patternOffset)];
     508:	6822      	ldr	r2, [r4, #0]
     50a:	4b20      	ldr	r3, [pc, #128]	; (58c <Meltdown::executeSpokes(int) [clone .part.55]+0x110>)
     50c:	fba3 1302 	umull	r1, r3, r3, r2
     510:	08db      	lsrs	r3, r3, #3
     512:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     516:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
     51a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     51e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     522:	6d9a      	ldr	r2, [r3, #88]	; 0x58
     524:	6d5d      	ldr	r5, [r3, #84]	; 0x54

			  (this->*(pattern.patternFunc))(leds, indexes, numLeds, modeOffset);
     526:	07d6      	lsls	r6, r2, #31
     528:	d523      	bpl.n	572 <Meltdown::executeSpokes(int) [clone .part.55]+0xf6>
     52a:	1052      	asrs	r2, r2, #1
     52c:	1917      	adds	r7, r2, r4
     52e:	5913      	ldr	r3, [r2, r4]
     530:	595d      	ldr	r5, [r3, r5]
     532:	4a14      	ldr	r2, [pc, #80]	; (584 <Meltdown::executeSpokes(int) [clone .part.55]+0x108>)
     534:	4914      	ldr	r1, [pc, #80]	; (588 <Meltdown::executeSpokes(int) [clone .part.55]+0x10c>)
     536:	4606      	mov	r6, r0
     538:	2300      	movs	r3, #0
     53a:	9300      	str	r3, [sp, #0]
     53c:	4638      	mov	r0, r7
     53e:	4633      	mov	r3, r6
     540:	47a8      	blx	r5
		  int IncrementEffectNumber()
		  {
			  return SetEffectNumber(gCurrentEffectNumber + 1);
		  }

		  void ExecuteEffect(CRGB leds[], uint16_t indexes[], int numLeds, int offset = 0) { (this->*(gEffects[GetEffectNumber(offset)]))(leds, indexes, numLeds); }
     542:	6863      	ldr	r3, [r4, #4]
		  int GetEffectNumber(int offset = 0)
		  {
			  // A value less than zero indicates we want the base effect.
			  if (offset < 0) return 0;

			  return (gCurrentEffectNumber + offset) % ARRAY_SIZE(gEffects);
     544:	4a0e      	ldr	r2, [pc, #56]	; (580 <Meltdown::executeSpokes(int) [clone .part.55]+0x104>)
		  int IncrementEffectNumber()
		  {
			  return SetEffectNumber(gCurrentEffectNumber + 1);
		  }

		  void ExecuteEffect(CRGB leds[], uint16_t indexes[], int numLeds, int offset = 0) { (this->*(gEffects[GetEffectNumber(offset)]))(leds, indexes, numLeds); }
     546:	f003 0301 	and.w	r3, r3, #1
     54a:	3319      	adds	r3, #25
     54c:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
     550:	f854 4033 	ldr.w	r4, [r4, r3, lsl #3]
     554:	684b      	ldr	r3, [r1, #4]
     556:	07d9      	lsls	r1, r3, #31
     558:	d50e      	bpl.n	578 <Meltdown::executeSpokes(int) [clone .part.55]+0xfc>
     55a:	105b      	asrs	r3, r3, #1
     55c:	1898      	adds	r0, r3, r2
     55e:	589b      	ldr	r3, [r3, r2]
     560:	591c      	ldr	r4, [r3, r4]
     562:	4a08      	ldr	r2, [pc, #32]	; (584 <Meltdown::executeSpokes(int) [clone .part.55]+0x108>)
     564:	4908      	ldr	r1, [pc, #32]	; (588 <Meltdown::executeSpokes(int) [clone .part.55]+0x10c>)
     566:	4633      	mov	r3, r6
     568:	46a4      	mov	ip, r4
     56a:	b003      	add	sp, #12
     56c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
     570:	4760      	bx	ip
     572:	eb04 0762 	add.w	r7, r4, r2, asr #1
     576:	e7dc      	b.n	532 <Meltdown::executeSpokes(int) [clone .part.55]+0xb6>
     578:	eb02 0063 	add.w	r0, r2, r3, asr #1
     57c:	e7f1      	b.n	562 <Meltdown::executeSpokes(int) [clone .part.55]+0xe6>
     57e:	bf00      	nop
     580:	1fffb06c 	.word	0x1fffb06c
     584:	1fff924c 	.word	0x1fff924c
     588:	1fff9e34 	.word	0x1fff9e34
     58c:	cccccccd 	.word	0xcccccccd

00000590 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)>:
  typedef union {
    uint8_t bytes[8];
    uint32_t raw[2];
  } Lines;

  virtual void showPixels(PixelController<RGB_ORDER, 8, 0xFF> & pixels) {
     590:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
class COctoWS2811Controller : public CPixelLEDController<RGB_ORDER, 8, 0xFF> {
  OctoWS2811  *pocto;
  uint8_t *drawbuffer,*framebuffer;

  void _init(int nLeds) {
    if(pocto == NULL) {
     594:	6986      	ldr	r6, [r0, #24]
  typedef union {
    uint8_t bytes[8];
    uint32_t raw[2];
  } Lines;

  virtual void showPixels(PixelController<RGB_ORDER, 8, 0xFF> & pixels) {
     596:	b085      	sub	sp, #20
     598:	4605      	mov	r5, r0
     59a:	460c      	mov	r4, r1
class COctoWS2811Controller : public CPixelLEDController<RGB_ORDER, 8, 0xFF> {
  OctoWS2811  *pocto;
  uint8_t *drawbuffer,*framebuffer;

  void _init(int nLeds) {
    if(pocto == NULL) {
     59c:	2e00      	cmp	r6, #0
     59e:	f000 8171 	beq.w	884 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x2f4>

  virtual void showPixels(PixelController<RGB_ORDER, 8, 0xFF> & pixels) {
    _init(pixels.size());

    uint8_t *pData = drawbuffer;
    while(pixels.has(1)) {
     5a2:	68a3      	ldr	r3, [r4, #8]
  } Lines;

  virtual void showPixels(PixelController<RGB_ORDER, 8, 0xFF> & pixels) {
    _init(pixels.size());

    uint8_t *pData = drawbuffer;
     5a4:	69ea      	ldr	r2, [r5, #28]
    while(pixels.has(1)) {
     5a6:	2b00      	cmp	r3, #0
     5a8:	f340 8166 	ble.w	878 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x2e8>
     5ac:	4627      	mov	r7, r4
     5ae:	3218      	adds	r2, #24
     5b0:	f857 8b14 	ldr.w	r8, [r7], #20
     5b4:	f104 0034 	add.w	r0, r4, #52	; 0x34
     5b8:	f894 9013 	ldrb.w	r9, [r4, #19]
     5bc:	f10d 0607 	add.w	r6, sp, #7
     5c0:	4639      	mov	r1, r7
     5c2:	f109 0901 	add.w	r9, r9, #1
  typedef union {
    uint8_t bytes[8];
    uint32_t raw[2];
  } Lines;

  virtual void showPixels(PixelController<RGB_ORDER, 8, 0xFF> & pixels) {
     5c6:	46b4      	mov	ip, r6
     5c8:	46be      	mov	lr, r7
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc, int lane) { return pc.mData[pc.mOffsets[lane] + RO(SLOT)]; }
     5ca:	f85e 3f04 	ldr.w	r3, [lr, #4]!
     5ce:	4443      	add	r3, r8
     5d0:	785b      	ldrb	r3, [r3, #1]

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
     5d2:	b143      	cbz	r3, 5e6 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x56>
         "L_%=: "
         : "+a" (i)
         : "a"  (j) );
    return i;
#elif QADD8_ARM_DSP_ASM == 1
    asm volatile( "uqadd8 %0, %0, %1" : "+r" (i) : "r" (j));
     5d4:	f894 a00d 	ldrb.w	sl, [r4, #13]
     5d8:	fa83 f35a 	uqadd8	r3, r3, sl
     5dc:	b2db      	uxtb	r3, r3
     5de:	fb09 f303 	mul.w	r3, r9, r3
     5e2:	f3c3 2307 	ubfx	r3, r3, #8, #8

    uint8_t *pData = drawbuffer;
    while(pixels.has(1)) {
      Lines b;

      for(int i = 0; i < 8; i++) { b.bytes[i] = pixels.loadAndScale0(i); }
     5e6:	4586      	cmp	lr, r0
     5e8:	f80c 3f01 	strb.w	r3, [ip, #1]!
     5ec:	d1ed      	bne.n	5ca <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x3a>
/// Simplified form of bits rotating function.  Based on code  found here - http://www.hackersdelight.org/hdcodetxt/transpose8.c.txt
__attribute__((always_inline)) inline void transpose8x1_MSB(unsigned char *A, unsigned char *B) {
  uint32_t x, y, t;

  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
     5ee:	f8dd 8008 	ldr.w	r8, [sp, #8]
  x = *(unsigned int*)(A+4);
     5f2:	9b03      	ldr	r3, [sp, #12]
  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     5f4:	ea88 1cd8 	eor.w	ip, r8, r8, lsr #7
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     5f8:	ea83 1ed3 	eor.w	lr, r3, r3, lsr #7
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     5fc:	f00c 1caa 	and.w	ip, ip, #11141290	; 0xaa00aa
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     600:	f00e 1eaa 	and.w	lr, lr, #11141290	; 0xaa00aa
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     604:	ea88 080c 	eor.w	r8, r8, ip
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     608:	ea83 030e 	eor.w	r3, r3, lr
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     60c:	ea88 1ccc 	eor.w	ip, r8, ip, lsl #7
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     610:	ea83 1ece 	eor.w	lr, r3, lr, lsl #7
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     614:	f64c 48cc 	movw	r8, #52428	; 0xcccc
     618:	ea8c 3a9c 	eor.w	sl, ip, ip, lsr #14
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     61c:	ea8e 399e 	eor.w	r9, lr, lr, lsr #14
     620:	4643      	mov	r3, r8
     622:	ea09 0303 	and.w	r3, r9, r3

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     626:	ea0a 0808 	and.w	r8, sl, r8
     62a:	ea8c 0c08 	eor.w	ip, ip, r8
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     62e:	ea8e 0e03 	eor.w	lr, lr, r3

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     632:	ea8c 3c88 	eor.w	ip, ip, r8, lsl #14
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     636:	ea8e 3e83 	eor.w	lr, lr, r3, lsl #14
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     63a:	ea4f 180e 	mov.w	r8, lr, lsl #4
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     63e:	ea4f 131c 	mov.w	r3, ip, lsr #4
     642:	f00e 3ef0 	and.w	lr, lr, #4042322160	; 0xf0f0f0f0
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     646:	f00c 3c0f 	and.w	ip, ip, #252645135	; 0xf0f0f0f
     64a:	f008 38f0 	and.w	r8, r8, #4042322160	; 0xf0f0f0f0
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     64e:	f003 330f 	and.w	r3, r3, #252645135	; 0xf0f0f0f
     652:	ea43 030e 	orr.w	r3, r3, lr
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     656:	ea48 0e0c 	orr.w	lr, r8, ip
  x = t;

  B[7] = y; y >>= 8;
  B[6] = y; y >>= 8;
     65a:	ea4f 491e 	mov.w	r9, lr, lsr #16
  B[5] = y; y >>= 8;
  B[4] = y;
     65e:	ea4f 681e 	mov.w	r8, lr, lsr #24

  B[3] = x; x >>= 8;
     662:	ea4f 2c13 	mov.w	ip, r3, lsr #8
  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
     666:	f802 ec11 	strb.w	lr, [r2, #-17]
  B[6] = y; y >>= 8;
  B[5] = y; y >>= 8;
  B[4] = y;

  B[3] = x; x >>= 8;
     66a:	f802 3c15 	strb.w	r3, [r2, #-21]
  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
     66e:	ea4f 2a1e 	mov.w	sl, lr, lsr #8
  B[6] = y; y >>= 8;
  B[5] = y; y >>= 8;
  B[4] = y;

  B[3] = x; x >>= 8;
  B[2] = x; x >>= 8;
     672:	ea4f 4e13 	mov.w	lr, r3, lsr #16
  B[1] = x; x >>= 8;
  B[0] = x; /* */
     676:	0e1b      	lsrs	r3, r3, #24
  B[6] = y; y >>= 8;
  B[5] = y; y >>= 8;
  B[4] = y;

  B[3] = x; x >>= 8;
  B[2] = x; x >>= 8;
     678:	f802 cc16 	strb.w	ip, [r2, #-22]
  B[1] = x; x >>= 8;
     67c:	f802 ec17 	strb.w	lr, [r2, #-23]
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
  B[6] = y; y >>= 8;
     680:	f802 ac12 	strb.w	sl, [r2, #-18]
  B[5] = y; y >>= 8;
     684:	f802 9c13 	strb.w	r9, [r2, #-19]
  B[4] = y;
     688:	f802 8c14 	strb.w	r8, [r2, #-20]

  B[3] = x; x >>= 8;
  B[2] = x; x >>= 8;
  B[1] = x; x >>= 8;
  B[0] = x; /* */
     68c:	f802 3c18 	strb.w	r3, [r2, #-24]
     690:	f894 9012 	ldrb.w	r9, [r4, #18]
     694:	f8d4 8000 	ldr.w	r8, [r4]
     698:	f109 0901 	add.w	r9, r9, #1
     69c:	f10d 0c07 	add.w	ip, sp, #7
     6a0:	46be      	mov	lr, r7
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc, int lane) { return pc.mData[pc.mOffsets[lane] + RO(SLOT)]; }
     6a2:	f85e 3f04 	ldr.w	r3, [lr, #4]!
     6a6:	f818 3003 	ldrb.w	r3, [r8, r3]

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
     6aa:	b143      	cbz	r3, 6be <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x12e>
     6ac:	f894 a00c 	ldrb.w	sl, [r4, #12]
     6b0:	fa83 f35a 	uqadd8	r3, r3, sl
     6b4:	b2db      	uxtb	r3, r3
     6b6:	fb09 f303 	mul.w	r3, r9, r3
     6ba:	f3c3 2307 	ubfx	r3, r3, #8, #8
      transpose8x1_MSB(b.bytes,pData); pData += 8;
      for(int i = 0; i < 8; i++) { b.bytes[i] = pixels.loadAndScale1(i); }
     6be:	4586      	cmp	lr, r0
     6c0:	f80c 3f01 	strb.w	r3, [ip, #1]!
     6c4:	d1ed      	bne.n	6a2 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x112>
/// Simplified form of bits rotating function.  Based on code  found here - http://www.hackersdelight.org/hdcodetxt/transpose8.c.txt
__attribute__((always_inline)) inline void transpose8x1_MSB(unsigned char *A, unsigned char *B) {
  uint32_t x, y, t;

  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
     6c6:	f8dd 8008 	ldr.w	r8, [sp, #8]
  x = *(unsigned int*)(A+4);
     6ca:	9b03      	ldr	r3, [sp, #12]
  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     6cc:	ea88 1cd8 	eor.w	ip, r8, r8, lsr #7
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     6d0:	ea83 1ed3 	eor.w	lr, r3, r3, lsr #7
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     6d4:	f00c 1caa 	and.w	ip, ip, #11141290	; 0xaa00aa
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     6d8:	f00e 1eaa 	and.w	lr, lr, #11141290	; 0xaa00aa
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     6dc:	ea88 080c 	eor.w	r8, r8, ip
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     6e0:	ea83 030e 	eor.w	r3, r3, lr
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     6e4:	ea88 1ccc 	eor.w	ip, r8, ip, lsl #7
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     6e8:	ea83 1ece 	eor.w	lr, r3, lr, lsl #7
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     6ec:	f64c 48cc 	movw	r8, #52428	; 0xcccc
     6f0:	ea8c 3a9c 	eor.w	sl, ip, ip, lsr #14
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     6f4:	ea8e 399e 	eor.w	r9, lr, lr, lsr #14
     6f8:	4643      	mov	r3, r8
     6fa:	ea09 0303 	and.w	r3, r9, r3

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     6fe:	ea0a 0808 	and.w	r8, sl, r8
     702:	ea8c 0c08 	eor.w	ip, ip, r8
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     706:	ea8e 0e03 	eor.w	lr, lr, r3

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     70a:	ea8c 3c88 	eor.w	ip, ip, r8, lsl #14
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     70e:	ea8e 3e83 	eor.w	lr, lr, r3, lsl #14
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     712:	ea4f 180e 	mov.w	r8, lr, lsl #4
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     716:	ea4f 131c 	mov.w	r3, ip, lsr #4
     71a:	f00e 3ef0 	and.w	lr, lr, #4042322160	; 0xf0f0f0f0
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     71e:	f00c 3c0f 	and.w	ip, ip, #252645135	; 0xf0f0f0f
     722:	f008 38f0 	and.w	r8, r8, #4042322160	; 0xf0f0f0f0
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     726:	f003 330f 	and.w	r3, r3, #252645135	; 0xf0f0f0f
     72a:	ea43 030e 	orr.w	r3, r3, lr
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     72e:	ea48 0e0c 	orr.w	lr, r8, ip
  x = t;

  B[7] = y; y >>= 8;
     732:	f802 ec09 	strb.w	lr, [r2, #-9]
  B[6] = y; y >>= 8;
  B[5] = y; y >>= 8;
  B[4] = y;

  B[3] = x; x >>= 8;
     736:	ea4f 2c13 	mov.w	ip, r3, lsr #8
     73a:	f802 3c0d 	strb.w	r3, [r2, #-13]
  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
     73e:	ea4f 2a1e 	mov.w	sl, lr, lsr #8
  B[6] = y; y >>= 8;
     742:	ea4f 491e 	mov.w	r9, lr, lsr #16
  B[5] = y; y >>= 8;
  B[4] = y;
     746:	ea4f 681e 	mov.w	r8, lr, lsr #24

  B[3] = x; x >>= 8;
  B[2] = x; x >>= 8;
     74a:	ea4f 4e13 	mov.w	lr, r3, lsr #16
  B[1] = x; x >>= 8;
  B[0] = x; /* */
     74e:	0e1b      	lsrs	r3, r3, #24
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
  B[6] = y; y >>= 8;
     750:	f802 ac0a 	strb.w	sl, [r2, #-10]
  B[5] = y; y >>= 8;
     754:	f802 9c0b 	strb.w	r9, [r2, #-11]
  B[4] = y;
     758:	f802 8c0c 	strb.w	r8, [r2, #-12]

  B[3] = x; x >>= 8;
  B[2] = x; x >>= 8;
     75c:	f802 cc0e 	strb.w	ip, [r2, #-14]
  B[1] = x; x >>= 8;
     760:	f802 ec0f 	strb.w	lr, [r2, #-15]
  B[0] = x; /* */
     764:	f802 3c10 	strb.w	r3, [r2, #-16]
     768:	f894 c014 	ldrb.w	ip, [r4, #20]
     76c:	f8d4 e000 	ldr.w	lr, [r4]
     770:	f10c 0c01 	add.w	ip, ip, #1
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc, int lane) { return pc.mData[pc.mOffsets[lane] + RO(SLOT)]; }
     774:	f851 3f04 	ldr.w	r3, [r1, #4]!
     778:	4473      	add	r3, lr
     77a:	789b      	ldrb	r3, [r3, #2]

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
     77c:	b143      	cbz	r3, 790 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x200>
     77e:	f894 800e 	ldrb.w	r8, [r4, #14]
     782:	fa83 f358 	uqadd8	r3, r3, r8
     786:	b2db      	uxtb	r3, r3
     788:	fb0c f303 	mul.w	r3, ip, r3
     78c:	f3c3 2307 	ubfx	r3, r3, #8, #8
      transpose8x1_MSB(b.bytes,pData); pData += 8;
      for(int i = 0; i < 8; i++) { b.bytes[i] = pixels.loadAndScale2(i); }
     790:	4288      	cmp	r0, r1
     792:	f806 3f01 	strb.w	r3, [r6, #1]!
     796:	d1ed      	bne.n	774 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x1e4>
/// Simplified form of bits rotating function.  Based on code  found here - http://www.hackersdelight.org/hdcodetxt/transpose8.c.txt
__attribute__((always_inline)) inline void transpose8x1_MSB(unsigned char *A, unsigned char *B) {
  uint32_t x, y, t;

  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
     798:	9b02      	ldr	r3, [sp, #8]
  x = *(unsigned int*)(A+4);
     79a:	9e03      	ldr	r6, [sp, #12]
  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     79c:	ea83 11d3 	eor.w	r1, r3, r3, lsr #7
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     7a0:	ea86 1ed6 	eor.w	lr, r6, r6, lsr #7
     7a4:	f00e 1eaa 	and.w	lr, lr, #11141290	; 0xaa00aa
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     7a8:	f001 11aa 	and.w	r1, r1, #11141290	; 0xaa00aa
     7ac:	404b      	eors	r3, r1
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     7ae:	ea86 060e 	eor.w	r6, r6, lr
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
     7b2:	ea83 11c1 	eor.w	r1, r3, r1, lsl #7
  // Load the array and pack it into x and y.
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
     7b6:	ea86 16ce 	eor.w	r6, r6, lr, lsl #7
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     7ba:	f64c 43cc 	movw	r3, #52428	; 0xcccc
     7be:	ea81 3891 	eor.w	r8, r1, r1, lsr #14
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     7c2:	ea86 3c96 	eor.w	ip, r6, r6, lsr #14
     7c6:	469e      	mov	lr, r3
     7c8:	ea0c 0e0e 	and.w	lr, ip, lr

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     7cc:	ea08 0303 	and.w	r3, r8, r3
     7d0:	4059      	eors	r1, r3
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     7d2:	ea86 060e 	eor.w	r6, r6, lr

  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);
     7d6:	ea81 3183 	eor.w	r1, r1, r3, lsl #14
  y = *(unsigned int*)(A);
  x = *(unsigned int*)(A+4);

  // pre-transform x
  t = (x ^ (x >> 7)) & 0x00AA00AA;  x = x ^ t ^ (t << 7);
  t = (x ^ (x >>14)) & 0x0000CCCC;  x = x ^ t ^ (t <<14);
     7da:	ea86 368e 	eor.w	r6, r6, lr, lsl #14
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     7de:	0133      	lsls	r3, r6, #4
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     7e0:	ea4f 1e11 	mov.w	lr, r1, lsr #4
     7e4:	f00e 3e0f 	and.w	lr, lr, #252645135	; 0xf0f0f0f
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     7e8:	f001 310f 	and.w	r1, r1, #252645135	; 0xf0f0f0f
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     7ec:	f006 36f0 	and.w	r6, r6, #4042322160	; 0xf0f0f0f0
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
     7f0:	f003 33f0 	and.w	r3, r3, #4042322160	; 0xf0f0f0f0
     7f4:	430b      	orrs	r3, r1
  // pre-transform y
  t = (y ^ (y >> 7)) & 0x00AA00AA;  y = y ^ t ^ (t << 7);
  t = (y ^ (y >>14)) & 0x0000CCCC;  y = y ^ t ^ (t <<14);

  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
     7f6:	ea4e 0606 	orr.w	r6, lr, r6
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
     7fa:	ea4f 2a13 	mov.w	sl, r3, lsr #8
  B[6] = y; y >>= 8;
     7fe:	ea4f 4913 	mov.w	r9, r3, lsr #16
  B[5] = y; y >>= 8;
  B[4] = y;
     802:	ea4f 6813 	mov.w	r8, r3, lsr #24

  B[3] = x; x >>= 8;
     806:	ea4f 2c16 	mov.w	ip, r6, lsr #8
  B[2] = x; x >>= 8;
     80a:	ea4f 4e16 	mov.w	lr, r6, lsr #16
  B[1] = x; x >>= 8;
  B[0] = x; /* */
     80e:	0e31      	lsrs	r1, r6, #24
  // final transform
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
     810:	f802 3c01 	strb.w	r3, [r2, #-1]
  B[6] = y; y >>= 8;
  B[5] = y; y >>= 8;
  B[4] = y;

  B[3] = x; x >>= 8;
     814:	f802 6c05 	strb.w	r6, [r2, #-5]
  t = (x & 0xF0F0F0F0) | ((y >> 4) & 0x0F0F0F0F);
  y = ((x << 4) & 0xF0F0F0F0) | (y & 0x0F0F0F0F);
  x = t;

  B[7] = y; y >>= 8;
  B[6] = y; y >>= 8;
     818:	f802 ac02 	strb.w	sl, [r2, #-2]
  B[5] = y; y >>= 8;
     81c:	f802 9c03 	strb.w	r9, [r2, #-3]
  B[4] = y;
     820:	f802 8c04 	strb.w	r8, [r2, #-4]

  B[3] = x; x >>= 8;
  B[2] = x; x >>= 8;
     824:	f802 cc06 	strb.w	ip, [r2, #-6]
  B[1] = x; x >>= 8;
     828:	f802 ec07 	strb.w	lr, [r2, #-7]
  B[0] = x; /* */
     82c:	f802 1c08 	strb.w	r1, [r2, #-8]

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLenRemaining--;}
     830:	68a3      	ldr	r3, [r4, #8]

        // step the dithering forward
         __attribute__((always_inline)) inline void stepDithering() {
             // IF UPDATING HERE, BE SURE TO UPDATE THE ASM VERSION IN
             // clockless_trinket.h!
                d[0] = e[0] - d[0];
     832:	f894 c00c 	ldrb.w	ip, [r4, #12]
                d[1] = e[1] - d[1];
     836:	f894 e00d 	ldrb.w	lr, [r4, #13]
                d[2] = e[2] - d[2];
     83a:	f894 900e 	ldrb.w	r9, [r4, #14]

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLenRemaining--;}
     83e:	6826      	ldr	r6, [r4, #0]

        // step the dithering forward
         __attribute__((always_inline)) inline void stepDithering() {
             // IF UPDATING HERE, BE SURE TO UPDATE THE ASM VERSION IN
             // clockless_trinket.h!
                d[0] = e[0] - d[0];
     840:	f894 b00f 	ldrb.w	fp, [r4, #15]
                d[1] = e[1] - d[1];
     844:	f894 a010 	ldrb.w	sl, [r4, #16]
                d[2] = e[2] - d[2];
     848:	7c61      	ldrb	r1, [r4, #17]

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLenRemaining--;}
     84a:	f994 8015 	ldrsb.w	r8, [r4, #21]
     84e:	3b01      	subs	r3, #1

        // step the dithering forward
         __attribute__((always_inline)) inline void stepDithering() {
             // IF UPDATING HERE, BE SURE TO UPDATE THE ASM VERSION IN
             // clockless_trinket.h!
                d[0] = e[0] - d[0];
     850:	ebcc 0c0b 	rsb	ip, ip, fp
                d[1] = e[1] - d[1];
     854:	ebce 0e0a 	rsb	lr, lr, sl
                d[2] = e[2] - d[2];
     858:	ebc9 0101 	rsb	r1, r9, r1

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLenRemaining--;}
     85c:	44b0      	add	r8, r6

  virtual void showPixels(PixelController<RGB_ORDER, 8, 0xFF> & pixels) {
    _init(pixels.size());

    uint8_t *pData = drawbuffer;
    while(pixels.has(1)) {
     85e:	2b00      	cmp	r3, #0
     860:	f102 0218 	add.w	r2, r2, #24

        // step the dithering forward
         __attribute__((always_inline)) inline void stepDithering() {
             // IF UPDATING HERE, BE SURE TO UPDATE THE ASM VERSION IN
             // clockless_trinket.h!
                d[0] = e[0] - d[0];
     864:	f884 c00c 	strb.w	ip, [r4, #12]
                d[1] = e[1] - d[1];
     868:	f884 e00d 	strb.w	lr, [r4, #13]
                d[2] = e[2] - d[2];
     86c:	73a1      	strb	r1, [r4, #14]

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLenRemaining--;}
     86e:	f8c4 8000 	str.w	r8, [r4]
     872:	60a3      	str	r3, [r4, #8]
     874:	f73f aea0 	bgt.w	5b8 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x28>
      transpose8x1_MSB(b.bytes,pData); pData += 8;
      pixels.stepDithering();
      pixels.advanceData();
    }

    pocto->show();
     878:	69a8      	ldr	r0, [r5, #24]
  }
     87a:	b005      	add	sp, #20
     87c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      transpose8x1_MSB(b.bytes,pData); pData += 8;
      pixels.stepDithering();
      pixels.advanceData();
    }

    pocto->show();
     880:	f001 bc3a 	b.w	20f8 <OctoWS2811::show()>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
            }
        }

        __attribute__((always_inline)) inline int size() { return mLen; }
     884:	f8d1 8004 	ldr.w	r8, [r1, #4]
  OctoWS2811  *pocto;
  uint8_t *drawbuffer,*framebuffer;

  void _init(int nLeds) {
    if(pocto == NULL) {
      drawbuffer = (uint8_t*)malloc(nLeds * 8 * 3);
     888:	eb08 0748 	add.w	r7, r8, r8, lsl #1
     88c:	00ff      	lsls	r7, r7, #3
     88e:	4638      	mov	r0, r7
     890:	f007 f9b8 	bl	7c04 <malloc>
     894:	61e8      	str	r0, [r5, #28]
      framebuffer = (uint8_t*)malloc(nLeds * 8 * 3);
     896:	4638      	mov	r0, r7
     898:	f007 f9b4 	bl	7c04 <malloc>
     89c:	6228      	str	r0, [r5, #32]

      // byte ordering is handled in show by the pixel controller
      int config = WS2811_RGB;
      config |= CHIP;

      pocto = new OctoWS2811(nLeds, framebuffer, drawbuffer, config);
     89e:	2001      	movs	r0, #1
     8a0:	f006 f878 	bl	6994 <operator new(unsigned int)>
     8a4:	69eb      	ldr	r3, [r5, #28]
     8a6:	6a2a      	ldr	r2, [r5, #32]
     8a8:	9600      	str	r6, [sp, #0]
     8aa:	4607      	mov	r7, r0
     8ac:	4641      	mov	r1, r8
     8ae:	f001 fafd 	bl	1eac <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)>
     8b2:	61af      	str	r7, [r5, #24]

      pocto->begin();
     8b4:	4638      	mov	r0, r7
     8b6:	f001 fb0f 	bl	1ed8 <OctoWS2811::begin()>
     8ba:	e672      	b.n	5a2 <COctoWS2811Controller<(EOrder)66, (unsigned char)0>::showPixels(PixelController<(EOrder)66, 8, 255ul>&)+0x12>

000008bc <CLEDController::clearLeds(int)>:

	///initialize the LED controller
	virtual void init() = 0;

	///clear out/zero out the given number of leds.
	virtual void clearLeds(int nLeds) { showColor(CRGB::Black, nLeds, CRGB::Black); }
     8bc:	b5f0      	push	{r4, r5, r6, r7, lr}
     8be:	b091      	sub	sp, #68	; 0x44
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     8c0:	2300      	movs	r3, #0
        show(data, nLeds, getAdjustment(brightness));
    }

    /// show function w/integer brightness, will scale for color correction and temperature
    void showColor(const struct CRGB &data, int nLeds, uint8_t brightness) {
        showColor(data, nLeds, getAdjustment(brightness));
     8c2:	6805      	ldr	r5, [r0, #0]
     8c4:	f88d 3000 	strb.w	r3, [sp]
     8c8:	f88d 3001 	strb.w	r3, [sp, #1]
     8cc:	f88d 3002 	strb.w	r3, [sp, #2]
     8d0:	682e      	ldr	r6, [r5, #0]
     8d2:	4a3a      	ldr	r2, [pc, #232]	; (9bc <CLEDController::clearLeds(int)+0x100>)
    {
    }

    /// allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
     8d4:	f88d 3004 	strb.w	r3, [sp, #4]
     8d8:	4296      	cmp	r6, r2
     8da:	f88d 3005 	strb.w	r3, [sp, #5]
     8de:	f88d 3006 	strb.w	r3, [sp, #6]
     8e2:	d164      	bne.n	9ae <CLEDController::clearLeds(int)+0xf2>
     8e4:	7c82      	ldrb	r2, [r0, #18]
            enable_dithering(dither);
            mAdvance = 3;
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
     8e6:	9103      	str	r1, [sp, #12]
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
     8e8:	2a01      	cmp	r2, #1
     8ea:	4604      	mov	r4, r0
            enable_dithering(dither);
            mAdvance = 3;
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
     8ec:	9104      	str	r1, [sp, #16]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
     8ee:	f88d 301a 	strb.w	r3, [sp, #26]
        g = rhs.g;
     8f2:	f88d 301b 	strb.w	r3, [sp, #27]
        b = rhs.b;
     8f6:	f88d 301c 	strb.w	r3, [sp, #28]
     8fa:	f8cd d008 	str.w	sp, [sp, #8]
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
     8fe:	d01a      	beq.n	936 <CLEDController::clearLeds(int)+0x7a>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
     900:	f88d 3019 	strb.w	r3, [sp, #25]
     904:	f88d 3018 	strb.w	r3, [sp, #24]
     908:	f88d 3017 	strb.w	r3, [sp, #23]
     90c:	f88d 3016 	strb.w	r3, [sp, #22]
     910:	f88d 3015 	strb.w	r3, [sp, #21]
     914:	f88d 3014 	strb.w	r3, [sp, #20]
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
     918:	2200      	movs	r2, #0
     91a:	f88d 201d 	strb.w	r2, [sp, #29]
     91e:	ab07      	add	r3, sp, #28
     920:	a90f      	add	r1, sp, #60	; 0x3c
        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
            mOffsets[i] = nOffset;
     922:	f843 2f04 	str.w	r2, [r3, #4]!

        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
     926:	4299      	cmp	r1, r3
     928:	d1fb      	bne.n	922 <CLEDController::clearLeds(int)+0x66>
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
     92a:	69ab      	ldr	r3, [r5, #24]
     92c:	4620      	mov	r0, r4
     92e:	a902      	add	r1, sp, #8
     930:	4798      	blx	r3

	///initialize the LED controller
	virtual void init() = 0;

	///clear out/zero out the given number of leds.
	virtual void clearLeds(int nLeds) { showColor(CRGB::Black, nLeds, CRGB::Black); }
     932:	b011      	add	sp, #68	; 0x44
     934:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                  (UPDATES_PER_FULL_DITHER_CYCLE>128) )
#define VIRTUAL_BITS RECOMMENDED_VIRTUAL_BITS

            // R is the digther signal 'counter'.
            static uint8_t R = 0;
            R++;
     936:	4a22      	ldr	r2, [pc, #136]	; (9c0 <CLEDController::clearLeds(int)+0x104>)

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            uint8_t ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
     938:	7813      	ldrb	r3, [r2, #0]
     93a:	3301      	adds	r3, #1
     93c:	f003 0307 	and.w	r3, r3, #7

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            uint8_t Q = 0;
     940:	f013 0f01 	tst.w	r3, #1
     944:	bf14      	ite	ne
     946:	2180      	movne	r1, #128	; 0x80
     948:	2100      	moveq	r1, #0
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            uint8_t ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
     94a:	7013      	strb	r3, [r2, #0]
            uint8_t Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
                if(R & 0x02) { Q |= 0x40; }
     94c:	079a      	lsls	r2, r3, #30
     94e:	bf44      	itt	mi
     950:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
     954:	b2c9      	uxtbmi	r1, r1
                if(R & 0x04) { Q |= 0x20; }
     956:	075b      	lsls	r3, r3, #29
     958:	bf48      	it	mi
     95a:	f041 0120 	orrmi.w	r1, r1, #32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
     95e:	3110      	adds	r1, #16
     960:	2200      	movs	r2, #0
     962:	b2c9      	uxtb	r1, r1
     964:	f10d 0317 	add.w	r3, sp, #23
     968:	f10d 071a 	add.w	r7, sp, #26
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    uint8_t s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
     96c:	f44f 7e80 	mov.w	lr, #256	; 0x100
     970:	b1aa      	cbz	r2, 99e <CLEDController::clearLeds(int)+0xe2>
     972:	fb9e f2f2 	sdiv	r2, lr, r2
     976:	b2d2      	uxtb	r2, r2
     978:	1c50      	adds	r0, r2, #1
     97a:	b2c0      	uxtb	r0, r0
///  4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC_ALWAYS_INLINE uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * (1+(uint16_t)(scale))) >> 8;
     97c:	fb00 1501 	mla	r5, r0, r1, r1
     980:	122d      	asrs	r5, r5, #8
     982:	7018      	strb	r0, [r3, #0]
     984:	b2ee      	uxtb	r6, r5
                    d[i] = scale8(Q, e[i]);
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
     986:	b105      	cbz	r5, 98a <CLEDController::clearLeds(int)+0xce>
     988:	3e01      	subs	r6, #1
     98a:	f803 6c03 	strb.w	r6, [r3, #-3]
#endif
                    if(e[i]) e[i]--;
     98e:	b100      	cbz	r0, 992 <CLEDController::clearLeds(int)+0xd6>
     990:	701a      	strb	r2, [r3, #0]
     992:	3301      	adds	r3, #1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
     994:	429f      	cmp	r7, r3
     996:	d008      	beq.n	9aa <CLEDController::clearLeds(int)+0xee>
     998:	78da      	ldrb	r2, [r3, #3]
                    uint8_t s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
     99a:	2a00      	cmp	r2, #0
     99c:	d1e9      	bne.n	972 <CLEDController::clearLeds(int)+0xb6>
     99e:	701a      	strb	r2, [r3, #0]
                    d[i] = scale8(Q, e[i]);
     9a0:	f803 2c03 	strb.w	r2, [r3, #-3]
     9a4:	3301      	adds	r3, #1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
     9a6:	429f      	cmp	r7, r3
     9a8:	d1f6      	bne.n	998 <CLEDController::clearLeds(int)+0xdc>
     9aa:	6825      	ldr	r5, [r4, #0]
     9ac:	e7b4      	b.n	918 <CLEDController::clearLeds(int)+0x5c>
        show(data, nLeds, getAdjustment(brightness));
    }

    /// show function w/integer brightness, will scale for color correction and temperature
    void showColor(const struct CRGB &data, int nLeds, uint8_t brightness) {
        showColor(data, nLeds, getAdjustment(brightness));
     9ae:	460a      	mov	r2, r1
     9b0:	ab01      	add	r3, sp, #4
     9b2:	4669      	mov	r1, sp
     9b4:	47b0      	blx	r6

	///initialize the LED controller
	virtual void init() = 0;

	///clear out/zero out the given number of leds.
	virtual void clearLeds(int nLeds) { showColor(CRGB::Black, nLeds, CRGB::Black); }
     9b6:	b011      	add	sp, #68	; 0x44
     9b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     9ba:	bf00      	nop
     9bc:	000009c5 	.word	0x000009c5
     9c0:	1fff91dc 	.word	0x1fff91dc

000009c4 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)>:

  /// set all the leds on the controller to a given color
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
     9c4:	b5f0      	push	{r4, r5, r6, r7, lr}
     9c6:	7c85      	ldrb	r5, [r0, #18]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
     9c8:	781c      	ldrb	r4, [r3, #0]
        g = rhs.g;
     9ca:	785e      	ldrb	r6, [r3, #1]
        b = rhs.b;
     9cc:	789b      	ldrb	r3, [r3, #2]
     9ce:	b08f      	sub	sp, #60	; 0x3c
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
     9d0:	2d01      	cmp	r5, #1
            enable_dithering(dither);
            mAdvance = 3;
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
     9d2:	e88d 0006 	stmia.w	sp, {r1, r2}
     9d6:	9202      	str	r2, [sp, #8]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
     9d8:	f88d 4012 	strb.w	r4, [sp, #18]
        g = rhs.g;
     9dc:	f88d 6013 	strb.w	r6, [sp, #19]
        b = rhs.b;
     9e0:	f88d 3014 	strb.w	r3, [sp, #20]
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
     9e4:	d01b      	beq.n	a1e <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0x5a>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
     9e6:	2300      	movs	r3, #0
     9e8:	f88d 3011 	strb.w	r3, [sp, #17]
     9ec:	f88d 3010 	strb.w	r3, [sp, #16]
     9f0:	f88d 300f 	strb.w	r3, [sp, #15]
     9f4:	f88d 300e 	strb.w	r3, [sp, #14]
     9f8:	f88d 300d 	strb.w	r3, [sp, #13]
     9fc:	f88d 300c 	strb.w	r3, [sp, #12]
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
     a00:	2200      	movs	r2, #0
     a02:	f88d 2015 	strb.w	r2, [sp, #21]
     a06:	ab05      	add	r3, sp, #20
     a08:	a90d      	add	r1, sp, #52	; 0x34
        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
            mOffsets[i] = nOffset;
     a0a:	f843 2f04 	str.w	r2, [r3, #4]!

        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
     a0e:	428b      	cmp	r3, r1
     a10:	d1fb      	bne.n	a0a <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0x46>
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
     a12:	6803      	ldr	r3, [r0, #0]
     a14:	4669      	mov	r1, sp
     a16:	699b      	ldr	r3, [r3, #24]
     a18:	4798      	blx	r3
  }
     a1a:	b00f      	add	sp, #60	; 0x3c
     a1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                  (UPDATES_PER_FULL_DITHER_CYCLE>128) )
#define VIRTUAL_BITS RECOMMENDED_VIRTUAL_BITS

            // R is the digther signal 'counter'.
            static uint8_t R = 0;
            R++;
     a1e:	4a1b      	ldr	r2, [pc, #108]	; (a8c <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0xc8>)

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            uint8_t ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
     a20:	7813      	ldrb	r3, [r2, #0]
     a22:	3301      	adds	r3, #1
     a24:	f003 0307 	and.w	r3, r3, #7

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            uint8_t Q = 0;
     a28:	f013 0f01 	tst.w	r3, #1
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            uint8_t ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
     a2c:	7013      	strb	r3, [r2, #0]

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            uint8_t Q = 0;
     a2e:	bf14      	ite	ne
     a30:	2280      	movne	r2, #128	; 0x80
     a32:	2200      	moveq	r2, #0

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
                if(R & 0x02) { Q |= 0x40; }
     a34:	0799      	lsls	r1, r3, #30
     a36:	bf44      	itt	mi
     a38:	f042 0240 	orrmi.w	r2, r2, #64	; 0x40
     a3c:	b2d2      	uxtbmi	r2, r2
                if(R & 0x04) { Q |= 0x20; }
     a3e:	075b      	lsls	r3, r3, #29
     a40:	bf48      	it	mi
     a42:	f042 0220 	orrmi.w	r2, r2, #32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
     a46:	3210      	adds	r2, #16
     a48:	b2d2      	uxtb	r2, r2
     a4a:	f10d 030f 	add.w	r3, sp, #15
     a4e:	f10d 0712 	add.w	r7, sp, #18
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    uint8_t s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
     a52:	f44f 7e80 	mov.w	lr, #256	; 0x100
     a56:	b1ac      	cbz	r4, a84 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0xc0>
     a58:	fb9e f4f4 	sdiv	r4, lr, r4
     a5c:	b2e4      	uxtb	r4, r4
     a5e:	1c61      	adds	r1, r4, #1
     a60:	b2c9      	uxtb	r1, r1
     a62:	fb01 2502 	mla	r5, r1, r2, r2
     a66:	122d      	asrs	r5, r5, #8
     a68:	7019      	strb	r1, [r3, #0]
     a6a:	b2ee      	uxtb	r6, r5
                    d[i] = scale8(Q, e[i]);
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
     a6c:	b105      	cbz	r5, a70 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0xac>
     a6e:	3e01      	subs	r6, #1
     a70:	f803 6c03 	strb.w	r6, [r3, #-3]
#endif
                    if(e[i]) e[i]--;
     a74:	b101      	cbz	r1, a78 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0xb4>
     a76:	701c      	strb	r4, [r3, #0]
     a78:	3301      	adds	r3, #1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
     a7a:	429f      	cmp	r7, r3
     a7c:	d0c0      	beq.n	a00 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0x3c>
     a7e:	78dc      	ldrb	r4, [r3, #3]
                    uint8_t s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
     a80:	2c00      	cmp	r4, #0
     a82:	d1e9      	bne.n	a58 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0x94>
     a84:	701c      	strb	r4, [r3, #0]
                    d[i] = scale8(Q, e[i]);
     a86:	f803 4c03 	strb.w	r4, [r3, #-3]
     a8a:	e7f5      	b.n	a78 <CPixelLEDController<(EOrder)66, 8, 255ul>::showColor(CRGB const&, int, CRGB)+0xb4>
     a8c:	1fff91dc 	.word	0x1fff91dc

00000a90 <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)>:

/// write the passed in rgb data out to the leds managed by this controller
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
     a90:	b5f0      	push	{r4, r5, r6, r7, lr}
     a92:	7c85      	ldrb	r5, [r0, #18]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
     a94:	781c      	ldrb	r4, [r3, #0]
        g = rhs.g;
     a96:	785e      	ldrb	r6, [r3, #1]
        b = rhs.b;
     a98:	789b      	ldrb	r3, [r3, #2]
     a9a:	b08f      	sub	sp, #60	; 0x3c
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
     a9c:	2d01      	cmp	r5, #1
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
     a9e:	e88d 0006 	stmia.w	sp, {r1, r2}
     aa2:	9202      	str	r2, [sp, #8]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
     aa4:	f88d 4012 	strb.w	r4, [sp, #18]
        g = rhs.g;
     aa8:	f88d 6013 	strb.w	r6, [sp, #19]
        b = rhs.b;
     aac:	f88d 3014 	strb.w	r3, [sp, #20]
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
     ab0:	d020      	beq.n	af4 <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0x64>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
     ab2:	2300      	movs	r3, #0
     ab4:	f88d 3011 	strb.w	r3, [sp, #17]
     ab8:	f88d 3010 	strb.w	r3, [sp, #16]
     abc:	f88d 300f 	strb.w	r3, [sp, #15]
     ac0:	f88d 300e 	strb.w	r3, [sp, #14]
     ac4:	f88d 300d 	strb.w	r3, [sp, #13]
     ac8:	f88d 300c 	strb.w	r3, [sp, #12]
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
     acc:	2103      	movs	r1, #3
            for(int i = 0; i < LANES; i++) { mOffsets[i] = other.mOffsets[i]; }

        }

        void initOffsets(int len) {
          int nOffset = 0;
     ace:	2300      	movs	r3, #0
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
     ad0:	f88d 1015 	strb.w	r1, [sp, #21]
     ad4:	eb02 0242 	add.w	r2, r2, r2, lsl #1

        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
     ad8:	4619      	mov	r1, r3
     ada:	ac05      	add	r4, sp, #20
     adc:	3101      	adds	r1, #1
     ade:	2908      	cmp	r1, #8
            mOffsets[i] = nOffset;
     ae0:	f844 3f04 	str.w	r3, [r4, #4]!
            if((1<<i) & MASK) { nOffset += (len * mAdvance); }
     ae4:	4413      	add	r3, r2

        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
     ae6:	d1f9      	bne.n	adc <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0x4c>
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
     ae8:	6803      	ldr	r3, [r0, #0]
     aea:	4669      	mov	r1, sp
     aec:	699b      	ldr	r3, [r3, #24]
     aee:	4798      	blx	r3
  }
     af0:	b00f      	add	sp, #60	; 0x3c
     af2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                  (UPDATES_PER_FULL_DITHER_CYCLE>128) )
#define VIRTUAL_BITS RECOMMENDED_VIRTUAL_BITS

            // R is the digther signal 'counter'.
            static uint8_t R = 0;
            R++;
     af4:	491b      	ldr	r1, [pc, #108]	; (b64 <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0xd4>)

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            uint8_t ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
     af6:	780b      	ldrb	r3, [r1, #0]
     af8:	3301      	adds	r3, #1
     afa:	f003 0307 	and.w	r3, r3, #7

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            uint8_t Q = 0;
     afe:	f013 0f01 	tst.w	r3, #1
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            uint8_t ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
     b02:	700b      	strb	r3, [r1, #0]

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            uint8_t Q = 0;
     b04:	bf14      	ite	ne
     b06:	2180      	movne	r1, #128	; 0x80
     b08:	2100      	moveq	r1, #0

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
                if(R & 0x02) { Q |= 0x40; }
     b0a:	079d      	lsls	r5, r3, #30
     b0c:	bf44      	itt	mi
     b0e:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
     b12:	b2c9      	uxtbmi	r1, r1
                if(R & 0x04) { Q |= 0x20; }
     b14:	075b      	lsls	r3, r3, #29
     b16:	bf48      	it	mi
     b18:	f041 0120 	orrmi.w	r1, r1, #32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
     b1c:	3110      	adds	r1, #16
     b1e:	b2c9      	uxtb	r1, r1
     b20:	f10d 030f 	add.w	r3, sp, #15
     b24:	f10d 0e12 	add.w	lr, sp, #18
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    uint8_t s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
     b28:	f44f 7c80 	mov.w	ip, #256	; 0x100
     b2c:	b1ac      	cbz	r4, b5a <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0xca>
     b2e:	fb9c f4f4 	sdiv	r4, ip, r4
     b32:	b2e4      	uxtb	r4, r4
     b34:	1c65      	adds	r5, r4, #1
     b36:	b2ed      	uxtb	r5, r5
     b38:	fb05 1601 	mla	r6, r5, r1, r1
     b3c:	1236      	asrs	r6, r6, #8
     b3e:	701d      	strb	r5, [r3, #0]
     b40:	b2f7      	uxtb	r7, r6
                    d[i] = scale8(Q, e[i]);
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
     b42:	b106      	cbz	r6, b46 <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0xb6>
     b44:	3f01      	subs	r7, #1
     b46:	f803 7c03 	strb.w	r7, [r3, #-3]
#endif
                    if(e[i]) e[i]--;
     b4a:	b105      	cbz	r5, b4e <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0xbe>
     b4c:	701c      	strb	r4, [r3, #0]
     b4e:	3301      	adds	r3, #1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
     b50:	4573      	cmp	r3, lr
     b52:	d0bb      	beq.n	acc <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0x3c>
     b54:	78dc      	ldrb	r4, [r3, #3]
                    uint8_t s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
     b56:	2c00      	cmp	r4, #0
     b58:	d1e9      	bne.n	b2e <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0x9e>
     b5a:	701c      	strb	r4, [r3, #0]
                    d[i] = scale8(Q, e[i]);
     b5c:	f803 4c03 	strb.w	r4, [r3, #-3]
     b60:	e7f5      	b.n	b4e <CPixelLEDController<(EOrder)66, 8, 255ul>::show(CRGB const*, int, CRGB)+0xbe>
     b62:	bf00      	nop
     b64:	1fff91dc 	.word	0x1fff91dc

00000b68 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     b68:	b570      	push	{r4, r5, r6, lr}
     b6a:	4604      	mov	r4, r0
     b6c:	4608      	mov	r0, r1
     b6e:	460d      	mov	r5, r1
     b70:	f007 ffc6 	bl	8b00 <strlen>
     b74:	6823      	ldr	r3, [r4, #0]
     b76:	4602      	mov	r2, r0
     b78:	4629      	mov	r1, r5
     b7a:	4620      	mov	r0, r4
     b7c:	685b      	ldr	r3, [r3, #4]
     b7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     b82:	4718      	bx	r3

00000b84 <Print::println(String const&)>:
	size_t print(uint64_t n, int base)		{ return printNumber64(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
     b84:	b538      	push	{r3, r4, r5, lr}
     b86:	4605      	mov	r5, r0
     b88:	f005 ff06 	bl	6998 <Print::print(String const&)>
     b8c:	4604      	mov	r4, r0
     b8e:	4628      	mov	r0, r5
     b90:	f005 ff28 	bl	69e4 <Print::println()>
     b94:	4420      	add	r0, r4
     b96:	bd38      	pop	{r3, r4, r5, pc}

00000b98 <Print::println(int)>:
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
     b98:	b538      	push	{r3, r4, r5, lr}
     b9a:	4605      	mov	r5, r0
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     b9c:	f005 ff76 	bl	6a8c <Print::print(long)>
     ba0:	4604      	mov	r4, r0
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
     ba2:	4628      	mov	r0, r5
     ba4:	f005 ff1e 	bl	69e4 <Print::println()>
     ba8:	4420      	add	r0, r4
     baa:	bd38      	pop	{r3, r4, r5, pc}

00000bac <Meltdown::CMeltdownLogger::Debug(Stream&, String, int) [clone .part.7] [clone .constprop.62]>:
			serial.print(msg);
			serial.print(": ");
			serial.println(value);
		}

		void Debug(Stream &serial, String msg, int value)
     bac:	b538      	push	{r3, r4, r5, lr}
		{
			if (!m_isDebug) return;

			serial.print(msg);
     bae:	4c07      	ldr	r4, [pc, #28]	; (bcc <Meltdown::CMeltdownLogger::Debug(Stream&, String, int) [clone .part.7] [clone .constprop.62]+0x20>)
			serial.print(msg);
			serial.print(": ");
			serial.println(value);
		}

		void Debug(Stream &serial, String msg, int value)
     bb0:	460d      	mov	r5, r1
		{
			if (!m_isDebug) return;

			serial.print(msg);
     bb2:	4601      	mov	r1, r0
     bb4:	4620      	mov	r0, r4
     bb6:	f005 feef 	bl	6998 <Print::print(String const&)>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     bba:	4620      	mov	r0, r4
     bbc:	4904      	ldr	r1, [pc, #16]	; (bd0 <Meltdown::CMeltdownLogger::Debug(Stream&, String, int) [clone .part.7] [clone .constprop.62]+0x24>)
     bbe:	f7ff ffd3 	bl	b68 <Print::write(char const*)>
			serial.print(": ");
			serial.println(value);
     bc2:	4629      	mov	r1, r5
     bc4:	4620      	mov	r0, r4
     bc6:	f7ff ffe7 	bl	b98 <Print::println(int)>
     bca:	bd38      	pop	{r3, r4, r5, pc}
     bcc:	1fff8760 	.word	0x1fff8760
     bd0:	00009134 	.word	0x00009134

00000bd4 <Meltdown::CMeltdownSerial::GetAnalogValue(int)>:
			String m_inputString;
			boolean m_inputStringComplete; // whether the String is complete

#pragma region INPUTS

			int GetAnalogValue(int currVal)
     bd4:	b570      	push	{r4, r5, r6, lr}
			{
				int val = currVal;

				if (!m_inputString.equals(""))
     bd6:	1d05      	adds	r5, r0, #4
			String m_inputString;
			boolean m_inputStringComplete; // whether the String is complete

#pragma region INPUTS

			int GetAnalogValue(int currVal)
     bd8:	b088      	sub	sp, #32
     bda:	460e      	mov	r6, r1
			{
				int val = currVal;

				if (!m_inputString.equals(""))
     bdc:	4628      	mov	r0, r5
     bde:	491b      	ldr	r1, [pc, #108]	; (c4c <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x78>)
     be0:	f006 f8c8 	bl	6d74 <String::equals(char const*) const>
     be4:	b110      	cbz	r0, bec <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x18>
				{
					val = GetSerialValue(m_inputString, currVal);
				}

				return val;
			}
     be6:	4630      	mov	r0, r6
     be8:	b008      	add	sp, #32
     bea:	bd70      	pop	{r4, r5, r6, pc}
     bec:	4604      	mov	r4, r0
			{
				int val = currVal;

				if (!m_inputString.equals(""))
				{
					val = GetSerialValue(m_inputString, currVal);
     bee:	4629      	mov	r1, r5
     bf0:	4668      	mov	r0, sp
     bf2:	f006 f809 	bl	6c08 <String::String(String const&)>
				}
			}

			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
     bf6:	4621      	mov	r1, r4
     bf8:	4668      	mov	r0, sp
     bfa:	f006 f8d1 	bl	6da0 <String::operator[](unsigned int)>
     bfe:	7803      	ldrb	r3, [r0, #0]
     c00:	2b23      	cmp	r3, #35	; 0x23
     c02:	d005      	beq.n	c10 <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x3c>
			{
				int val = currVal;

				if (!m_inputString.equals(""))
				{
					val = GetSerialValue(m_inputString, currVal);
     c04:	4668      	mov	r0, sp
     c06:	f005 ff99 	bl	6b3c <String::~String()>
				}

				return val;
			}
     c0a:	4630      	mov	r0, r6
     c0c:	b008      	add	sp, #32
     c0e:	bd70      	pop	{r4, r5, r6, pc}
				}
			}

			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
     c10:	9b02      	ldr	r3, [sp, #8]
     c12:	2b09      	cmp	r3, #9
     c14:	d9f6      	bls.n	c04 <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x30>
				{
					String valString = inputString.substring(5, 9);
     c16:	a804      	add	r0, sp, #16
     c18:	2309      	movs	r3, #9
     c1a:	2205      	movs	r2, #5
     c1c:	4669      	mov	r1, sp
     c1e:	f006 f8e7 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					int val = valString.toInt();
     c22:	a804      	add	r0, sp, #16
     c24:	f006 f908 	bl	6e38 <String::toInt() const>

					// A value of 0 indicates an error but is acceptable if the intended value is actually 0.
					if (val != 0 || valString.equals("0000"))
     c28:	4604      	mov	r4, r0
     c2a:	b120      	cbz	r0, c36 <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x62>
					{
						return val;
     c2c:	a804      	add	r0, sp, #16
     c2e:	f005 ff85 	bl	6b3c <String::~String()>
			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
				{
					String valString = inputString.substring(5, 9);
					int val = valString.toInt();
     c32:	4626      	mov	r6, r4
     c34:	e7e6      	b.n	c04 <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x30>

					// A value of 0 indicates an error but is acceptable if the intended value is actually 0.
					if (val != 0 || valString.equals("0000"))
     c36:	4906      	ldr	r1, [pc, #24]	; (c50 <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x7c>)
     c38:	a804      	add	r0, sp, #16
     c3a:	f006 f89b 	bl	6d74 <String::equals(char const*) const>
     c3e:	2800      	cmp	r0, #0
     c40:	d1f4      	bne.n	c2c <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x58>

			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
				{
					String valString = inputString.substring(5, 9);
     c42:	a804      	add	r0, sp, #16
     c44:	f005 ff7a 	bl	6b3c <String::~String()>
     c48:	e7dc      	b.n	c04 <Meltdown::CMeltdownSerial::GetAnalogValue(int)+0x30>
     c4a:	bf00      	nop
     c4c:	0000933c 	.word	0x0000933c
     c50:	00009138 	.word	0x00009138

00000c54 <Meltdown::CMeltdownSerial::GetValue()>:
					return m_inputString.substring(1, 5);
				}
				return "";
			}

			int GetValue()
     c54:	b530      	push	{r4, r5, lr}
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     c56:	1d04      	adds	r4, r0, #4
					return m_inputString.substring(1, 5);
				}
				return "";
			}

			int GetValue()
     c58:	b085      	sub	sp, #20
     c5a:	4605      	mov	r5, r0
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     c5c:	2100      	movs	r1, #0
     c5e:	4620      	mov	r0, r4
     c60:	f006 f89e 	bl	6da0 <String::operator[](unsigned int)>
     c64:	7803      	ldrb	r3, [r0, #0]
     c66:	2b23      	cmp	r3, #35	; 0x23
     c68:	d003      	beq.n	c72 <Meltdown::CMeltdownSerial::GetValue()+0x1e>
				return "";
			}

			int GetValue()
			{
				int val = 0;
     c6a:	2400      	movs	r4, #0
				{
					String valString = m_inputString.substring(5, 9);
					val = valString.toInt();
				}
				return val;
			}
     c6c:	4620      	mov	r0, r4
     c6e:	b005      	add	sp, #20
     c70:	bd30      	pop	{r4, r5, pc}
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     c72:	68eb      	ldr	r3, [r5, #12]
     c74:	2b09      	cmp	r3, #9
     c76:	d9f8      	bls.n	c6a <Meltdown::CMeltdownSerial::GetValue()+0x16>
				{
					String valString = m_inputString.substring(5, 9);
     c78:	4621      	mov	r1, r4
     c7a:	2309      	movs	r3, #9
     c7c:	2205      	movs	r2, #5
     c7e:	4668      	mov	r0, sp
     c80:	f006 f8b6 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
     c84:	4668      	mov	r0, sp
     c86:	f006 f8d7 	bl	6e38 <String::toInt() const>
     c8a:	4604      	mov	r4, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
     c8c:	4668      	mov	r0, sp
     c8e:	f005 ff55 	bl	6b3c <String::~String()>
					val = valString.toInt();
				}
				return val;
			}
     c92:	4620      	mov	r0, r4
     c94:	b005      	add	sp, #20
     c96:	bd30      	pop	{r4, r5, pc}

00000c98 <Meltdown::setIndexesForAll()>:
	}

	void setIndexesForAll()
	{
		if (gSelectedIndexes != INDEXES_ALL)
		{
     c98:	b510      	push	{r4, lr}
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
     c9a:	490a      	ldr	r1, [pc, #40]	; (cc4 <Meltdown::setIndexesForAll()+0x2c>)
     c9c:	480a      	ldr	r0, [pc, #40]	; (cc8 <Meltdown::setIndexesForAll()+0x30>)
     c9e:	f006 f85b 	bl	6d58 <String::equals(String const&) const>
			gSelectedIndexes = INDEXES_ALL;
     ca2:	b100      	cbz	r0, ca6 <Meltdown::setIndexesForAll()+0xe>
     ca4:	bd10      	pop	{r4, pc}
     ca6:	4604      	mov	r4, r0

			for (int i = 0; i < NUM_LEDS; i++)
     ca8:	4906      	ldr	r1, [pc, #24]	; (cc4 <Meltdown::setIndexesForAll()+0x2c>)
     caa:	4807      	ldr	r0, [pc, #28]	; (cc8 <Meltdown::setIndexesForAll()+0x30>)
     cac:	f005 ffca 	bl	6c44 <String::operator=(String const&)>
     cb0:	4b06      	ldr	r3, [pc, #24]	; (ccc <Meltdown::setIndexesForAll()+0x34>)
			{
				ledIndexes[i] = i;
     cb2:	4620      	mov	r0, r4
     cb4:	f240 52dc 	movw	r2, #1500	; 0x5dc
			}
		}
     cb8:	f823 0f02 	strh.w	r0, [r3, #2]!
		{
			gSelectedIndexes = INDEXES_ALL;

			for (int i = 0; i < NUM_LEDS; i++)
			{
				ledIndexes[i] = i;
     cbc:	3001      	adds	r0, #1
     cbe:	4290      	cmp	r0, r2
     cc0:	d1fa      	bne.n	cb8 <Meltdown::setIndexesForAll()+0x20>
     cc2:	bd10      	pop	{r4, pc}
     cc4:	1fff9208 	.word	0x1fff9208
     cc8:	1fff9218 	.word	0x1fff9218
     ccc:	1fff924a 	.word	0x1fff924a

00000cd0 <Meltdown::tryExecuteCommand() [clone .part.53]>:
		MeltdownLED.Sunrise(leds, ledIndexes, NUM_LEDS);
	}

	void tryExecuteCommand()
	{
		if (MeltdownSerial.GetInputStringComplete())
     cd0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

			void AddCharToInputString(char inChar) { m_inputString += inChar; }

			bool GetInputStringComplete() { return m_inputStringComplete; }

			void SetInputStringComplete(bool value) { m_inputStringComplete = value; }
     cd4:	4daf      	ldr	r5, [pc, #700]	; (f94 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2c4>)
     cd6:	2300      	movs	r3, #0

			String GetCommand()
			{
				if (m_inputString[0] == '#' && m_inputString.length() >= 6)
     cd8:	4619      	mov	r1, r3

			void AddCharToInputString(char inChar) { m_inputString += inChar; }

			bool GetInputStringComplete() { return m_inputStringComplete; }

			void SetInputStringComplete(bool value) { m_inputStringComplete = value; }
     cda:	752b      	strb	r3, [r5, #20]
     cdc:	b08d      	sub	sp, #52	; 0x34

			String GetCommand()
			{
				if (m_inputString[0] == '#' && m_inputString.length() >= 6)
     cde:	1d28      	adds	r0, r5, #4
     ce0:	f006 f85e 	bl	6da0 <String::operator[](unsigned int)>
     ce4:	7803      	ldrb	r3, [r0, #0]
     ce6:	2b23      	cmp	r3, #35	; 0x23
     ce8:	d042      	beq.n	d70 <Meltdown::tryExecuteCommand() [clone .part.53]+0xa0>
				{
					return m_inputString.substring(1, 5);
				}
				return "";
     cea:	4668      	mov	r0, sp
     cec:	49aa      	ldr	r1, [pc, #680]	; (f98 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2c8>)
     cee:	466c      	mov	r4, sp
     cf0:	f005 ff64 	bl	6bbc <String::String(char const*)>
			MeltdownSerial.SetInputStringComplete(false);

			String command = MeltdownSerial.GetCommand();
			if (!command.equals(""))
			{
				if (command.equals(MeltdownSerial.BRIGHTNESS))
     cf4:	49a8      	ldr	r1, [pc, #672]	; (f98 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2c8>)
     cf6:	4620      	mov	r0, r4
     cf8:	f006 f83c 	bl	6d74 <String::equals(char const*) const>
     cfc:	b990      	cbnz	r0, d24 <Meltdown::tryExecuteCommand() [clone .part.53]+0x54>
				{
					MeltdownLED.SetBrightness(-1);
     cfe:	49a7      	ldr	r1, [pc, #668]	; (f9c <Meltdown::tryExecuteCommand() [clone .part.53]+0x2cc>)
     d00:	4620      	mov	r0, r4
     d02:	f006 f829 	bl	6d58 <String::equals(String const&) const>
     d06:	4606      	mov	r6, r0
     d08:	b308      	cbz	r0, d4e <Meltdown::tryExecuteCommand() [clone .part.53]+0x7e>

		  // BRIGHTNESS //

		  int SetBrightness(int pin)
		  {
			  gBrightness = MeltdownSerial.GetAnalogValue(pin, gBrightness);
     d0a:	4fa5      	ldr	r7, [pc, #660]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)

			int GetAnalogValue(int currVal)
			{
				int val = currVal;

				if (!m_inputString.equals(""))
     d0c:	49a2      	ldr	r1, [pc, #648]	; (f98 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2c8>)
     d0e:	48a5      	ldr	r0, [pc, #660]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     d10:	697e      	ldr	r6, [r7, #20]
     d12:	f006 f82f 	bl	6d74 <String::equals(char const*) const>
     d16:	4605      	mov	r5, r0
     d18:	2800      	cmp	r0, #0
     d1a:	d04d      	beq.n	db8 <Meltdown::tryExecuteCommand() [clone .part.53]+0xe8>
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
     d1c:	4ba2      	ldr	r3, [pc, #648]	; (fa8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d8>)
     d1e:	617e      	str	r6, [r7, #20]
     d20:	701e      	strb	r6, [r3, #0]
     d22:	e00a      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
			}
			else
			{
				MeltdownLogger.Debug(Serial, F("Something went wrong reading serial, command was blank."));
			}

     d24:	ad08      	add	r5, sp, #32
     d26:	4628      	mov	r0, r5
     d28:	49a0      	ldr	r1, [pc, #640]	; (fac <Meltdown::tryExecuteCommand() [clone .part.53]+0x2dc>)
     d2a:	f005 ff5b 	bl	6be4 <String::String(__FlashStringHelper const*)>
			m_isDebug = isDebug;
		}

		void Debug(Stream &serial, String msg)
		{
			if (!m_isDebug) return;
     d2e:	4ba0      	ldr	r3, [pc, #640]	; (fb0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2e0>)
     d30:	781b      	ldrb	r3, [r3, #0]
     d32:	bb43      	cbnz	r3, d86 <Meltdown::tryExecuteCommand() [clone .part.53]+0xb6>
     d34:	4628      	mov	r0, r5
     d36:	f005 ff01 	bl	6b3c <String::~String()>
				return newVal <= (oldVal - m_analogTolerance) || newVal >= (oldVal + m_analogTolerance);
			}

			String GetInputString() { return m_inputString; }

			void ClearInputString() { m_inputString = ""; }
     d3a:	4997      	ldr	r1, [pc, #604]	; (f98 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2c8>)
     d3c:	4899      	ldr	r0, [pc, #612]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     d3e:	f005 ff89 	bl	6c54 <String::operator=(char const*)>
		{
			MeltdownSerial.SetInputStringComplete(false);

			String command = MeltdownSerial.GetCommand();
			if (!command.equals(""))
			{
     d42:	4620      	mov	r0, r4
     d44:	f005 fefa 	bl	6b3c <String::~String()>

			MeltdownSerial.ClearInputString();
		}
	}

#pragma endregion COMMANDS
     d48:	b00d      	add	sp, #52	; 0x34
     d4a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				{
					MeltdownLED.SetBrightness(-1);
				}
				else if (command.equals(MeltdownSerial.FULL_PURPLE))
				{
					MeltdownLED.SetFullPurple();
     d4e:	4999      	ldr	r1, [pc, #612]	; (fb4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2e4>)
     d50:	4620      	mov	r0, r4
     d52:	f006 f801 	bl	6d58 <String::equals(String const&) const>
     d56:	4607      	mov	r7, r0
     d58:	b1e8      	cbz	r0, d96 <Meltdown::tryExecuteCommand() [clone .part.53]+0xc6>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     d5a:	4631      	mov	r1, r6
     d5c:	4891      	ldr	r0, [pc, #580]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     d5e:	f006 f81f 	bl	6da0 <String::operator[](unsigned int)>
     d62:	7803      	ldrb	r3, [r0, #0]
     d64:	2b23      	cmp	r3, #35	; 0x23
     d66:	d070      	beq.n	e4a <Meltdown::tryExecuteCommand() [clone .part.53]+0x17a>
		  bool ToggleFullPurple()
		  {
			  gFullPurple = !gFullPurple;
			  return gFullPurple;
		  }
		  void SetFullPurple() { gFullPurple = MeltdownSerial.GetBoolValue(); }
     d68:	4b8d      	ldr	r3, [pc, #564]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     d6a:	f883 6034 	strb.w	r6, [r3, #52]	; 0x34
     d6e:	e7e4      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>

			void SetInputStringComplete(bool value) { m_inputStringComplete = value; }

			String GetCommand()
			{
				if (m_inputString[0] == '#' && m_inputString.length() >= 6)
     d70:	68eb      	ldr	r3, [r5, #12]
     d72:	2b05      	cmp	r3, #5
     d74:	d9b9      	bls.n	cea <Meltdown::tryExecuteCommand() [clone .part.53]+0x1a>
				{
					return m_inputString.substring(1, 5);
     d76:	4668      	mov	r0, sp
     d78:	2305      	movs	r3, #5
     d7a:	2201      	movs	r2, #1
     d7c:	1d29      	adds	r1, r5, #4
     d7e:	466c      	mov	r4, sp
     d80:	f006 f836 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
     d84:	e7b6      	b.n	cf4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x24>
	size_t print(uint64_t n, int base)		{ return printNumber64(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
     d86:	4629      	mov	r1, r5
     d88:	488b      	ldr	r0, [pc, #556]	; (fb8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2e8>)
     d8a:	f005 fe05 	bl	6998 <Print::print(String const&)>
     d8e:	488a      	ldr	r0, [pc, #552]	; (fb8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2e8>)
     d90:	f005 fe28 	bl	69e4 <Print::println()>
     d94:	e7ce      	b.n	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
				}
				else if (command.equals(MeltdownSerial.FULL_YELLOW))
				{
					MeltdownLED.SetFullYellow();
     d96:	4989      	ldr	r1, [pc, #548]	; (fbc <Meltdown::tryExecuteCommand() [clone .part.53]+0x2ec>)
     d98:	4620      	mov	r0, r4
     d9a:	f005 ffdd 	bl	6d58 <String::equals(String const&) const>
     d9e:	4606      	mov	r6, r0
     da0:	b1d8      	cbz	r0, dda <Meltdown::tryExecuteCommand() [clone .part.53]+0x10a>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     da2:	4639      	mov	r1, r7
     da4:	487f      	ldr	r0, [pc, #508]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     da6:	f005 fffb 	bl	6da0 <String::operator[](unsigned int)>
     daa:	7803      	ldrb	r3, [r0, #0]
     dac:	2b23      	cmp	r3, #35	; 0x23
     dae:	d038      	beq.n	e22 <Meltdown::tryExecuteCommand() [clone .part.53]+0x152>
		  bool ToggleFullYellow()
		  {
			  gFullYellow = !gFullYellow;
			  return gFullYellow;
		  }
		  void SetFullYellow() { gFullYellow = MeltdownSerial.GetBoolValue(); }
     db0:	4b7b      	ldr	r3, [pc, #492]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     db2:	f883 7035 	strb.w	r7, [r3, #53]	; 0x35
     db6:	e7c0      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
			{
				int val = currVal;

				if (!m_inputString.equals(""))
				{
					val = GetSerialValue(m_inputString, currVal);
     db8:	f10d 0810 	add.w	r8, sp, #16
     dbc:	4979      	ldr	r1, [pc, #484]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     dbe:	4640      	mov	r0, r8
     dc0:	f005 ff22 	bl	6c08 <String::String(String const&)>
				}
			}

			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
     dc4:	4629      	mov	r1, r5
     dc6:	4640      	mov	r0, r8
     dc8:	f005 ffea 	bl	6da0 <String::operator[](unsigned int)>
     dcc:	7803      	ldrb	r3, [r0, #0]
     dce:	2b23      	cmp	r3, #35	; 0x23
     dd0:	d04f      	beq.n	e72 <Meltdown::tryExecuteCommand() [clone .part.53]+0x1a2>
			{
				int val = currVal;

				if (!m_inputString.equals(""))
				{
					val = GetSerialValue(m_inputString, currVal);
     dd2:	4640      	mov	r0, r8
     dd4:	f005 feb2 	bl	6b3c <String::~String()>
     dd8:	e7a0      	b.n	d1c <Meltdown::tryExecuteCommand() [clone .part.53]+0x4c>
				}
				else if (command.equals(MeltdownSerial.FULL_BLUE))
				{
					MeltdownLED.SetFullBlue();
     dda:	4979      	ldr	r1, [pc, #484]	; (fc0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2f0>)
     ddc:	4620      	mov	r0, r4
     dde:	f005 ffbb 	bl	6d58 <String::equals(String const&) const>
     de2:	4607      	mov	r7, r0
     de4:	b990      	cbnz	r0, e0c <Meltdown::tryExecuteCommand() [clone .part.53]+0x13c>
				}
				else if (command.equals(MeltdownSerial.FULL_GREEN))
				{
					MeltdownLED.SetFullGreen();
     de6:	4977      	ldr	r1, [pc, #476]	; (fc4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2f4>)
     de8:	4620      	mov	r0, r4
     dea:	f005 ffb5 	bl	6d58 <String::equals(String const&) const>
     dee:	4606      	mov	r6, r0
     df0:	2800      	cmp	r0, #0
     df2:	d052      	beq.n	e9a <Meltdown::tryExecuteCommand() [clone .part.53]+0x1ca>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     df4:	4639      	mov	r1, r7
     df6:	486b      	ldr	r0, [pc, #428]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     df8:	f005 ffd2 	bl	6da0 <String::operator[](unsigned int)>
     dfc:	7803      	ldrb	r3, [r0, #0]
     dfe:	2b23      	cmp	r3, #35	; 0x23
     e00:	f000 808c 	beq.w	f1c <Meltdown::tryExecuteCommand() [clone .part.53]+0x24c>
		  bool ToggleFullGreen()
		  {
			  gFullGreen = !gFullGreen;
			  return gFullGreen;
		  }
		  void SetFullGreen() { gFullGreen = MeltdownSerial.GetBoolValue(); }
     e04:	4b66      	ldr	r3, [pc, #408]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     e06:	f883 7037 	strb.w	r7, [r3, #55]	; 0x37
     e0a:	e796      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
     e0c:	4631      	mov	r1, r6
     e0e:	4865      	ldr	r0, [pc, #404]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     e10:	f005 ffc6 	bl	6da0 <String::operator[](unsigned int)>
     e14:	7803      	ldrb	r3, [r0, #0]
     e16:	2b23      	cmp	r3, #35	; 0x23
     e18:	d05a      	beq.n	ed0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x200>
		  bool ToggleFullBlue()
		  {
			  gFullBlue = !gFullBlue;
			  return gFullBlue;
		  }
		  void SetFullBlue() { gFullBlue = MeltdownSerial.GetBoolValue(); }
     e1a:	4b61      	ldr	r3, [pc, #388]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     e1c:	f883 6036 	strb.w	r6, [r3, #54]	; 0x36
     e20:	e78b      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
     e22:	68eb      	ldr	r3, [r5, #12]
     e24:	2b09      	cmp	r3, #9
     e26:	d9c3      	bls.n	db0 <Meltdown::tryExecuteCommand() [clone .part.53]+0xe0>
				{
					String valString = m_inputString.substring(5, 9);
     e28:	2309      	movs	r3, #9
     e2a:	2205      	movs	r2, #5
     e2c:	495d      	ldr	r1, [pc, #372]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     e2e:	a808      	add	r0, sp, #32
     e30:	f005 ffde 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
     e34:	a808      	add	r0, sp, #32
     e36:	f005 ffff 	bl	6e38 <String::toInt() const>
     e3a:	4607      	mov	r7, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
     e3c:	a808      	add	r0, sp, #32
     e3e:	f005 fe7d 	bl	6b3c <String::~String()>
     e42:	3700      	adds	r7, #0
     e44:	bf18      	it	ne
     e46:	2701      	movne	r7, #1
     e48:	e7b2      	b.n	db0 <Meltdown::tryExecuteCommand() [clone .part.53]+0xe0>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     e4a:	68eb      	ldr	r3, [r5, #12]
     e4c:	2b09      	cmp	r3, #9
     e4e:	d98b      	bls.n	d68 <Meltdown::tryExecuteCommand() [clone .part.53]+0x98>
				{
					String valString = m_inputString.substring(5, 9);
     e50:	2309      	movs	r3, #9
     e52:	2205      	movs	r2, #5
     e54:	4953      	ldr	r1, [pc, #332]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     e56:	a808      	add	r0, sp, #32
     e58:	f005 ffca 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
     e5c:	a808      	add	r0, sp, #32
     e5e:	f005 ffeb 	bl	6e38 <String::toInt() const>
     e62:	4606      	mov	r6, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
     e64:	a808      	add	r0, sp, #32
     e66:	f005 fe69 	bl	6b3c <String::~String()>
     e6a:	3600      	adds	r6, #0
     e6c:	bf18      	it	ne
     e6e:	2601      	movne	r6, #1
     e70:	e77a      	b.n	d68 <Meltdown::tryExecuteCommand() [clone .part.53]+0x98>
				}
			}

			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
     e72:	9b06      	ldr	r3, [sp, #24]
     e74:	2b09      	cmp	r3, #9
     e76:	d9ac      	bls.n	dd2 <Meltdown::tryExecuteCommand() [clone .part.53]+0x102>
				{
					String valString = inputString.substring(5, 9);
     e78:	ad08      	add	r5, sp, #32
     e7a:	4628      	mov	r0, r5
     e7c:	2309      	movs	r3, #9
     e7e:	2205      	movs	r2, #5
     e80:	4641      	mov	r1, r8
     e82:	f005 ffb5 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					int val = valString.toInt();
     e86:	4628      	mov	r0, r5
     e88:	f005 ffd6 	bl	6e38 <String::toInt() const>

					// A value of 0 indicates an error but is acceptable if the intended value is actually 0.
					if (val != 0 || valString.equals("0000"))
     e8c:	4681      	mov	r9, r0
     e8e:	b1a8      	cbz	r0, ebc <Meltdown::tryExecuteCommand() [clone .part.53]+0x1ec>
					{
						return val;
     e90:	4628      	mov	r0, r5
     e92:	f005 fe53 	bl	6b3c <String::~String()>
			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
				{
					String valString = inputString.substring(5, 9);
					int val = valString.toInt();
     e96:	464e      	mov	r6, r9
     e98:	e79b      	b.n	dd2 <Meltdown::tryExecuteCommand() [clone .part.53]+0x102>
				}
				else if (command.equals(MeltdownSerial.PAUSE))
				{
					MeltdownLED.SetPause();
     e9a:	494b      	ldr	r1, [pc, #300]	; (fc8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2f8>)
     e9c:	4620      	mov	r0, r4
     e9e:	f005 ff5b 	bl	6d58 <String::equals(String const&) const>
     ea2:	4607      	mov	r7, r0
     ea4:	b340      	cbz	r0, ef8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x228>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     ea6:	4631      	mov	r1, r6
     ea8:	483e      	ldr	r0, [pc, #248]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     eaa:	f005 ff79 	bl	6da0 <String::operator[](unsigned int)>
     eae:	7803      	ldrb	r3, [r0, #0]
     eb0:	2b23      	cmp	r3, #35	; 0x23
     eb2:	d05b      	beq.n	f6c <Meltdown::tryExecuteCommand() [clone .part.53]+0x29c>
		  bool TogglePause()
		  {
			  gPause = !gPause;
			  return gPause;
		  }
		  void SetPause() { gPause = MeltdownSerial.GetBoolValue(); }
     eb4:	4b3a      	ldr	r3, [pc, #232]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     eb6:	f883 603b 	strb.w	r6, [r3, #59]	; 0x3b
     eba:	e73e      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
				{
					String valString = inputString.substring(5, 9);
					int val = valString.toInt();

					// A value of 0 indicates an error but is acceptable if the intended value is actually 0.
					if (val != 0 || valString.equals("0000"))
     ebc:	4943      	ldr	r1, [pc, #268]	; (fcc <Meltdown::tryExecuteCommand() [clone .part.53]+0x2fc>)
     ebe:	4628      	mov	r0, r5
     ec0:	f005 ff58 	bl	6d74 <String::equals(char const*) const>
     ec4:	2800      	cmp	r0, #0
     ec6:	d1e3      	bne.n	e90 <Meltdown::tryExecuteCommand() [clone .part.53]+0x1c0>

			int GetSerialValue(String inputString, int currVal)
			{
				if (inputString[0] == '#' && inputString.length() >= 10)
				{
					String valString = inputString.substring(5, 9);
     ec8:	4628      	mov	r0, r5
     eca:	f005 fe37 	bl	6b3c <String::~String()>
     ece:	e780      	b.n	dd2 <Meltdown::tryExecuteCommand() [clone .part.53]+0x102>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     ed0:	68eb      	ldr	r3, [r5, #12]
     ed2:	2b09      	cmp	r3, #9
     ed4:	d9a1      	bls.n	e1a <Meltdown::tryExecuteCommand() [clone .part.53]+0x14a>
				{
					String valString = m_inputString.substring(5, 9);
     ed6:	2309      	movs	r3, #9
     ed8:	2205      	movs	r2, #5
     eda:	4932      	ldr	r1, [pc, #200]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     edc:	a808      	add	r0, sp, #32
     ede:	f005 ff87 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
     ee2:	a808      	add	r0, sp, #32
     ee4:	f005 ffa8 	bl	6e38 <String::toInt() const>
     ee8:	4606      	mov	r6, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
     eea:	a808      	add	r0, sp, #32
     eec:	f005 fe26 	bl	6b3c <String::~String()>
     ef0:	3600      	adds	r6, #0
     ef2:	bf18      	it	ne
     ef4:	2601      	movne	r6, #1
     ef6:	e790      	b.n	e1a <Meltdown::tryExecuteCommand() [clone .part.53]+0x14a>
				}
				else if (command.equals(MeltdownSerial.BLACK))
				{
					MeltdownLED.SetBlack();
     ef8:	4935      	ldr	r1, [pc, #212]	; (fd0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x300>)
     efa:	4620      	mov	r0, r4
     efc:	f005 ff2c 	bl	6d58 <String::equals(String const&) const>
     f00:	4606      	mov	r6, r0
     f02:	b300      	cbz	r0, f46 <Meltdown::tryExecuteCommand() [clone .part.53]+0x276>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     f04:	4639      	mov	r1, r7
     f06:	4827      	ldr	r0, [pc, #156]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     f08:	f005 ff4a 	bl	6da0 <String::operator[](unsigned int)>
     f0c:	7803      	ldrb	r3, [r0, #0]
     f0e:	2b23      	cmp	r3, #35	; 0x23
     f10:	f000 8093 	beq.w	103a <Meltdown::tryExecuteCommand() [clone .part.53]+0x36a>
		  bool ToggleBlack()
		  {
			  gBlack = !gBlack;
			  return gBlack;
		  }
		  void SetBlack() { gBlack = MeltdownSerial.GetBoolValue(); }
     f14:	4b22      	ldr	r3, [pc, #136]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     f16:	f883 703c 	strb.w	r7, [r3, #60]	; 0x3c
     f1a:	e70e      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
     f1c:	68eb      	ldr	r3, [r5, #12]
     f1e:	2b09      	cmp	r3, #9
     f20:	f67f af70 	bls.w	e04 <Meltdown::tryExecuteCommand() [clone .part.53]+0x134>
				{
					String valString = m_inputString.substring(5, 9);
     f24:	2309      	movs	r3, #9
     f26:	2205      	movs	r2, #5
     f28:	491e      	ldr	r1, [pc, #120]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     f2a:	a808      	add	r0, sp, #32
     f2c:	f005 ff60 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
     f30:	a808      	add	r0, sp, #32
     f32:	f005 ff81 	bl	6e38 <String::toInt() const>
     f36:	4607      	mov	r7, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
     f38:	a808      	add	r0, sp, #32
     f3a:	f005 fdff 	bl	6b3c <String::~String()>
     f3e:	3700      	adds	r7, #0
     f40:	bf18      	it	ne
     f42:	2701      	movne	r7, #1
     f44:	e75e      	b.n	e04 <Meltdown::tryExecuteCommand() [clone .part.53]+0x134>
				}
				else if (command.equals(MeltdownSerial.MIRROR))
				{
					MeltdownLED.SetMirror();
     f46:	4923      	ldr	r1, [pc, #140]	; (fd4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x304>)
     f48:	4620      	mov	r0, r4
     f4a:	f005 ff05 	bl	6d58 <String::equals(String const&) const>
     f4e:	2800      	cmp	r0, #0
     f50:	d042      	beq.n	fd8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x308>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
     f52:	4631      	mov	r1, r6
     f54:	4813      	ldr	r0, [pc, #76]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     f56:	f005 ff23 	bl	6da0 <String::operator[](unsigned int)>
     f5a:	7803      	ldrb	r3, [r0, #0]
     f5c:	2b23      	cmp	r3, #35	; 0x23
     f5e:	f000 80ab 	beq.w	10b8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x3e8>
     f62:	2300      	movs	r3, #0
		  bool ToggleMirror()
		  {
			  gMirror = !gMirror;
			  return gMirror;
		  }
		  void SetMirror() { gMirror = MeltdownSerial.GetBoolValue(); }
     f64:	4a0e      	ldr	r2, [pc, #56]	; (fa0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d0>)
     f66:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
     f6a:	e6e6      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
     f6c:	68eb      	ldr	r3, [r5, #12]
     f6e:	2b09      	cmp	r3, #9
     f70:	d9a0      	bls.n	eb4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x1e4>
				{
					String valString = m_inputString.substring(5, 9);
     f72:	2309      	movs	r3, #9
     f74:	2205      	movs	r2, #5
     f76:	490b      	ldr	r1, [pc, #44]	; (fa4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x2d4>)
     f78:	a808      	add	r0, sp, #32
     f7a:	f005 ff39 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
     f7e:	a808      	add	r0, sp, #32
     f80:	f005 ff5a 	bl	6e38 <String::toInt() const>
     f84:	4606      	mov	r6, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
     f86:	a808      	add	r0, sp, #32
     f88:	f005 fdd8 	bl	6b3c <String::~String()>
     f8c:	3600      	adds	r6, #0
     f8e:	bf18      	it	ne
     f90:	2601      	movne	r6, #1
     f92:	e78f      	b.n	eb4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x1e4>
     f94:	1fffb2c8 	.word	0x1fffb2c8
     f98:	0000933c 	.word	0x0000933c
     f9c:	1fffb310 	.word	0x1fffb310
     fa0:	1fffb06c 	.word	0x1fffb06c
     fa4:	1fffb2cc 	.word	0x1fffb2cc
     fa8:	1fffb044 	.word	0x1fffb044
     fac:	00009268 	.word	0x00009268
     fb0:	1fffb2c4 	.word	0x1fffb2c4
     fb4:	1fffb320 	.word	0x1fffb320
     fb8:	1fff8760 	.word	0x1fff8760
     fbc:	1fffb330 	.word	0x1fffb330
     fc0:	1fffb340 	.word	0x1fffb340
     fc4:	1fffb350 	.word	0x1fffb350
     fc8:	1fffb3c0 	.word	0x1fffb3c0
     fcc:	00009138 	.word	0x00009138
     fd0:	1fffb430 	.word	0x1fffb430
     fd4:	1fffb360 	.word	0x1fffb360
				}
				else if (command.equals(MeltdownSerial.PATTERN))
				{
					// Set to black.
     fd8:	49b5      	ldr	r1, [pc, #724]	; (12b0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5e0>)
     fda:	4620      	mov	r0, r4
     fdc:	f005 febc 	bl	6d58 <String::equals(String const&) const>
     fe0:	2800      	cmp	r0, #0
     fe2:	d040      	beq.n	1066 <Meltdown::tryExecuteCommand() [clone .part.53]+0x396>
					setIndexesForAll();
					MeltdownLED.SetAllColor(leds, ledIndexes, NUM_LEDS, CRGB::Black);

     fe4:	f7ff fe58 	bl	c98 <Meltdown::setIndexesForAll()>
     fe8:	4ab2      	ldr	r2, [pc, #712]	; (12b4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5e4>)
     fea:	4db3      	ldr	r5, [pc, #716]	; (12b8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5e8>)
     fec:	f602 36b8 	addw	r6, r2, #3000	; 0xbb8
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     ff0:	2100      	movs	r1, #0

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
			  {
				  leds[indexes[i]] = color;
     ff2:	f832 3f02 	ldrh.w	r3, [r2, #2]!
     ff6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     ffa:	18e8      	adds	r0, r5, r3

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
     ffc:	4296      	cmp	r6, r2
     ffe:	54e9      	strb	r1, [r5, r3]
    1000:	f04f 0300 	mov.w	r3, #0
        g = (colorcode >>  8) & 0xFF;
    1004:	7041      	strb	r1, [r0, #1]
        b = (colorcode >>  0) & 0xFF;
    1006:	7081      	strb	r1, [r0, #2]
    1008:	d1f3      	bne.n	ff2 <Meltdown::tryExecuteCommand() [clone .part.53]+0x322>
		  }
		  void SetBottom() { gBottom = MeltdownSerial.GetBoolValue(); }

		  bool GetBottom() { return gBottom; }

		  void ResetFrame() { gFrame = 1; }
    100a:	4eac      	ldr	r6, [pc, #688]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
		  int SetPatternNumber()
		  {
			  ResetFrame();
			  ResetDelay();

			  gCurrentPatternNumber = MeltdownSerial.GetValue();
    100c:	48ac      	ldr	r0, [pc, #688]	; (12c0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f0>)

		  // DELAY //

		  int GetDelay() { return gDelay; }

		  void ResetDelay() { gDelay = 0; }
    100e:	61b3      	str	r3, [r6, #24]
		  }
		  void SetBottom() { gBottom = MeltdownSerial.GetBoolValue(); }

		  bool GetBottom() { return gBottom; }

		  void ResetFrame() { gFrame = 1; }
    1010:	2301      	movs	r3, #1
    1012:	62f3      	str	r3, [r6, #44]	; 0x2c
		  int SetPatternNumber()
		  {
			  ResetFrame();
			  ResetDelay();

			  gCurrentPatternNumber = MeltdownSerial.GetValue();
    1014:	f7ff fe1e 	bl	c54 <Meltdown::CMeltdownSerial::GetValue()>
					int patternNumber = MeltdownLED.SetPatternNumber();
					MeltdownLogger.Debug(Serial, F("Setting pattern number"), patternNumber);
				}
				else if (command.equals(MeltdownSerial.TOP))
    1018:	ad08      	add	r5, sp, #32
    101a:	6030      	str	r0, [r6, #0]
    101c:	4607      	mov	r7, r0
    101e:	49a9      	ldr	r1, [pc, #676]	; (12c4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f4>)
    1020:	4628      	mov	r0, r5
    1022:	f005 fddf 	bl	6be4 <String::String(__FlashStringHelper const*)>
			serial.println(value);
		}

		void Debug(Stream &serial, String msg, int value)
		{
			if (!m_isDebug) return;
    1026:	4ba8      	ldr	r3, [pc, #672]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    1028:	781b      	ldrb	r3, [r3, #0]
    102a:	2b00      	cmp	r3, #0
    102c:	f43f ae82 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    1030:	4639      	mov	r1, r7
    1032:	4628      	mov	r0, r5
    1034:	f7ff fdba 	bl	bac <Meltdown::CMeltdownLogger::Debug(Stream&, String, int) [clone .part.7] [clone .constprop.62]>
    1038:	e67c      	b.n	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
    103a:	68eb      	ldr	r3, [r5, #12]
    103c:	2b09      	cmp	r3, #9
    103e:	d801      	bhi.n	1044 <Meltdown::tryExecuteCommand() [clone .part.53]+0x374>
    1040:	2700      	movs	r7, #0
    1042:	e767      	b.n	f14 <Meltdown::tryExecuteCommand() [clone .part.53]+0x244>
				{
					String valString = m_inputString.substring(5, 9);
    1044:	2309      	movs	r3, #9
    1046:	2205      	movs	r2, #5
    1048:	49a0      	ldr	r1, [pc, #640]	; (12cc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5fc>)
    104a:	a808      	add	r0, sp, #32
    104c:	f005 fed0 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
    1050:	a808      	add	r0, sp, #32
    1052:	f005 fef1 	bl	6e38 <String::toInt() const>
    1056:	4607      	mov	r7, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
    1058:	a808      	add	r0, sp, #32
    105a:	f005 fd6f 	bl	6b3c <String::~String()>
    105e:	3700      	adds	r7, #0
    1060:	bf18      	it	ne
    1062:	2701      	movne	r7, #1
    1064:	e756      	b.n	f14 <Meltdown::tryExecuteCommand() [clone .part.53]+0x244>
				{
					bool topVal = MeltdownLED.ToggleTop();
    1066:	4d9a      	ldr	r5, [pc, #616]	; (12d0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x600>)
    1068:	4620      	mov	r0, r4
    106a:	4629      	mov	r1, r5
    106c:	f005 fe74 	bl	6d58 <String::equals(String const&) const>
    1070:	4607      	mov	r7, r0
    1072:	2800      	cmp	r0, #0
    1074:	d035      	beq.n	10e2 <Meltdown::tryExecuteCommand() [clone .part.53]+0x412>

		  // POSITION //

		  bool ToggleTop()
		  {
			  gBottom = false;
    1076:	4b91      	ldr	r3, [pc, #580]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
					MeltdownLogger.Debug(Serial, F("Setting top position"), topVal);
				}
				else if (command.equals(MeltdownSerial.BOTTOM))
    1078:	4996      	ldr	r1, [pc, #600]	; (12d4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x604>)
			  gTop = !gTop;
    107a:	f893 603d 	ldrb.w	r6, [r3, #61]	; 0x3d

		  // POSITION //

		  bool ToggleTop()
		  {
			  gBottom = false;
    107e:	2200      	movs	r2, #0
    1080:	ad08      	add	r5, sp, #32
			  gTop = !gTop;
    1082:	f086 0601 	eor.w	r6, r6, #1

		  // POSITION //

		  bool ToggleTop()
		  {
			  gBottom = false;
    1086:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
			  gTop = !gTop;
    108a:	f883 603d 	strb.w	r6, [r3, #61]	; 0x3d
    108e:	4628      	mov	r0, r5
    1090:	f005 fda8 	bl	6be4 <String::String(__FlashStringHelper const*)>
			serial.println(value);
		}

		void Debug(Stream &serial, String msg, bool value)
		{
			if (!m_isDebug) return;
    1094:	4b8c      	ldr	r3, [pc, #560]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    1096:	781b      	ldrb	r3, [r3, #0]
    1098:	2b00      	cmp	r3, #0
    109a:	f43f ae4b 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>

			serial.print(msg);
    109e:	4629      	mov	r1, r5
    10a0:	488d      	ldr	r0, [pc, #564]	; (12d8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x608>)
    10a2:	f005 fc79 	bl	6998 <Print::print(String const&)>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    10a6:	498d      	ldr	r1, [pc, #564]	; (12dc <Meltdown::tryExecuteCommand() [clone .part.53]+0x60c>)
    10a8:	488b      	ldr	r0, [pc, #556]	; (12d8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x608>)
    10aa:	f7ff fd5d 	bl	b68 <Print::write(char const*)>
			serial.print(": ");
			serial.println(value);
    10ae:	4631      	mov	r1, r6
    10b0:	4889      	ldr	r0, [pc, #548]	; (12d8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x608>)
    10b2:	f7ff fd71 	bl	b98 <Print::println(int)>
    10b6:	e63d      	b.n	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
			}

			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
    10b8:	68eb      	ldr	r3, [r5, #12]
    10ba:	2b09      	cmp	r3, #9
    10bc:	f67f af51 	bls.w	f62 <Meltdown::tryExecuteCommand() [clone .part.53]+0x292>
				{
					String valString = m_inputString.substring(5, 9);
    10c0:	2309      	movs	r3, #9
    10c2:	2205      	movs	r2, #5
    10c4:	4981      	ldr	r1, [pc, #516]	; (12cc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5fc>)
    10c6:	a808      	add	r0, sp, #32
    10c8:	f005 fe92 	bl	6df0 <String::substring(unsigned int, unsigned int) const>
					val = valString.toInt();
    10cc:	a808      	add	r0, sp, #32
    10ce:	f005 feb3 	bl	6e38 <String::toInt() const>
    10d2:	4605      	mov	r5, r0
			int GetValue()
			{
				int val = 0;
				if (m_inputString[0] == '#' && m_inputString.length() >= 10)
				{
					String valString = m_inputString.substring(5, 9);
    10d4:	a808      	add	r0, sp, #32
    10d6:	f005 fd31 	bl	6b3c <String::~String()>
    10da:	1c2b      	adds	r3, r5, #0
    10dc:	bf18      	it	ne
    10de:	2301      	movne	r3, #1
    10e0:	e740      	b.n	f64 <Meltdown::tryExecuteCommand() [clone .part.53]+0x294>
				{
					bool bottomVal = MeltdownLED.ToggleBottom();
    10e2:	f105 0110 	add.w	r1, r5, #16
    10e6:	4620      	mov	r0, r4
    10e8:	f005 fe36 	bl	6d58 <String::equals(String const&) const>
    10ec:	b198      	cbz	r0, 1116 <Meltdown::tryExecuteCommand() [clone .part.53]+0x446>

		  bool GetTop() { return gTop; }

		  bool ToggleBottom()
		  {
			  gTop = false;
    10ee:	4b73      	ldr	r3, [pc, #460]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
					MeltdownLogger.Debug(Serial, F("Setting bottom position"), bottomVal);
				}
				else if (command.equals(MeltdownSerial.EFFECT))
    10f0:	497b      	ldr	r1, [pc, #492]	; (12e0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x610>)
			  gBottom = !gBottom;
    10f2:	f893 603e 	ldrb.w	r6, [r3, #62]	; 0x3e

		  bool GetTop() { return gTop; }

		  bool ToggleBottom()
		  {
			  gTop = false;
    10f6:	f883 703d 	strb.w	r7, [r3, #61]	; 0x3d
    10fa:	ad08      	add	r5, sp, #32
			  gBottom = !gBottom;
    10fc:	f086 0601 	eor.w	r6, r6, #1
    1100:	f883 603e 	strb.w	r6, [r3, #62]	; 0x3e
    1104:	4628      	mov	r0, r5
    1106:	f005 fd6d 	bl	6be4 <String::String(__FlashStringHelper const*)>
			serial.println(value);
		}

		void Debug(Stream &serial, String msg, bool value)
		{
			if (!m_isDebug) return;
    110a:	4b6f      	ldr	r3, [pc, #444]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    110c:	781b      	ldrb	r3, [r3, #0]
    110e:	2b00      	cmp	r3, #0
    1110:	f43f ae10 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    1114:	e7c3      	b.n	109e <Meltdown::tryExecuteCommand() [clone .part.53]+0x3ce>
				{
					int effectNumber = MeltdownLED.SetEffectNumber();
    1116:	f1a5 0180 	sub.w	r1, r5, #128	; 0x80
    111a:	4620      	mov	r0, r4
    111c:	f005 fe1c 	bl	6d58 <String::equals(String const&) const>
    1120:	4606      	mov	r6, r0
    1122:	b1a8      	cbz	r0, 1150 <Meltdown::tryExecuteCommand() [clone .part.53]+0x480>
			  return gCurrentEffectNumber;
		  }

		  int SetEffectNumber()
		  {
			  gCurrentEffectNumber = MeltdownSerial.GetValue();
    1124:	f1a5 00a8 	sub.w	r0, r5, #168	; 0xa8
    1128:	f7ff fd94 	bl	c54 <Meltdown::CMeltdownSerial::GetValue()>
    112c:	4b63      	ldr	r3, [pc, #396]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
					MeltdownLogger.Debug(Serial, F("Setting effect number"), effectNumber);
				}
				else if (command.equals(MeltdownSerial.MODE))
    112e:	496d      	ldr	r1, [pc, #436]	; (12e4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x614>)
    1130:	6058      	str	r0, [r3, #4]
    1132:	4606      	mov	r6, r0
    1134:	ad08      	add	r5, sp, #32
				{
					int modeNumber = MeltdownLED.SetModeNumber();
					MeltdownLogger.Debug(Serial, F("Setting mode number"), modeNumber);
				}
				else if (command.equals(MeltdownSerial.ANALOG_EFFECT))
    1136:	4628      	mov	r0, r5
    1138:	f005 fd54 	bl	6be4 <String::String(__FlashStringHelper const*)>
			serial.println(value);
		}

		void Debug(Stream &serial, String msg, int value)
		{
			if (!m_isDebug) return;
    113c:	4b62      	ldr	r3, [pc, #392]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    113e:	781b      	ldrb	r3, [r3, #0]
    1140:	2b00      	cmp	r3, #0
    1142:	f43f adf7 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    1146:	4631      	mov	r1, r6
    1148:	4628      	mov	r0, r5
    114a:	f7ff fd2f 	bl	bac <Meltdown::CMeltdownLogger::Debug(Stream&, String, int) [clone .part.7] [clone .constprop.62]>
    114e:	e5f1      	b.n	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
					int effectNumber = MeltdownLED.SetEffectNumber();
					MeltdownLogger.Debug(Serial, F("Setting effect number"), effectNumber);
				}
				else if (command.equals(MeltdownSerial.MODE))
				{
					int modeNumber = MeltdownLED.SetModeNumber();
    1150:	f1a5 0170 	sub.w	r1, r5, #112	; 0x70
    1154:	4620      	mov	r0, r4
    1156:	f005 fdff 	bl	6d58 <String::equals(String const&) const>
    115a:	b300      	cbz	r0, 119e <Meltdown::tryExecuteCommand() [clone .part.53]+0x4ce>
		  }

		  int SetModeNumber()
		  {
			  // TODO - I'm trying to randomize the global palette. This is hacky, do something better?
			  while (gLastRandomPaletteNumber == gRandomPaletteNumber)
    115c:	4f57      	ldr	r7, [pc, #348]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
    115e:	4862      	ldr	r0, [pc, #392]	; (12e8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x618>)
    1160:	68fd      	ldr	r5, [r7, #12]
    1162:	6939      	ldr	r1, [r7, #16]
    1164:	8803      	ldrh	r3, [r0, #0]
    1166:	e005      	b.n	1174 <Meltdown::tryExecuteCommand() [clone .part.53]+0x4a4>
extern uint16_t rand16seed;// = RAND16_SEED;

/// Generate an 8-bit random number
LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    1168:	b293      	uxth	r3, r2
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
    116a:	eb03 2113 	add.w	r1, r3, r3, lsr #8
			  {
				  gRandomPaletteNumber = random8(8);
    116e:	f3c1 1142 	ubfx	r1, r1, #5, #3
    1172:	2601      	movs	r6, #1
extern uint16_t rand16seed;// = RAND16_SEED;

/// Generate an 8-bit random number
LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    1174:	eb03 2243 	add.w	r2, r3, r3, lsl #9
    1178:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    117c:	f502 5258 	add.w	r2, r2, #13824	; 0x3600
		  }

		  int SetModeNumber()
		  {
			  // TODO - I'm trying to randomize the global palette. This is hacky, do something better?
			  while (gLastRandomPaletteNumber == gRandomPaletteNumber)
    1180:	42a9      	cmp	r1, r5
    1182:	f102 0219 	add.w	r2, r2, #25
    1186:	d0ef      	beq.n	1168 <Meltdown::tryExecuteCommand() [clone .part.53]+0x498>
    1188:	2e00      	cmp	r6, #0
    118a:	d174      	bne.n	1276 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5a6>
			  {
				  gRandomPaletteNumber = random8(8);
			  }
			  gLastRandomPaletteNumber = gRandomPaletteNumber;

			  gCurrentModeNumber = MeltdownSerial.GetValue();
    118c:	484c      	ldr	r0, [pc, #304]	; (12c0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f0>)
			  // TODO - I'm trying to randomize the global palette. This is hacky, do something better?
			  while (gLastRandomPaletteNumber == gRandomPaletteNumber)
			  {
				  gRandomPaletteNumber = random8(8);
			  }
			  gLastRandomPaletteNumber = gRandomPaletteNumber;
    118e:	60f9      	str	r1, [r7, #12]

			  gCurrentModeNumber = MeltdownSerial.GetValue();
    1190:	f7ff fd60 	bl	c54 <Meltdown::CMeltdownSerial::GetValue()>
					MeltdownLogger.Debug(Serial, F("Setting mode number"), modeNumber);
				}
				else if (command.equals(MeltdownSerial.ANALOG_EFFECT))
    1194:	ad08      	add	r5, sp, #32
    1196:	4606      	mov	r6, r0
    1198:	4954      	ldr	r1, [pc, #336]	; (12ec <Meltdown::tryExecuteCommand() [clone .part.53]+0x61c>)
    119a:	60b8      	str	r0, [r7, #8]
    119c:	e7cb      	b.n	1136 <Meltdown::tryExecuteCommand() [clone .part.53]+0x466>
				{
					int currVal = MeltdownLED.GetAnalogEffect();
    119e:	f105 0140 	add.w	r1, r5, #64	; 0x40
    11a2:	4620      	mov	r0, r4
    11a4:	f005 fdd8 	bl	6d58 <String::equals(String const&) const>
    11a8:	b1f8      	cbz	r0, 11ea <Meltdown::tryExecuteCommand() [clone .part.53]+0x51a>
    11aa:	f8df 8110 	ldr.w	r8, [pc, #272]	; 12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>
    11ae:	f8d8 7020 	ldr.w	r7, [r8, #32]

			int GetAnalogValue(int pin, int currVal)
			{
				if (pin == -1)
				{
					return GetAnalogValue(currVal);
    11b2:	f1a5 00a8 	sub.w	r0, r5, #168	; 0xa8
    11b6:	4639      	mov	r1, r7
    11b8:	f7ff fd0c 	bl	bd4 <Meltdown::CMeltdownSerial::GetAnalogValue(int)>
    11bc:	f855 3ca8 	ldr.w	r3, [r5, #-168]

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }

		  int SetAnalogEffect(int pin)
		  {
			  gAnalogEffect = MeltdownSerial.GetAnalogValue(pin, gAnalogEffect);
    11c0:	f8c8 0020 	str.w	r0, [r8, #32]
			// Because an analog read can waiver between values, we need to determine if an analog value has changed enough
			// for us to do anything about.
			bool HasChanged(int oldVal, int newVal)
			{
				// Otherwise, check that the value has surpassed the tolerance threshold.
				return newVal <= (oldVal - m_analogTolerance) || newVal >= (oldVal + m_analogTolerance);
    11c4:	1afa      	subs	r2, r7, r3
    11c6:	4282      	cmp	r2, r0

			int GetAnalogValue(int pin, int currVal)
			{
				if (pin == -1)
				{
					return GetAnalogValue(currVal);
    11c8:	4606      	mov	r6, r0
			// Because an analog read can waiver between values, we need to determine if an analog value has changed enough
			// for us to do anything about.
			bool HasChanged(int oldVal, int newVal)
			{
				// Otherwise, check that the value has surpassed the tolerance threshold.
				return newVal <= (oldVal - m_analogTolerance) || newVal >= (oldVal + m_analogTolerance);
    11ca:	da03      	bge.n	11d4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x504>
    11cc:	443b      	add	r3, r7
    11ce:	4283      	cmp	r3, r0
    11d0:	f73f adb3 	bgt.w	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>

					if (MeltdownSerial.HasChanged(currVal, modeVal))
					{
						MeltdownLogger.Debug(Serial, F("Setting Analog Effect"), modeVal);
					}
				}
    11d4:	ad08      	add	r5, sp, #32
    11d6:	4628      	mov	r0, r5
    11d8:	4945      	ldr	r1, [pc, #276]	; (12f0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x620>)
    11da:	f005 fd03 	bl	6be4 <String::String(__FlashStringHelper const*)>
    11de:	4b3a      	ldr	r3, [pc, #232]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    11e0:	781b      	ldrb	r3, [r3, #0]
    11e2:	2b00      	cmp	r3, #0
    11e4:	f43f ada6 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    11e8:	e7ad      	b.n	1146 <Meltdown::tryExecuteCommand() [clone .part.53]+0x476>
				else if (command.equals(MeltdownSerial.ANALOG_PATTERN))
				{
					int currVal = MeltdownLED.GetAnalogPattern();
    11ea:	f105 0130 	add.w	r1, r5, #48	; 0x30
    11ee:	4620      	mov	r0, r4
    11f0:	f005 fdb2 	bl	6d58 <String::equals(String const&) const>
    11f4:	4606      	mov	r6, r0
    11f6:	b1f8      	cbz	r0, 1238 <Meltdown::tryExecuteCommand() [clone .part.53]+0x568>
    11f8:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>
    11fc:	f8d8 701c 	ldr.w	r7, [r8, #28]

			int GetAnalogValue(int pin, int currVal)
			{
				if (pin == -1)
				{
					return GetAnalogValue(currVal);
    1200:	f1a5 00a8 	sub.w	r0, r5, #168	; 0xa8
    1204:	4639      	mov	r1, r7
    1206:	f7ff fce5 	bl	bd4 <Meltdown::CMeltdownSerial::GetAnalogValue(int)>
    120a:	f855 3ca8 	ldr.w	r3, [r5, #-168]

		  // ANALOG //

		  int SetAnalogPattern(int pin)
		  {
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
    120e:	f8c8 001c 	str.w	r0, [r8, #28]
			// Because an analog read can waiver between values, we need to determine if an analog value has changed enough
			// for us to do anything about.
			bool HasChanged(int oldVal, int newVal)
			{
				// Otherwise, check that the value has surpassed the tolerance threshold.
				return newVal <= (oldVal - m_analogTolerance) || newVal >= (oldVal + m_analogTolerance);
    1212:	1afa      	subs	r2, r7, r3
    1214:	4282      	cmp	r2, r0

			int GetAnalogValue(int pin, int currVal)
			{
				if (pin == -1)
				{
					return GetAnalogValue(currVal);
    1216:	4606      	mov	r6, r0
			// Because an analog read can waiver between values, we need to determine if an analog value has changed enough
			// for us to do anything about.
			bool HasChanged(int oldVal, int newVal)
			{
				// Otherwise, check that the value has surpassed the tolerance threshold.
				return newVal <= (oldVal - m_analogTolerance) || newVal >= (oldVal + m_analogTolerance);
    1218:	da03      	bge.n	1222 <Meltdown::tryExecuteCommand() [clone .part.53]+0x552>
    121a:	443b      	add	r3, r7
    121c:	4283      	cmp	r3, r0
    121e:	f73f ad8c 	bgt.w	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>

					if (MeltdownSerial.HasChanged(currVal, patternVal))
					{
						MeltdownLogger.Debug(Serial, F("Setting Analog Pattern"), patternVal);
					}
				}
    1222:	ad08      	add	r5, sp, #32
    1224:	4628      	mov	r0, r5
    1226:	4933      	ldr	r1, [pc, #204]	; (12f4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x624>)
    1228:	f005 fcdc 	bl	6be4 <String::String(__FlashStringHelper const*)>
    122c:	4b26      	ldr	r3, [pc, #152]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    122e:	781b      	ldrb	r3, [r3, #0]
    1230:	2b00      	cmp	r3, #0
    1232:	f43f ad7f 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    1236:	e786      	b.n	1146 <Meltdown::tryExecuteCommand() [clone .part.53]+0x476>
				else if (command.equals(MeltdownSerial.AUTO_NONE))
				{
					MeltdownLED.SetAutoMode(MeltdownLED.None);
    1238:	f105 0170 	add.w	r1, r5, #112	; 0x70
    123c:	4620      	mov	r0, r4
    123e:	f005 fd8b 	bl	6d58 <String::equals(String const&) const>
    1242:	b1d8      	cbz	r0, 127c <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ac>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1244:	4a2c      	ldr	r2, [pc, #176]	; (12f8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x628>)

		  // AUTO MODE //

		  void SetAutoMode(AutoMode mode)
		  {
			  gAutoMode = mode;
    1246:	4b1d      	ldr	r3, [pc, #116]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
    1248:	6812      	ldr	r2, [r2, #0]
    124a:	9204      	str	r2, [sp, #16]
	return ret;
    124c:	9a04      	ldr	r2, [sp, #16]
		  {
			  gAutoModeActive = isActive;
			  // If we're waking up, reset the timer.
			  if (!gAutoModeActive)
			  {
				  gAutoModeStartMillis = millis();
    124e:	649a      	str	r2, [r3, #72]	; 0x48
					MeltdownLogger.Debug(Serial, F("Disabling Auto Mode."));
				}
				else if (command.equals(MeltdownSerial.AUTO_PATTERN))
    1250:	ad08      	add	r5, sp, #32

		  bool IsAutoSleep() { return gAutoMode == Sleep; }

		  bool SetAutoModeActive(bool isActive)
		  {
			  gAutoModeActive = isActive;
    1252:	f883 603f 	strb.w	r6, [r3, #63]	; 0x3f
    1256:	4929      	ldr	r1, [pc, #164]	; (12fc <Meltdown::tryExecuteCommand() [clone .part.53]+0x62c>)

		  // AUTO MODE //

		  void SetAutoMode(AutoMode mode)
		  {
			  gAutoMode = mode;
    1258:	f883 6040 	strb.w	r6, [r3, #64]	; 0x40
    125c:	4628      	mov	r0, r5
    125e:	f005 fcc1 	bl	6be4 <String::String(__FlashStringHelper const*)>
			m_isDebug = isDebug;
		}

		void Debug(Stream &serial, String msg)
		{
			if (!m_isDebug) return;
    1262:	4b19      	ldr	r3, [pc, #100]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    1264:	781b      	ldrb	r3, [r3, #0]
    1266:	2b00      	cmp	r3, #0
    1268:	f43f ad64 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>

			serial.println(msg);
    126c:	4629      	mov	r1, r5
    126e:	481a      	ldr	r0, [pc, #104]	; (12d8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x608>)
    1270:	f7ff fc88 	bl	b84 <Print::println(String const&)>
    1274:	e55e      	b.n	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    1276:	8003      	strh	r3, [r0, #0]
    1278:	6139      	str	r1, [r7, #16]
    127a:	e787      	b.n	118c <Meltdown::tryExecuteCommand() [clone .part.53]+0x4bc>
				{
					MeltdownLED.SetAutoMode(MeltdownLED.Pattern);
    127c:	f105 0190 	add.w	r1, r5, #144	; 0x90
    1280:	4620      	mov	r0, r4
    1282:	f005 fd69 	bl	6d58 <String::equals(String const&) const>
    1286:	2800      	cmp	r0, #0
    1288:	d03c      	beq.n	1304 <Meltdown::tryExecuteCommand() [clone .part.53]+0x634>
    128a:	4b0c      	ldr	r3, [pc, #48]	; (12bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ec>)
					MeltdownLogger.Debug(Serial, F("Setting Auto Pattern Mode."));
				}
				else if (command.equals(MeltdownSerial.AUTO_MODE))
    128c:	491c      	ldr	r1, [pc, #112]	; (1300 <Meltdown::tryExecuteCommand() [clone .part.53]+0x630>)
    128e:	ad08      	add	r5, sp, #32
    1290:	2602      	movs	r6, #2

		  bool IsAutoSleep() { return gAutoMode == Sleep; }

		  bool SetAutoModeActive(bool isActive)
		  {
			  gAutoModeActive = isActive;
    1292:	2201      	movs	r2, #1
    1294:	4628      	mov	r0, r5

		  // AUTO MODE //

		  void SetAutoMode(AutoMode mode)
		  {
			  gAutoMode = mode;
    1296:	f883 6040 	strb.w	r6, [r3, #64]	; 0x40

		  bool IsAutoSleep() { return gAutoMode == Sleep; }

		  bool SetAutoModeActive(bool isActive)
		  {
			  gAutoModeActive = isActive;
    129a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
				else if (command.equals(MeltdownSerial.AUTO_SLEEP))
				{
					MeltdownLED.SetAutoMode(MeltdownLED.Sleep);
					MeltdownLogger.Debug(Serial, F("Setting Auto Sleep Mode."));
				}
				else
    129e:	f005 fca1 	bl	6be4 <String::String(__FlashStringHelper const*)>
			m_isDebug = isDebug;
		}

		void Debug(Stream &serial, String msg)
		{
			if (!m_isDebug) return;
    12a2:	4b09      	ldr	r3, [pc, #36]	; (12c8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x5f8>)
    12a4:	781b      	ldrb	r3, [r3, #0]
    12a6:	2b00      	cmp	r3, #0
    12a8:	f43f ad44 	beq.w	d34 <Meltdown::tryExecuteCommand() [clone .part.53]+0x64>
    12ac:	e7de      	b.n	126c <Meltdown::tryExecuteCommand() [clone .part.53]+0x59c>
    12ae:	bf00      	nop
    12b0:	1fffb2e0 	.word	0x1fffb2e0
    12b4:	1fff924a 	.word	0x1fff924a
    12b8:	1fff9e34 	.word	0x1fff9e34
    12bc:	1fffb06c 	.word	0x1fffb06c
    12c0:	1fffb2c8 	.word	0x1fffb2c8
    12c4:	00009140 	.word	0x00009140
    12c8:	1fffb2c4 	.word	0x1fffb2c4
    12cc:	1fffb2cc 	.word	0x1fffb2cc
    12d0:	1fffb370 	.word	0x1fffb370
    12d4:	00009158 	.word	0x00009158
    12d8:	1fff8760 	.word	0x1fff8760
    12dc:	00009134 	.word	0x00009134
    12e0:	00009170 	.word	0x00009170
    12e4:	00009188 	.word	0x00009188
    12e8:	1fff8724 	.word	0x1fff8724
    12ec:	000091a0 	.word	0x000091a0
    12f0:	000092a0 	.word	0x000092a0
    12f4:	000092b8 	.word	0x000092b8
    12f8:	1fffb440 	.word	0x1fffb440
    12fc:	000091b4 	.word	0x000091b4
    1300:	000091cc 	.word	0x000091cc
					MeltdownLED.SetAutoMode(MeltdownLED.Pattern);
					MeltdownLogger.Debug(Serial, F("Setting Auto Pattern Mode."));
				}
				else if (command.equals(MeltdownSerial.AUTO_MODE))
				{
					MeltdownLED.SetAutoMode(MeltdownLED.Mode);
    1304:	f105 01a0 	add.w	r1, r5, #160	; 0xa0
    1308:	4620      	mov	r0, r4
    130a:	f005 fd25 	bl	6d58 <String::equals(String const&) const>
    130e:	b140      	cbz	r0, 1322 <Meltdown::tryExecuteCommand() [clone .part.53]+0x652>

		  // AUTO MODE //

		  void SetAutoMode(AutoMode mode)
		  {
			  gAutoMode = mode;
    1310:	4b24      	ldr	r3, [pc, #144]	; (13a4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6d4>)
					MeltdownLogger.Debug(Serial, F("Setting Auto Mode Mode."));
				}
				else if (command.equals(MeltdownSerial.AUTO_PATTERN_MODE))
    1312:	4925      	ldr	r1, [pc, #148]	; (13a8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6d8>)
    1314:	ad08      	add	r5, sp, #32
    1316:	2603      	movs	r6, #3

		  bool IsAutoSleep() { return gAutoMode == Sleep; }

		  bool SetAutoModeActive(bool isActive)
		  {
			  gAutoModeActive = isActive;
    1318:	2201      	movs	r2, #1
    131a:	4628      	mov	r0, r5

		  // AUTO MODE //

		  void SetAutoMode(AutoMode mode)
		  {
			  gAutoMode = mode;
    131c:	f883 6040 	strb.w	r6, [r3, #64]	; 0x40
    1320:	e7bb      	b.n	129a <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ca>
				{
					MeltdownLED.SetAutoMode(MeltdownLED.PatternMode);
    1322:	f105 01b0 	add.w	r1, r5, #176	; 0xb0
    1326:	4620      	mov	r0, r4
    1328:	f005 fd16 	bl	6d58 <String::equals(String const&) const>
    132c:	b140      	cbz	r0, 1340 <Meltdown::tryExecuteCommand() [clone .part.53]+0x670>
    132e:	4b1d      	ldr	r3, [pc, #116]	; (13a4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6d4>)
					MeltdownLogger.Debug(Serial, F("Setting Auto Pattern Mode Mode."));
				}
				else if (command.equals(MeltdownSerial.AUTO_SLEEP))
    1330:	491e      	ldr	r1, [pc, #120]	; (13ac <Meltdown::tryExecuteCommand() [clone .part.53]+0x6dc>)
    1332:	ad08      	add	r5, sp, #32
    1334:	2604      	movs	r6, #4

		  bool IsAutoSleep() { return gAutoMode == Sleep; }

		  bool SetAutoModeActive(bool isActive)
		  {
			  gAutoModeActive = isActive;
    1336:	2201      	movs	r2, #1
    1338:	4628      	mov	r0, r5

		  // AUTO MODE //

		  void SetAutoMode(AutoMode mode)
		  {
			  gAutoMode = mode;
    133a:	f883 6040 	strb.w	r6, [r3, #64]	; 0x40
    133e:	e7ac      	b.n	129a <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ca>
				{
					MeltdownLED.SetAutoMode(MeltdownLED.Sleep);
    1340:	491b      	ldr	r1, [pc, #108]	; (13b0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6e0>)
    1342:	4620      	mov	r0, r4
    1344:	f005 fd08 	bl	6d58 <String::equals(String const&) const>
    1348:	b138      	cbz	r0, 135a <Meltdown::tryExecuteCommand() [clone .part.53]+0x68a>
    134a:	4b16      	ldr	r3, [pc, #88]	; (13a4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6d4>)
					MeltdownLogger.Debug(Serial, F("Setting Auto Sleep Mode."));
				}
				else
    134c:	4919      	ldr	r1, [pc, #100]	; (13b4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6e4>)
    134e:	ad08      	add	r5, sp, #32
    1350:	2201      	movs	r2, #1
    1352:	4628      	mov	r0, r5
    1354:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    1358:	e79f      	b.n	129a <Meltdown::tryExecuteCommand() [clone .part.53]+0x5ca>
				{
					MeltdownLogger.Debug(Serial, F("Something went wrong reading serial command"), command);
				}
			}
    135a:	ad08      	add	r5, sp, #32
    135c:	4916      	ldr	r1, [pc, #88]	; (13b8 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6e8>)
    135e:	4628      	mov	r0, r5
    1360:	f10d 0810 	add.w	r8, sp, #16
    1364:	f005 fc3e 	bl	6be4 <String::String(__FlashStringHelper const*)>
    1368:	4640      	mov	r0, r8
    136a:	4621      	mov	r1, r4
    136c:	f005 fc4c 	bl	6c08 <String::String(String const&)>
			serial.println(msg);
		}

		void Debug(Stream &serial, String msg, String value)
		{
			if (!m_isDebug) return;
    1370:	4b12      	ldr	r3, [pc, #72]	; (13bc <Meltdown::tryExecuteCommand() [clone .part.53]+0x6ec>)
    1372:	781b      	ldrb	r3, [r3, #0]
    1374:	b173      	cbz	r3, 1394 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6c4>

			serial.print(msg);
    1376:	4629      	mov	r1, r5
    1378:	4811      	ldr	r0, [pc, #68]	; (13c0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6f0>)
    137a:	f005 fb0d 	bl	6998 <Print::print(String const&)>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    137e:	2102      	movs	r1, #2
    1380:	4810      	ldr	r0, [pc, #64]	; (13c4 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6f4>)
    1382:	f005 f8c9 	bl	6518 <usb_serial_write>
	size_t print(uint64_t n, int base)		{ return printNumber64(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
    1386:	4641      	mov	r1, r8
    1388:	480d      	ldr	r0, [pc, #52]	; (13c0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6f0>)
    138a:	f005 fb05 	bl	6998 <Print::print(String const&)>
    138e:	480c      	ldr	r0, [pc, #48]	; (13c0 <Meltdown::tryExecuteCommand() [clone .part.53]+0x6f0>)
    1390:	f005 fb28 	bl	69e4 <Print::println()>
    1394:	4640      	mov	r0, r8
    1396:	f005 fbd1 	bl	6b3c <String::~String()>
    139a:	4628      	mov	r0, r5
    139c:	f005 fbce 	bl	6b3c <String::~String()>
    13a0:	e4cb      	b.n	d3a <Meltdown::tryExecuteCommand() [clone .part.53]+0x6a>
    13a2:	bf00      	nop
    13a4:	1fffb06c 	.word	0x1fffb06c
    13a8:	000091e8 	.word	0x000091e8
    13ac:	00009200 	.word	0x00009200
    13b0:	1fffb3f0 	.word	0x1fffb3f0
    13b4:	00009220 	.word	0x00009220
    13b8:	0000923c 	.word	0x0000923c
    13bc:	1fffb2c4 	.word	0x1fffb2c4
    13c0:	1fff8760 	.word	0x1fff8760
    13c4:	00009134 	.word	0x00009134

000013c8 <Meltdown::setIndexesForWheels()>:

	/// Set the indexes for all wheel sections, treating them as one long contiguous strip.
	void setIndexesForWheels()
	{
		if (gSelectedIndexes != INDEXES_WHEELS)
		{
    13c8:	b538      	push	{r3, r4, r5, lr}
    13ca:	4914      	ldr	r1, [pc, #80]	; (141c <Meltdown::setIndexesForWheels()+0x54>)
    13cc:	4814      	ldr	r0, [pc, #80]	; (1420 <Meltdown::setIndexesForWheels()+0x58>)
    13ce:	f005 fcc3 	bl	6d58 <String::equals(String const&) const>
			gSelectedIndexes = INDEXES_WHEELS;
    13d2:	b100      	cbz	r0, 13d6 <Meltdown::setIndexesForWheels()+0xe>
    13d4:	bd38      	pop	{r3, r4, r5, pc}
    13d6:	4604      	mov	r4, r0

			clearLedIndexes();
    13d8:	4910      	ldr	r1, [pc, #64]	; (141c <Meltdown::setIndexesForWheels()+0x54>)
    13da:	4811      	ldr	r0, [pc, #68]	; (1420 <Meltdown::setIndexesForWheels()+0x58>)
    13dc:	f005 fc32 	bl	6c44 <String::operator=(String const&)>
    13e0:	4b10      	ldr	r3, [pc, #64]	; (1424 <Meltdown::setIndexesForWheels()+0x5c>)
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
		}
	}
    13e2:	4622      	mov	r2, r4
    13e4:	f603 31b8 	addw	r1, r3, #3000	; 0xbb8
    13e8:	f823 2f02 	strh.w	r2, [r3, #2]!

	void clearLedIndexes()
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
    13ec:	428b      	cmp	r3, r1
    13ee:	d1fb      	bne.n	13e8 <Meltdown::setIndexesForWheels()+0x20>
    13f0:	4c0d      	ldr	r4, [pc, #52]	; (1428 <Meltdown::setIndexesForWheels()+0x60>)
    13f2:	2000      	movs	r0, #0
			gSelectedIndexes = INDEXES_WHEELS;

			clearLedIndexes();
			for (int i = 0; i < NUM_PENTS; i++)
			{
				for (int j = 0; j < NUM_STRIPS_PER_PENT; j++)
    13f4:	f240 55dc 	movw	r5, #1500	; 0x5dc
    13f8:	1e82      	subs	r2, r0, #2
    13fa:	f500 7195 	add.w	r1, r0, #298	; 0x12a
    13fe:	4422      	add	r2, r4
    1400:	4421      	add	r1, r4
    1402:	b283      	uxth	r3, r0

					for (int k = 0; k < NUM_WHEEL_LEDS_PER_STRIP; k++)
					{
						ledIndexes[(i * NUM_WHEEL_LEDS_PER_PENT) + (j * NUM_WHEEL_LEDS_PER_STRIP) + k] = (i * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + k;
					}
				}
    1404:	f822 3f02 	strh.w	r3, [r2, #2]!
    1408:	3301      	adds	r3, #1
					// Temporary workaround for hardware fault.
					if (i == 3 && j == 4) continue;

					for (int k = 0; k < NUM_WHEEL_LEDS_PER_STRIP; k++)
					{
						ledIndexes[(i * NUM_WHEEL_LEDS_PER_PENT) + (j * NUM_WHEEL_LEDS_PER_STRIP) + k] = (i * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + k;
    140a:	428a      	cmp	r2, r1
    140c:	b29b      	uxth	r3, r3
    140e:	d1f9      	bne.n	1404 <Meltdown::setIndexesForWheels()+0x3c>
    1410:	f500 7096 	add.w	r0, r0, #300	; 0x12c
			gSelectedIndexes = INDEXES_WHEELS;

			clearLedIndexes();
			for (int i = 0; i < NUM_PENTS; i++)
			{
				for (int j = 0; j < NUM_STRIPS_PER_PENT; j++)
    1414:	42a8      	cmp	r0, r5
    1416:	d1ef      	bne.n	13f8 <Meltdown::setIndexesForWheels()+0x30>
    1418:	bd38      	pop	{r3, r4, r5, pc}
    141a:	bf00      	nop
    141c:	1fff9e24 	.word	0x1fff9e24
    1420:	1fff9218 	.word	0x1fff9218
    1424:	1fff924a 	.word	0x1fff924a
    1428:	1fff924c 	.word	0x1fff924c

0000142c <Meltdown::setIndexesForWheel(int)>:

	/// Set the indexes for the wheel section of a single pent.
	void setIndexesForWheel(int pentNumber)
	{
		if (gSelectedIndexes != INDEXES_WHEEL + pentNumber)
		{
    142c:	b530      	push	{r4, r5, lr}
    142e:	b085      	sub	sp, #20
    1430:	4604      	mov	r4, r0
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
    1432:	491d      	ldr	r1, [pc, #116]	; (14a8 <Meltdown::setIndexesForWheel(int)+0x7c>)
    1434:	4668      	mov	r0, sp
    1436:	f005 fbe7 	bl	6c08 <String::String(String const&)>
			gSelectedIndexes = INDEXES_WHEEL + pentNumber;
    143a:	4621      	mov	r1, r4
    143c:	4668      	mov	r0, sp
    143e:	f005 fc6f 	bl	6d20 <operator+(StringSumHelper const&, int)>
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
    1442:	4601      	mov	r1, r0
    1444:	4819      	ldr	r0, [pc, #100]	; (14ac <Meltdown::setIndexesForWheel(int)+0x80>)
    1446:	f005 fc87 	bl	6d58 <String::equals(String const&) const>
    144a:	4605      	mov	r5, r0
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
    144c:	4668      	mov	r0, sp
    144e:	f005 fb75 	bl	6b3c <String::~String()>
    1452:	b10d      	cbz	r5, 1458 <Meltdown::setIndexesForWheel(int)+0x2c>
				}
			}
		}
	}

	/// Set the indexes for all spoke sections, treating them as one long contigous strip.
    1454:	b005      	add	sp, #20
    1456:	bd30      	pop	{r4, r5, pc}
{
public:
	StringSumHelper(const String &s) : String(s) {}
    1458:	4913      	ldr	r1, [pc, #76]	; (14a8 <Meltdown::setIndexesForWheel(int)+0x7c>)
    145a:	4668      	mov	r0, sp
    145c:	f005 fbd4 	bl	6c08 <String::String(String const&)>
	{
		if (gSelectedIndexes != INDEXES_WHEEL + pentNumber)
		{
			gSelectedIndexes = INDEXES_WHEEL + pentNumber;

			clearLedIndexes();
    1460:	4621      	mov	r1, r4
    1462:	4668      	mov	r0, sp
    1464:	f005 fc5c 	bl	6d20 <operator+(StringSumHelper const&, int)>
    1468:	4601      	mov	r1, r0
    146a:	4810      	ldr	r0, [pc, #64]	; (14ac <Meltdown::setIndexesForWheel(int)+0x80>)
    146c:	f005 fbea 	bl	6c44 <String::operator=(String const&)>
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
    1470:	4668      	mov	r0, sp
    1472:	f005 fb63 	bl	6b3c <String::~String()>
    1476:	4a0e      	ldr	r2, [pc, #56]	; (14b0 <Meltdown::setIndexesForWheel(int)+0x84>)
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
		}
	}
    1478:	4628      	mov	r0, r5
    147a:	f602 31b8 	addw	r1, r2, #3000	; 0xbb8
	{
		if (gSelectedIndexes != INDEXES_WHEEL + pentNumber)
		{
			gSelectedIndexes = INDEXES_WHEEL + pentNumber;

			clearLedIndexes();
    147e:	4613      	mov	r3, r2
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
		}
	}
    1480:	f823 0f02 	strh.w	r0, [r3, #2]!

	void clearLedIndexes()
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
    1484:	428b      	cmp	r3, r1
    1486:	d1fb      	bne.n	1480 <Meltdown::setIndexesForWheel(int)+0x54>
    1488:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    148c:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
    1490:	00a3      	lsls	r3, r4, #2
    1492:	4908      	ldr	r1, [pc, #32]	; (14b4 <Meltdown::setIndexesForWheel(int)+0x88>)
    1494:	b29b      	uxth	r3, r3

				for (int k = 0; k < NUM_WHEEL_LEDS_PER_STRIP; k++)
				{
					ledIndexes[(j * NUM_WHEEL_LEDS_PER_STRIP) + k] = (pentNumber * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + k;
				}
			}
    1496:	f822 3f02 	strh.w	r3, [r2, #2]!
    149a:	3301      	adds	r3, #1
				// Temporary workaround for hardware fault.
				if (pentNumber == 3 && j == 4) continue;

				for (int k = 0; k < NUM_WHEEL_LEDS_PER_STRIP; k++)
				{
					ledIndexes[(j * NUM_WHEEL_LEDS_PER_STRIP) + k] = (pentNumber * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + k;
    149c:	4291      	cmp	r1, r2
    149e:	b29b      	uxth	r3, r3
    14a0:	d1f9      	bne.n	1496 <Meltdown::setIndexesForWheel(int)+0x6a>
				}
			}
		}
	}

	/// Set the indexes for all spoke sections, treating them as one long contigous strip.
    14a2:	b005      	add	sp, #20
    14a4:	bd30      	pop	{r4, r5, pc}
    14a6:	bf00      	nop
    14a8:	1fff9238 	.word	0x1fff9238
    14ac:	1fff9218 	.word	0x1fff9218
    14b0:	1fff924a 	.word	0x1fff924a
    14b4:	1fff9376 	.word	0x1fff9376

000014b8 <Meltdown::setIndexesForSpokes()>:
	void setIndexesForSpokes()
	{
		if (gSelectedIndexes != INDEXES_SPOKES)
		{
    14b8:	b570      	push	{r4, r5, r6, lr}
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
    14ba:	4915      	ldr	r1, [pc, #84]	; (1510 <Meltdown::setIndexesForSpokes()+0x58>)
    14bc:	4815      	ldr	r0, [pc, #84]	; (1514 <Meltdown::setIndexesForSpokes()+0x5c>)
    14be:	f005 fc4b 	bl	6d58 <String::equals(String const&) const>
			gSelectedIndexes = INDEXES_SPOKES;
    14c2:	b100      	cbz	r0, 14c6 <Meltdown::setIndexesForSpokes()+0xe>
    14c4:	bd70      	pop	{r4, r5, r6, pc}
    14c6:	4604      	mov	r4, r0

			clearLedIndexes();
    14c8:	4911      	ldr	r1, [pc, #68]	; (1510 <Meltdown::setIndexesForSpokes()+0x58>)
    14ca:	4812      	ldr	r0, [pc, #72]	; (1514 <Meltdown::setIndexesForSpokes()+0x5c>)
    14cc:	f005 fbba 	bl	6c44 <String::operator=(String const&)>
    14d0:	4b11      	ldr	r3, [pc, #68]	; (1518 <Meltdown::setIndexesForSpokes()+0x60>)
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
		}
	}
    14d2:	4622      	mov	r2, r4
    14d4:	f603 31b8 	addw	r1, r3, #3000	; 0xbb8
    14d8:	f823 2f02 	strh.w	r2, [r3, #2]!

	void clearLedIndexes()
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
    14dc:	4299      	cmp	r1, r3
    14de:	d1fb      	bne.n	14d8 <Meltdown::setIndexesForSpokes()+0x20>
    14e0:	4e0e      	ldr	r6, [pc, #56]	; (151c <Meltdown::setIndexesForSpokes()+0x64>)
    14e2:	2400      	movs	r4, #0
			gSelectedIndexes = INDEXES_SPOKES;

			clearLedIndexes();
			for (int i = 0; i < NUM_PENTS; i++)
			{
				for (int j = 0; j < NUM_STRIPS_PER_PENT; j++)
    14e4:	f240 55dc 	movw	r5, #1500	; 0x5dc
    14e8:	b2a2      	uxth	r2, r4
    14ea:	f102 0396 	add.w	r3, r2, #150	; 0x96
    14ee:	f502 7096 	add.w	r0, r2, #300	; 0x12c
    14f2:	1ea2      	subs	r2, r4, #2
    14f4:	b29b      	uxth	r3, r3
    14f6:	b280      	uxth	r0, r0
    14f8:	4432      	add	r2, r6
    14fa:	1c59      	adds	r1, r3, #1
				{
					for (int k = 0; k < NUM_SPOKE_LEDS_PER_STRIP; k++)
					{
						ledIndexes[(i * NUM_SPOKE_LEDS_PER_PENT) + (j * NUM_SPOKE_LEDS_PER_STRIP) + k] = (i * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + NUM_WHEEL_LEDS_PER_STRIP + k;
					}
				}
    14fc:	f822 3f02 	strh.w	r3, [r2, #2]!
    1500:	b28b      	uxth	r3, r1
			{
				for (int j = 0; j < NUM_STRIPS_PER_PENT; j++)
				{
					for (int k = 0; k < NUM_SPOKE_LEDS_PER_STRIP; k++)
					{
						ledIndexes[(i * NUM_SPOKE_LEDS_PER_PENT) + (j * NUM_SPOKE_LEDS_PER_STRIP) + k] = (i * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + NUM_WHEEL_LEDS_PER_STRIP + k;
    1502:	4283      	cmp	r3, r0
    1504:	d1f9      	bne.n	14fa <Meltdown::setIndexesForSpokes()+0x42>
    1506:	f504 7496 	add.w	r4, r4, #300	; 0x12c
			gSelectedIndexes = INDEXES_SPOKES;

			clearLedIndexes();
			for (int i = 0; i < NUM_PENTS; i++)
			{
				for (int j = 0; j < NUM_STRIPS_PER_PENT; j++)
    150a:	42ac      	cmp	r4, r5
    150c:	d1ec      	bne.n	14e8 <Meltdown::setIndexesForSpokes()+0x30>
    150e:	bd70      	pop	{r4, r5, r6, pc}
    1510:	1fff9228 	.word	0x1fff9228
    1514:	1fff9218 	.word	0x1fff9218
    1518:	1fff924a 	.word	0x1fff924a
    151c:	1fff924c 	.word	0x1fff924c

00001520 <Meltdown::setIndexesForSpokes(int)>:

	/// Set the indexes for the spokes of a single pent.
	void setIndexesForSpokes(int pentNumber)
	{
		if (gSelectedIndexes != INDEXES_SPOKE + pentNumber)
		{
    1520:	b530      	push	{r4, r5, lr}
    1522:	b085      	sub	sp, #20
    1524:	4604      	mov	r4, r0
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
    1526:	491d      	ldr	r1, [pc, #116]	; (159c <Meltdown::setIndexesForSpokes(int)+0x7c>)
    1528:	4668      	mov	r0, sp
    152a:	f005 fb6d 	bl	6c08 <String::String(String const&)>
			gSelectedIndexes = INDEXES_SPOKE + pentNumber;
    152e:	4621      	mov	r1, r4
    1530:	4668      	mov	r0, sp
    1532:	f005 fbf5 	bl	6d20 <operator+(StringSumHelper const&, int)>
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
    1536:	4601      	mov	r1, r0
    1538:	4819      	ldr	r0, [pc, #100]	; (15a0 <Meltdown::setIndexesForSpokes(int)+0x80>)
    153a:	f005 fc0d 	bl	6d58 <String::equals(String const&) const>
    153e:	4605      	mov	r5, r0
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
    1540:	4668      	mov	r0, sp
    1542:	f005 fafb 	bl	6b3c <String::~String()>
    1546:	b10d      	cbz	r5, 154c <Meltdown::setIndexesForSpokes(int)+0x2c>
				}
			}
		}
	}


    1548:	b005      	add	sp, #20
    154a:	bd30      	pop	{r4, r5, pc}
{
public:
	StringSumHelper(const String &s) : String(s) {}
    154c:	4913      	ldr	r1, [pc, #76]	; (159c <Meltdown::setIndexesForSpokes(int)+0x7c>)
    154e:	4668      	mov	r0, sp
    1550:	f005 fb5a 	bl	6c08 <String::String(String const&)>
	{
		if (gSelectedIndexes != INDEXES_SPOKE + pentNumber)
		{
			gSelectedIndexes = INDEXES_SPOKE + pentNumber;

			clearLedIndexes();
    1554:	4621      	mov	r1, r4
    1556:	4668      	mov	r0, sp
    1558:	f005 fbe2 	bl	6d20 <operator+(StringSumHelper const&, int)>
    155c:	4601      	mov	r1, r0
    155e:	4810      	ldr	r0, [pc, #64]	; (15a0 <Meltdown::setIndexesForSpokes(int)+0x80>)
    1560:	f005 fb70 	bl	6c44 <String::operator=(String const&)>
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
    1564:	4668      	mov	r0, sp
    1566:	f005 fae9 	bl	6b3c <String::~String()>
    156a:	4a0e      	ldr	r2, [pc, #56]	; (15a4 <Meltdown::setIndexesForSpokes(int)+0x84>)
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
		}
	}
    156c:	4628      	mov	r0, r5
    156e:	f602 31b8 	addw	r1, r2, #3000	; 0xbb8
	{
		if (gSelectedIndexes != INDEXES_SPOKE + pentNumber)
		{
			gSelectedIndexes = INDEXES_SPOKE + pentNumber;

			clearLedIndexes();
    1572:	4613      	mov	r3, r2
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
		}
	}
    1574:	f823 0f02 	strh.w	r0, [r3, #2]!

	void clearLedIndexes()
	{
		for (int i = 0; i < NUM_LEDS; i++)
		{
			ledIndexes[i] = 0;
    1578:	428b      	cmp	r3, r1
    157a:	d1fb      	bne.n	1574 <Meltdown::setIndexesForSpokes(int)+0x54>
    157c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    1580:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
    1584:	00a3      	lsls	r3, r4, #2
    1586:	3396      	adds	r3, #150	; 0x96
    1588:	4907      	ldr	r1, [pc, #28]	; (15a8 <Meltdown::setIndexesForSpokes(int)+0x88>)
    158a:	b29b      	uxth	r3, r3
			{
				for (int k = 0; k < NUM_SPOKE_LEDS_PER_STRIP; k++)
				{
					ledIndexes[(j * NUM_SPOKE_LEDS_PER_STRIP) + k] = (pentNumber * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + NUM_WHEEL_LEDS_PER_STRIP + k;
				}
			}
    158c:	f822 3f02 	strh.w	r3, [r2, #2]!
    1590:	3301      	adds	r3, #1
			clearLedIndexes();
			for (int j = 0; j < NUM_STRIPS_PER_PENT; j++)
			{
				for (int k = 0; k < NUM_SPOKE_LEDS_PER_STRIP; k++)
				{
					ledIndexes[(j * NUM_SPOKE_LEDS_PER_STRIP) + k] = (pentNumber * NUM_LEDS_PER_PENT) + (j * NUM_LEDS_PER_STRIP) + NUM_WHEEL_LEDS_PER_STRIP + k;
    1592:	4291      	cmp	r1, r2
    1594:	b29b      	uxth	r3, r3
    1596:	d1f9      	bne.n	158c <Meltdown::setIndexesForSpokes(int)+0x6c>
				}
			}
		}
	}


    1598:	b005      	add	sp, #20
    159a:	bd30      	pop	{r4, r5, pc}
    159c:	1fff9e04 	.word	0x1fff9e04
    15a0:	1fff9218 	.word	0x1fff9218
    15a4:	1fff924a 	.word	0x1fff924a
    15a8:	1fff9376 	.word	0x1fff9376

000015ac <Meltdown::executeWheels(int)>:
	}

	void executeWheels(int numLeds)
	{
		if (MeltdownLED.GetBottom())
		{
    15ac:	4a18      	ldr	r2, [pc, #96]	; (1610 <Meltdown::executeWheels(int)+0x64>)
    15ae:	b470      	push	{r4, r5, r6}
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Black);
    15b0:	f892 603e 	ldrb.w	r6, [r2, #62]	; 0x3e
    15b4:	b196      	cbz	r6, 15dc <Meltdown::executeWheels(int)+0x30>

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    15b6:	2800      	cmp	r0, #0
    15b8:	dd0e      	ble.n	15d8 <Meltdown::executeWheels(int)+0x2c>
    15ba:	4a16      	ldr	r2, [pc, #88]	; (1614 <Meltdown::executeWheels(int)+0x68>)
    15bc:	4916      	ldr	r1, [pc, #88]	; (1618 <Meltdown::executeWheels(int)+0x6c>)
    15be:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    15c2:	2400      	movs	r4, #0
			  {
				  leds[indexes[i]] = color;
    15c4:	f832 3b02 	ldrh.w	r3, [r2], #2
    15c8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    15cc:	18cd      	adds	r5, r1, r3

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    15ce:	4290      	cmp	r0, r2
    15d0:	54cc      	strb	r4, [r1, r3]
        g = (colorcode >>  8) & 0xFF;
    15d2:	706c      	strb	r4, [r5, #1]
        b = (colorcode >>  0) & 0xFF;
    15d4:	70ac      	strb	r4, [r5, #2]
    15d6:	d1f5      	bne.n	15c4 <Meltdown::executeWheels(int)+0x18>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeSpokes(int numLeds)
    15d8:	bc70      	pop	{r4, r5, r6}
    15da:	4770      	bx	lr
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Black);
		}
		else if (MeltdownLED.GetFullPurple())
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Purple);
    15dc:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
    15e0:	b192      	cbz	r2, 1608 <Meltdown::executeWheels(int)+0x5c>
    15e2:	2800      	cmp	r0, #0
    15e4:	ddf8      	ble.n	15d8 <Meltdown::executeWheels(int)+0x2c>
    15e6:	4a0b      	ldr	r2, [pc, #44]	; (1614 <Meltdown::executeWheels(int)+0x68>)
    15e8:	490b      	ldr	r1, [pc, #44]	; (1618 <Meltdown::executeWheels(int)+0x6c>)
    15ea:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    15ee:	2580      	movs	r5, #128	; 0x80
			  {
				  leds[indexes[i]] = color;
    15f0:	f832 3b02 	ldrh.w	r3, [r2], #2
    15f4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    15f8:	18cc      	adds	r4, r1, r3

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    15fa:	4290      	cmp	r0, r2
    15fc:	54cd      	strb	r5, [r1, r3]
        g = (colorcode >>  8) & 0xFF;
    15fe:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    1600:	70a5      	strb	r5, [r4, #2]
    1602:	d1f5      	bne.n	15f0 <Meltdown::executeWheels(int)+0x44>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeSpokes(int numLeds)
    1604:	bc70      	pop	{r4, r5, r6}
    1606:	4770      	bx	lr
    1608:	bc70      	pop	{r4, r5, r6}
    160a:	f7fe bf37 	b.w	47c <Meltdown::executeSpokes(int) [clone .part.55]>
    160e:	bf00      	nop
    1610:	1fffb06c 	.word	0x1fffb06c
    1614:	1fff924c 	.word	0x1fff924c
    1618:	1fff9e34 	.word	0x1fff9e34

0000161c <Meltdown::executeSpokes(int)>:
	{
		if (MeltdownLED.GetTop())
		{
    161c:	4a18      	ldr	r2, [pc, #96]	; (1680 <Meltdown::executeSpokes(int)+0x64>)
    161e:	b470      	push	{r4, r5, r6}
			// Call the current pattern function once, updating the 'leds' array.
    1620:	f892 603d 	ldrb.w	r6, [r2, #61]	; 0x3d
    1624:	b196      	cbz	r6, 164c <Meltdown::executeSpokes(int)+0x30>
    1626:	2800      	cmp	r0, #0
    1628:	dd0e      	ble.n	1648 <Meltdown::executeSpokes(int)+0x2c>
    162a:	4a16      	ldr	r2, [pc, #88]	; (1684 <Meltdown::executeSpokes(int)+0x68>)
    162c:	4916      	ldr	r1, [pc, #88]	; (1688 <Meltdown::executeSpokes(int)+0x6c>)
    162e:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    1632:	2400      	movs	r4, #0
			  {
				  leds[indexes[i]] = color;
    1634:	f832 3b02 	ldrh.w	r3, [r2], #2
    1638:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    163c:	18cd      	adds	r5, r1, r3

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    163e:	4290      	cmp	r0, r2
    1640:	54cc      	strb	r4, [r1, r3]
        g = (colorcode >>  8) & 0xFF;
    1642:	706c      	strb	r4, [r5, #1]
        b = (colorcode >>  0) & 0xFF;
    1644:	70ac      	strb	r4, [r5, #2]
    1646:	d1f5      	bne.n	1634 <Meltdown::executeSpokes(int)+0x18>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeLoop()
    1648:	bc70      	pop	{r4, r5, r6}
    164a:	4770      	bx	lr
			// Call the current pattern function once, updating the 'leds' array.
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Black);
		}
		else if (MeltdownLED.GetFullPurple())
		{
			MeltdownLED.SetAllColor(leds, ledIndexes, numLeds, CRGB::Purple);
    164c:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
    1650:	b192      	cbz	r2, 1678 <Meltdown::executeSpokes(int)+0x5c>
    1652:	2800      	cmp	r0, #0
    1654:	ddf8      	ble.n	1648 <Meltdown::executeSpokes(int)+0x2c>
    1656:	4a0b      	ldr	r2, [pc, #44]	; (1684 <Meltdown::executeSpokes(int)+0x68>)
    1658:	490b      	ldr	r1, [pc, #44]	; (1688 <Meltdown::executeSpokes(int)+0x6c>)
    165a:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    165e:	2580      	movs	r5, #128	; 0x80
			  {
				  leds[indexes[i]] = color;
    1660:	f832 3b02 	ldrh.w	r3, [r2], #2
    1664:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1668:	18cc      	adds	r4, r1, r3

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    166a:	4290      	cmp	r0, r2
    166c:	54cd      	strb	r5, [r1, r3]
        g = (colorcode >>  8) & 0xFF;
    166e:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    1670:	70a5      	strb	r5, [r4, #2]
    1672:	d1f5      	bne.n	1660 <Meltdown::executeSpokes(int)+0x44>
			MeltdownLED.ExecutePattern(leds, ledIndexes, numLeds);
			MeltdownLED.ExecuteEffect(leds, ledIndexes, numLeds);
		}
	}

	void executeLoop()
    1674:	bc70      	pop	{r4, r5, r6}
    1676:	4770      	bx	lr
    1678:	bc70      	pop	{r4, r5, r6}
    167a:	f7fe beff 	b.w	47c <Meltdown::executeSpokes(int) [clone .part.55]>
    167e:	bf00      	nop
    1680:	1fffb06c 	.word	0x1fffb06c
    1684:	1fff924c 	.word	0x1fff924c
    1688:	1fff9e34 	.word	0x1fff9e34

0000168c <Meltdown::executeLoop()>:
	{
		tryExecuteCommand();

    168c:	4b36      	ldr	r3, [pc, #216]	; (1768 <Meltdown::executeLoop()+0xdc>)

	void tryExecuteCommand()
	{
		if (MeltdownSerial.GetInputStringComplete())
		{
			MeltdownSerial.SetInputStringComplete(false);
    168e:	7d1b      	ldrb	r3, [r3, #20]
	}

	void executeLoop()
	{
		tryExecuteCommand();

    1690:	b570      	push	{r4, r5, r6, lr}

	void tryExecuteCommand()
	{
		if (MeltdownSerial.GetInputStringComplete())
		{
			MeltdownSerial.SetInputStringComplete(false);
    1692:	2b00      	cmp	r3, #0
    1694:	d145      	bne.n	1722 <Meltdown::executeLoop()+0x96>
    1696:	4e35      	ldr	r6, [pc, #212]	; (176c <Meltdown::executeLoop()+0xe0>)
	{
		tryExecuteCommand();

		if (!MeltdownLED.GetPause() && !MeltdownLED.GetBlack())
		{
			if (MeltdownLED.GetMirror())
    1698:	f896 303b 	ldrb.w	r3, [r6, #59]	; 0x3b
    169c:	2b00      	cmp	r3, #0
    169e:	d13b      	bne.n	1718 <Meltdown::executeLoop()+0x8c>
    16a0:	f896 403c 	ldrb.w	r4, [r6, #60]	; 0x3c
    16a4:	b18c      	cbz	r4, 16ca <Meltdown::executeLoop()+0x3e>
		else if (MeltdownLED.GetBlack())
		{
			// Set to black.
			setIndexesForAll();
			MeltdownLED.SetAllColor(leds, ledIndexes, NUM_LEDS, CRGB::Black);
		}
    16a6:	f7ff faf7 	bl	c98 <Meltdown::setIndexesForAll()>
    16aa:	4a31      	ldr	r2, [pc, #196]	; (1770 <Meltdown::executeLoop()+0xe4>)
    16ac:	4c31      	ldr	r4, [pc, #196]	; (1774 <Meltdown::executeLoop()+0xe8>)
    16ae:	f602 35b8 	addw	r5, r2, #3000	; 0xbb8
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    16b2:	2100      	movs	r1, #0
			  {
				  leds[indexes[i]] = color;
    16b4:	f832 3f02 	ldrh.w	r3, [r2, #2]!
    16b8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    16bc:	18e0      	adds	r0, r4, r3

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    16be:	42aa      	cmp	r2, r5
    16c0:	54e1      	strb	r1, [r4, r3]
        g = (colorcode >>  8) & 0xFF;
    16c2:	7041      	strb	r1, [r0, #1]
        b = (colorcode >>  0) & 0xFF;
    16c4:	7081      	strb	r1, [r0, #2]
    16c6:	d1f5      	bne.n	16b4 <Meltdown::executeLoop()+0x28>
    16c8:	e01b      	b.n	1702 <Meltdown::executeLoop()+0x76>

		if (!MeltdownLED.GetPause() && !MeltdownLED.GetBlack())
		{
			if (MeltdownLED.GetMirror())
			{
				for (int i = 0; i < NUM_PENTS; i++)
    16ca:	f896 3038 	ldrb.w	r3, [r6, #56]	; 0x38
    16ce:	b35b      	cbz	r3, 1728 <Meltdown::executeLoop()+0x9c>
				{
					// WHEELS
					setIndexesForWheel(i);
					executeWheels(NUM_WHEEL_LEDS_PER_PENT);

    16d0:	4620      	mov	r0, r4
    16d2:	f7ff feab 	bl	142c <Meltdown::setIndexesForWheel(int)>
					// SPOKES
    16d6:	2096      	movs	r0, #150	; 0x96
    16d8:	f7ff ff68 	bl	15ac <Meltdown::executeWheels(int)>
					setIndexesForSpokes(i);
					executeSpokes(NUM_SPOKE_LEDS_PER_PENT);
				}
    16dc:	4620      	mov	r0, r4
    16de:	f7ff ff1f 	bl	1520 <Meltdown::setIndexesForSpokes(int)>
		{
			if (MeltdownLED.GetMirror())
			{
				for (int i = 0; i < NUM_PENTS; i++)
				{
					// WHEELS
    16e2:	3401      	adds	r4, #1

					// SPOKES
					setIndexesForSpokes(i);
					executeSpokes(NUM_SPOKE_LEDS_PER_PENT);
				}

    16e4:	2096      	movs	r0, #150	; 0x96
    16e6:	f7ff ff99 	bl	161c <Meltdown::executeSpokes(int)>
		{
			if (MeltdownLED.GetMirror())
			{
				for (int i = 0; i < NUM_PENTS; i++)
				{
					// WHEELS
    16ea:	2c05      	cmp	r4, #5
    16ec:	d1f0      	bne.n	16d0 <Meltdown::executeLoop()+0x44>
    16ee:	6b30      	ldr	r0, [r6, #48]	; 0x30

		  int GetFrameStep(float multiplier = 1)
		  {
			  // A value of less than zero indicates that we don't want to have any kind of modified increase, like in the case
			  // of an especially long string of lights that would otherwise slow some patterns down.
			  if (gFrameStep <= 0) return 1;
    16f0:	2800      	cmp	r0, #0
    16f2:	dd34      	ble.n	175e <Meltdown::executeLoop()+0xd2>

			  return gFrameStep * multiplier;
    16f4:	f005 ffe6 	bl	76c4 <__aeabi_i2f>
    16f8:	f006 f9fe 	bl	7af8 <__aeabi_f2iz>

		  void ResetFrame() { gFrame = 1; }

		  void IncrementFrame(float multiplier = 1)
		  {
			  gFrame += (GetFrameStep(multiplier));
    16fc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    16fe:	4418      	add	r0, r3
    1700:	62f0      	str	r0, [r6, #44]	; 0x2c
    1702:	69b0      	ldr	r0, [r6, #24]
			MeltdownLED.SetAllColor(leds, ledIndexes, NUM_LEDS, CRGB::Black);
		}

		if (MeltdownLED.GetDelay() > 0)
		{
			delay(MeltdownLED.GetDelay());
    1704:	2800      	cmp	r0, #0
    1706:	dd01      	ble.n	170c <Meltdown::executeLoop()+0x80>
		}

    1708:	f003 fba8 	bl	4e5c <delay>
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
    170c:	481a      	ldr	r0, [pc, #104]	; (1778 <Meltdown::executeLoop()+0xec>)
		//displayDebugColors();

		LEDS.show();
	}

	void executeSerialEvent()
    170e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    1712:	7801      	ldrb	r1, [r0, #0]
    1714:	f000 be76 	b.w	2404 <CFastLED::show(unsigned char)>
				MeltdownLED.IncrementFrame(1.5f);
			}
		}
		else if (MeltdownLED.GetBlack())
		{
			// Set to black.
    1718:	f896 303c 	ldrb.w	r3, [r6, #60]	; 0x3c
    171c:	2b00      	cmp	r3, #0
    171e:	d0f0      	beq.n	1702 <Meltdown::executeLoop()+0x76>
    1720:	e7c1      	b.n	16a6 <Meltdown::executeLoop()+0x1a>
    1722:	f7ff fad5 	bl	cd0 <Meltdown::tryExecuteCommand() [clone .part.53]>
    1726:	e7b6      	b.n	1696 <Meltdown::executeLoop()+0xa>
			else
			{
				// WHEELS
				setIndexesForWheels();
				executeWheels(NUM_WHEEL_LEDS);

    1728:	f7ff fe4e 	bl	13c8 <Meltdown::setIndexesForWheels()>
				// SPOKES
    172c:	f240 20ee 	movw	r0, #750	; 0x2ee
    1730:	f7ff ff3c 	bl	15ac <Meltdown::executeWheels(int)>
				setIndexesForSpokes();
				executeSpokes(NUM_SPOKE_LEDS);

    1734:	f7ff fec0 	bl	14b8 <Meltdown::setIndexesForSpokes()>
				MeltdownLED.IncrementFrame(1.5f);
    1738:	f240 20ee 	movw	r0, #750	; 0x2ee
    173c:	f7ff ff6e 	bl	161c <Meltdown::executeSpokes(int)>
    1740:	6b30      	ldr	r0, [r6, #48]	; 0x30

		  int GetFrameStep(float multiplier = 1)
		  {
			  // A value of less than zero indicates that we don't want to have any kind of modified increase, like in the case
			  // of an especially long string of lights that would otherwise slow some patterns down.
			  if (gFrameStep <= 0) return 1;
    1742:	2800      	cmp	r0, #0
    1744:	dd0d      	ble.n	1762 <Meltdown::executeLoop()+0xd6>

			  return gFrameStep * multiplier;
    1746:	f005 ffbd 	bl	76c4 <__aeabi_i2f>
    174a:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
    174e:	f006 f80d 	bl	776c <__aeabi_fmul>
    1752:	f006 f9d1 	bl	7af8 <__aeabi_f2iz>

		  void ResetFrame() { gFrame = 1; }

		  void IncrementFrame(float multiplier = 1)
		  {
			  gFrame += (GetFrameStep(multiplier));
    1756:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    1758:	4403      	add	r3, r0
    175a:	62f3      	str	r3, [r6, #44]	; 0x2c
    175c:	e7d1      	b.n	1702 <Meltdown::executeLoop()+0x76>

		  int GetFrameStep(float multiplier = 1)
		  {
			  // A value of less than zero indicates that we don't want to have any kind of modified increase, like in the case
			  // of an especially long string of lights that would otherwise slow some patterns down.
			  if (gFrameStep <= 0) return 1;
    175e:	2001      	movs	r0, #1
    1760:	e7cc      	b.n	16fc <Meltdown::executeLoop()+0x70>
    1762:	2001      	movs	r0, #1
    1764:	e7f7      	b.n	1756 <Meltdown::executeLoop()+0xca>
    1766:	bf00      	nop
    1768:	1fffb2c8 	.word	0x1fffb2c8
    176c:	1fffb06c 	.word	0x1fffb06c
    1770:	1fff924a 	.word	0x1fff924a
    1774:	1fff9e34 	.word	0x1fff9e34
    1778:	1fffb044 	.word	0x1fffb044

0000177c <Meltdown::executeSerialEvent()>:
	}

	void executeSerialEvent()
	{
		while (Serial1.available() && !MeltdownSerial.GetInputStringComplete())
		{
    177c:	b570      	push	{r4, r5, r6, lr}
    177e:	4d1c      	ldr	r5, [pc, #112]	; (17f0 <Meltdown::executeSerialEvent()+0x74>)
    1780:	b088      	sub	sp, #32
    1782:	462e      	mov	r6, r5
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    1784:	f003 ff46 	bl	5614 <serial_available>
			// get the new byte:
    1788:	b908      	cbnz	r0, 178e <Meltdown::executeSerialEvent()+0x12>
				MeltdownSerial.SetInputStringComplete(true);
			}
		}
	}
}

    178a:	b008      	add	sp, #32
    178c:	bd70      	pop	{r4, r5, r6, pc}

	void executeSerialEvent()
	{
		while (Serial1.available() && !MeltdownSerial.GetInputStringComplete())
		{
			// get the new byte:
    178e:	7d2b      	ldrb	r3, [r5, #20]
    1790:	2b00      	cmp	r3, #0
    1792:	d1fa      	bne.n	178a <Meltdown::executeSerialEvent()+0xe>
	virtual int peek(void)          { return serial_peek(); }
	virtual int read(void)          { return serial_getchar(); }
    1794:	f003 ff52 	bl	563c <serial_getchar>
			char inChar = (char)Serial1.read();
			// add it to the inputString:
			MeltdownSerial.AddCharToInputString(inChar);
    1798:	b2c4      	uxtb	r4, r0
	String & append(float num);
	String & append(double num)			{return append((float)num);}
	String & operator += (const String &rhs)	{return append(rhs);}
	String & operator += (const char *cstr)		{return append(cstr);}
	String & operator += (const __FlashStringHelper *pgmstr) {return append(pgmstr);}
	String & operator += (char c)			{return append(c);}
    179a:	4621      	mov	r1, r4
    179c:	4815      	ldr	r0, [pc, #84]	; (17f4 <Meltdown::executeSerialEvent()+0x78>)
    179e:	f005 fa9b 	bl	6cd8 <String::append(char)>
			// if the incoming character is a newline, set a flag
			// so the main loop can do something about it:
			if (inChar == '\n')
			{
				MeltdownLogger.Debug(Serial, F("Received input string"), MeltdownSerial.GetInputString());
    17a2:	2c0a      	cmp	r4, #10
    17a4:	d1ee      	bne.n	1784 <Meltdown::executeSerialEvent()+0x8>
				MeltdownSerial.SetInputStringComplete(true);
			}
    17a6:	4914      	ldr	r1, [pc, #80]	; (17f8 <Meltdown::executeSerialEvent()+0x7c>)
    17a8:	a804      	add	r0, sp, #16
    17aa:	f005 fa1b 	bl	6be4 <String::String(__FlashStringHelper const*)>
			}

			String GetInputString() { return m_inputString; }
    17ae:	4668      	mov	r0, sp
    17b0:	4910      	ldr	r1, [pc, #64]	; (17f4 <Meltdown::executeSerialEvent()+0x78>)
    17b2:	f005 fa29 	bl	6c08 <String::String(String const&)>
			serial.println(msg);
		}

		void Debug(Stream &serial, String msg, String value)
		{
			if (!m_isDebug) return;
    17b6:	4b11      	ldr	r3, [pc, #68]	; (17fc <Meltdown::executeSerialEvent()+0x80>)
    17b8:	781b      	ldrb	r3, [r3, #0]
    17ba:	b943      	cbnz	r3, 17ce <Meltdown::executeSerialEvent()+0x52>
    17bc:	4668      	mov	r0, sp
    17be:	f005 f9bd 	bl	6b3c <String::~String()>
    17c2:	a804      	add	r0, sp, #16
    17c4:	f005 f9ba 	bl	6b3c <String::~String()>

			void AddCharToInputString(char inChar) { m_inputString += inChar; }

			bool GetInputStringComplete() { return m_inputStringComplete; }

			void SetInputStringComplete(bool value) { m_inputStringComplete = value; }
    17c8:	2301      	movs	r3, #1
    17ca:	7533      	strb	r3, [r6, #20]
    17cc:	e7da      	b.n	1784 <Meltdown::executeSerialEvent()+0x8>

			serial.print(msg);
    17ce:	a904      	add	r1, sp, #16
    17d0:	480b      	ldr	r0, [pc, #44]	; (1800 <Meltdown::executeSerialEvent()+0x84>)
    17d2:	f005 f8e1 	bl	6998 <Print::print(String const&)>
    17d6:	2102      	movs	r1, #2
    17d8:	480a      	ldr	r0, [pc, #40]	; (1804 <Meltdown::executeSerialEvent()+0x88>)
    17da:	f004 fe9d 	bl	6518 <usb_serial_write>
    17de:	4669      	mov	r1, sp
    17e0:	4807      	ldr	r0, [pc, #28]	; (1800 <Meltdown::executeSerialEvent()+0x84>)
    17e2:	f005 f8d9 	bl	6998 <Print::print(String const&)>
    17e6:	4806      	ldr	r0, [pc, #24]	; (1800 <Meltdown::executeSerialEvent()+0x84>)
    17e8:	f005 f8fc 	bl	69e4 <Print::println()>
    17ec:	e7e6      	b.n	17bc <Meltdown::executeSerialEvent()+0x40>
    17ee:	bf00      	nop
    17f0:	1fffb2c8 	.word	0x1fffb2c8
    17f4:	1fffb2cc 	.word	0x1fffb2cc
    17f8:	000092d0 	.word	0x000092d0
    17fc:	1fffb2c4 	.word	0x1fffb2c4
    1800:	1fff8760 	.word	0x1fff8760
    1804:	00009134 	.word	0x00009134

00001808 <loop>:
	Meltdown::executeSetup();
}

void loop()
{
	Meltdown::executeLoop();
    1808:	b530      	push	{r4, r5, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    180a:	4c25      	ldr	r4, [pc, #148]	; (18a0 <loop+0x98>)
    180c:	b085      	sub	sp, #20
    180e:	6823      	ldr	r3, [r4, #0]
    1810:	9301      	str	r3, [sp, #4]
	return ret;
    1812:	9b01      	ldr	r3, [sp, #4]
    1814:	b923      	cbnz	r3, 1820 <loop+0x18>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1816:	6823      	ldr	r3, [r4, #0]
    1818:	9302      	str	r3, [sp, #8]
	return ret;
    181a:	9b02      	ldr	r3, [sp, #8]
    181c:	2b01      	cmp	r3, #1
    181e:	d91e      	bls.n	185e <loop+0x56>
    1820:	4820      	ldr	r0, [pc, #128]	; (18a4 <loop+0x9c>)
    1822:	4d21      	ldr	r5, [pc, #132]	; (18a8 <loop+0xa0>)
    1824:	f000 f998 	bl	1b58 <VisualMicroDebug::DBG_Millis()>
    1828:	682a      	ldr	r2, [r5, #0]
    182a:	4920      	ldr	r1, [pc, #128]	; (18ac <loop+0xa4>)
    182c:	4290      	cmp	r0, r2
    182e:	4603      	mov	r3, r0
    1830:	6008      	str	r0, [r1, #0]
    1832:	d318      	bcc.n	1866 <loop+0x5e>
    1834:	1a9a      	subs	r2, r3, r2
    1836:	2af9      	cmp	r2, #249	; 0xf9
    1838:	d911      	bls.n	185e <loop+0x56>
    183a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    183e:	4819      	ldr	r0, [pc, #100]	; (18a4 <loop+0x9c>)
    1840:	602b      	str	r3, [r5, #0]
    1842:	f000 f993 	bl	1b6c <VisualMicroDebug::OnBreakPointBegin(unsigned long)>
    1846:	2101      	movs	r1, #1
    1848:	4816      	ldr	r0, [pc, #88]	; (18a4 <loop+0x9c>)
    184a:	f000 fa0f 	bl	1c6c <VisualMicroDebug::outPacketStart(bool)>
    184e:	b978      	cbnz	r0, 1870 <loop+0x68>
    1850:	4814      	ldr	r0, [pc, #80]	; (18a4 <loop+0x9c>)
    1852:	2102      	movs	r1, #2
    1854:	f000 f96e 	bl	1b34 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)>
    1858:	4812      	ldr	r0, [pc, #72]	; (18a4 <loop+0x9c>)
    185a:	f000 f9f3 	bl	1c44 <VisualMicroDebug::OnBreakPointEnd()>
}

    185e:	f7ff ff15 	bl	168c <Meltdown::executeLoop()>
void serialEvent1()
    1862:	b005      	add	sp, #20
    1864:	bd30      	pop	{r4, r5, pc}
	Meltdown::executeSetup();
}

void loop()
{
	Meltdown::executeLoop();
    1866:	602b      	str	r3, [r5, #0]
}

    1868:	f7ff ff10 	bl	168c <Meltdown::executeLoop()>
void serialEvent1()
    186c:	b005      	add	sp, #20
    186e:	bd30      	pop	{r4, r5, pc}
	Meltdown::executeSetup();
}

void loop()
{
	Meltdown::executeLoop();
    1870:	2101      	movs	r1, #1
    1872:	480c      	ldr	r0, [pc, #48]	; (18a4 <loop+0x9c>)
    1874:	f000 f994 	bl	1ba0 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)>
    1878:	2101      	movs	r1, #1
    187a:	480d      	ldr	r0, [pc, #52]	; (18b0 <loop+0xa8>)
    187c:	f004 fe4c 	bl	6518 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1880:	6823      	ldr	r3, [r4, #0]
    1882:	9303      	str	r3, [sp, #12]
	return ret;
    1884:	9903      	ldr	r1, [sp, #12]

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1886:	480b      	ldr	r0, [pc, #44]	; (18b4 <loop+0xac>)
    1888:	2300      	movs	r3, #0
    188a:	220a      	movs	r2, #10
    188c:	f005 f8be 	bl	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1890:	4804      	ldr	r0, [pc, #16]	; (18a4 <loop+0x9c>)
    1892:	f000 f9c9 	bl	1c28 <VisualMicroDebug::OnBreakPointPrintEnd()>
    1896:	4803      	ldr	r0, [pc, #12]	; (18a4 <loop+0x9c>)
    1898:	f000 fa0c 	bl	1cb4 <VisualMicroDebug::outPacketEnd()>
    189c:	e7d8      	b.n	1850 <loop+0x48>
    189e:	bf00      	nop
    18a0:	1fffb440 	.word	0x1fffb440
    18a4:	1fffafcc 	.word	0x1fffafcc
    18a8:	1fff9248 	.word	0x1fff9248
    18ac:	1fffafc8 	.word	0x1fffafc8
    18b0:	000092e8 	.word	0x000092e8
    18b4:	1fff8760 	.word	0x1fff8760

000018b8 <serialEvent1()>:

void serialEvent1()
{
	Meltdown::executeSerialEvent();
    18b8:	f7ff bf60 	b.w	177c <Meltdown::executeSerialEvent()>

000018bc <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__>:
    18bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

#pragma region INDEX SETUP

	const String INDEXES_NONE = "NONE";
	const String INDEXES_ALL = "ALL";
	const String INDEXES_WHEELS = "WHEELS";
    18c0:	4e26      	ldr	r6, [pc, #152]	; (195c <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xa0>)
    18c2:	4d27      	ldr	r5, [pc, #156]	; (1960 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xa4>)
    18c4:	4c27      	ldr	r4, [pc, #156]	; (1964 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xa8>)
	const String INDEXES_WHEEL = "WHEEL";
    18c6:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 1988 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xcc>

#pragma region INDEX SETUP

	const String INDEXES_NONE = "NONE";
	const String INDEXES_ALL = "ALL";
	const String INDEXES_WHEELS = "WHEELS";
    18ca:	4927      	ldr	r1, [pc, #156]	; (1968 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xac>)
	const String INDEXES_WHEEL = "WHEEL";
	const String INDEXES_SPOKES = "SPOKES";
    18cc:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 198c <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xd0>
	const String INDEXES_SPOKE = "SPOKE";
    18d0:	4f26      	ldr	r7, [pc, #152]	; (196c <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xb0>)

#pragma region INDEX SETUP

	const String INDEXES_NONE = "NONE";
	const String INDEXES_ALL = "ALL";
	const String INDEXES_WHEELS = "WHEELS";
    18d2:	4630      	mov	r0, r6
    18d4:	f005 f972 	bl	6bbc <String::String(char const*)>
    18d8:	462a      	mov	r2, r5
    18da:	4621      	mov	r1, r4
    18dc:	4630      	mov	r0, r6
    18de:	f005 fc59 	bl	7194 <__aeabi_atexit>
	const String INDEXES_WHEEL = "WHEEL";
    18e2:	4648      	mov	r0, r9
    18e4:	4922      	ldr	r1, [pc, #136]	; (1970 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xb4>)
    18e6:	f005 f969 	bl	6bbc <String::String(char const*)>
    18ea:	462a      	mov	r2, r5
    18ec:	4621      	mov	r1, r4
    18ee:	4648      	mov	r0, r9
    18f0:	f005 fc50 	bl	7194 <__aeabi_atexit>
	const String INDEXES_SPOKES = "SPOKES";
    18f4:	4640      	mov	r0, r8
    18f6:	491f      	ldr	r1, [pc, #124]	; (1974 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xb8>)
	const String INDEXES_SPOKE = "SPOKE";

    18f8:	f8df 9094 	ldr.w	r9, [pc, #148]	; 1990 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xd4>

	const String INDEXES_NONE = "NONE";
	const String INDEXES_ALL = "ALL";
	const String INDEXES_WHEELS = "WHEELS";
	const String INDEXES_WHEEL = "WHEEL";
	const String INDEXES_SPOKES = "SPOKES";
    18fc:	f005 f95e 	bl	6bbc <String::String(char const*)>
    1900:	462a      	mov	r2, r5
    1902:	4621      	mov	r1, r4
    1904:	4640      	mov	r0, r8
    1906:	f005 fc45 	bl	7194 <__aeabi_atexit>
	const String INDEXES_SPOKE = "SPOKE";
    190a:	4638      	mov	r0, r7
    190c:	491a      	ldr	r1, [pc, #104]	; (1978 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xbc>)

	String gSelectedIndexes = INDEXES_NONE;
    190e:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1994 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xd8>
	const String INDEXES_NONE = "NONE";
	const String INDEXES_ALL = "ALL";
	const String INDEXES_WHEELS = "WHEELS";
	const String INDEXES_WHEEL = "WHEEL";
	const String INDEXES_SPOKES = "SPOKES";
	const String INDEXES_SPOKE = "SPOKE";
    1912:	f005 f953 	bl	6bbc <String::String(char const*)>
    1916:	462a      	mov	r2, r5
    1918:	4621      	mov	r1, r4
    191a:	4638      	mov	r0, r7
    191c:	f005 fc3a 	bl	7194 <__aeabi_atexit>

    1920:	4648      	mov	r0, r9
    1922:	4916      	ldr	r1, [pc, #88]	; (197c <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xc0>)
	String gSelectedIndexes = INDEXES_NONE;

	void clearLedIndexes()
    1924:	4f16      	ldr	r7, [pc, #88]	; (1980 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xc4>)
	const String INDEXES_ALL = "ALL";
	const String INDEXES_WHEELS = "WHEELS";
	const String INDEXES_WHEEL = "WHEEL";
	const String INDEXES_SPOKES = "SPOKES";
	const String INDEXES_SPOKE = "SPOKE";

    1926:	f005 f949 	bl	6bbc <String::String(char const*)>
    192a:	462a      	mov	r2, r5
    192c:	4621      	mov	r1, r4
    192e:	4648      	mov	r0, r9
    1930:	f005 fc30 	bl	7194 <__aeabi_atexit>
	String gSelectedIndexes = INDEXES_NONE;
    1934:	4640      	mov	r0, r8
    1936:	4913      	ldr	r1, [pc, #76]	; (1984 <_GLOBAL__sub_I___VisualMicro_DEBUG_1_HITCOUNTER__+0xc8>)
    1938:	f005 f940 	bl	6bbc <String::String(char const*)>
    193c:	462a      	mov	r2, r5
    193e:	4621      	mov	r1, r4
    1940:	4640      	mov	r0, r8
    1942:	f005 fc27 	bl	7194 <__aeabi_atexit>

	void clearLedIndexes()
    1946:	4631      	mov	r1, r6
    1948:	4638      	mov	r0, r7
    194a:	f005 f95d 	bl	6c08 <String::String(String const&)>
    194e:	462a      	mov	r2, r5
    1950:	4621      	mov	r1, r4
    1952:	4638      	mov	r0, r7
void serialEvent1()
{
	Meltdown::executeSerialEvent();
    1954:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const String INDEXES_SPOKES = "SPOKES";
	const String INDEXES_SPOKE = "SPOKE";

	String gSelectedIndexes = INDEXES_NONE;

	void clearLedIndexes()
    1958:	f005 bc1c 	b.w	7194 <__aeabi_atexit>
    195c:	1fff9e14 	.word	0x1fff9e14
    1960:	1fff8720 	.word	0x1fff8720
    1964:	00006b3d 	.word	0x00006b3d
    1968:	000092ec 	.word	0x000092ec
    196c:	1fff9238 	.word	0x1fff9238
    1970:	000092f4 	.word	0x000092f4
    1974:	000092f8 	.word	0x000092f8
    1978:	00009300 	.word	0x00009300
    197c:	00009308 	.word	0x00009308
    1980:	1fff9218 	.word	0x1fff9218
    1984:	00009310 	.word	0x00009310
    1988:	1fff9208 	.word	0x1fff9208
    198c:	1fff9e24 	.word	0x1fff9e24
    1990:	1fff9228 	.word	0x1fff9228
    1994:	1fff9e04 	.word	0x1fff9e04

00001998 <Meltdown::executeSetup()>:
#pragma endregion COMMANDS

	void executeSetup()
	{
		// initialize serial communication at 9600 bits per second:
		Serial.begin(9600);
    1998:	b538      	push	{r3, r4, r5, lr}
		Serial1.begin(9600);

		Serial.println(F("Serial port opened."));
    199a:	f44f 5116 	mov.w	r1, #9600	; 0x2580
    199e:	4822      	ldr	r0, [pc, #136]	; (1a28 <Meltdown::executeSetup()+0x90>)
    19a0:	f004 ff78 	bl	6894 <HardwareSerial::begin(unsigned long)>
    19a4:	2113      	movs	r1, #19
    19a6:	4821      	ldr	r0, [pc, #132]	; (1a2c <Meltdown::executeSetup()+0x94>)
    19a8:	f004 fdb6 	bl	6518 <usb_serial_write>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    19ac:	4820      	ldr	r0, [pc, #128]	; (1a30 <Meltdown::executeSetup()+0x98>)
    19ae:	f005 f819 	bl	69e4 <Print::println()>

		bool m_isDebug = false;

		void InitSerial(bool isDebug)
		{
			m_isDebug = isDebug;
    19b2:	4b20      	ldr	r3, [pc, #128]	; (1a34 <Meltdown::executeSetup()+0x9c>)
    19b4:	2501      	movs	r5, #1
		MeltdownLogger.InitSerial(DEBUG);

		delay(3000);

		LEDS.addLeds<OCTOWS2811>(leds, NUM_LEDS_PER_PENT);
    19b6:	f640 30b8 	movw	r0, #3000	; 0xbb8
    19ba:	701d      	strb	r5, [r3, #0]
    19bc:	f003 fa4e 	bl	4e5c <delay>
#ifdef USE_OCTOWS2811
	template<OWS2811 CHIPSET, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0)
	{
		switch(CHIPSET) {
			case OCTOWS2811: { static COctoWS2811Controller<RGB_ORDER,WS2811_800kHz> controller; return addLeds(&controller, data, nLedsOrOffset, nLedsIfOffset); }
    19c0:	481d      	ldr	r0, [pc, #116]	; (1a38 <Meltdown::executeSetup()+0xa0>)
    19c2:	6803      	ldr	r3, [r0, #0]
    19c4:	ea13 0405 	ands.w	r4, r3, r5
    19c8:	d00b      	beq.n	19e2 <Meltdown::executeSetup()+0x4a>
    19ca:	2300      	movs	r3, #0
    19cc:	f44f 7296 	mov.w	r2, #300	; 0x12c
    19d0:	491a      	ldr	r1, [pc, #104]	; (1a3c <Meltdown::executeSetup()+0xa4>)
    19d2:	481b      	ldr	r0, [pc, #108]	; (1a40 <Meltdown::executeSetup()+0xa8>)
    19d4:	f000 fcc4 	bl	2360 <CFastLED::addLeds(CLEDController*, CRGB*, int, int)>
    19d8:	4a1a      	ldr	r2, [pc, #104]	; (1a44 <Meltdown::executeSetup()+0xac>)
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
    19da:	4b1b      	ldr	r3, [pc, #108]	; (1a48 <Meltdown::executeSetup()+0xb0>)
    19dc:	6952      	ldr	r2, [r2, #20]
    19de:	701a      	strb	r2, [r3, #0]
    19e0:	bd38      	pop	{r3, r4, r5, pc}
#ifdef USE_OCTOWS2811
	template<OWS2811 CHIPSET, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0)
	{
		switch(CHIPSET) {
			case OCTOWS2811: { static COctoWS2811Controller<RGB_ORDER,WS2811_800kHz> controller; return addLeds(&controller, data, nLedsOrOffset, nLedsIfOffset); }
    19e2:	f002 ffe5 	bl	49b0 <__cxa_guard_acquire>
    19e6:	2800      	cmp	r0, #0
    19e8:	d0ef      	beq.n	19ca <Meltdown::executeSetup()+0x32>

public:
	/// create an led controller object, add it to the chain of controllers
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
    19ea:	4918      	ldr	r1, [pc, #96]	; (1a4c <Meltdown::executeSetup()+0xb4>)
	///@param scale the rgb scaling to apply to each led before writing it out
    virtual void show(const struct CRGB *data, int nLeds, CRGB scale) = 0;

public:
	/// create an led controller object, add it to the chain of controllers
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
    19ec:	4b14      	ldr	r3, [pc, #80]	; (1a40 <Meltdown::executeSetup()+0xa8>)
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
    19ee:	6808      	ldr	r0, [r1, #0]
	///@param scale the rgb scaling to apply to each led before writing it out
    virtual void show(const struct CRGB *data, int nLeds, CRGB scale) = 0;

public:
	/// create an led controller object, add it to the chain of controllers
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
    19f0:	605c      	str	r4, [r3, #4]
    {
    }

    /// allow construction from a LEDColorCorrection enum
    inline CRGB( LEDColorCorrection colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    19f2:	22ff      	movs	r2, #255	; 0xff
    19f4:	749d      	strb	r5, [r3, #18]
    19f6:	615c      	str	r4, [r3, #20]
        m_pNext = NULL;
    19f8:	609c      	str	r4, [r3, #8]
    19fa:	731a      	strb	r2, [r3, #12]
    19fc:	735a      	strb	r2, [r3, #13]
    19fe:	739a      	strb	r2, [r3, #14]

    }

    /// allow construction from a ColorTemperature enum
    inline CRGB( ColorTemperature colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    1a00:	73da      	strb	r2, [r3, #15]
    1a02:	741a      	strb	r2, [r3, #16]
    1a04:	745a      	strb	r2, [r3, #17]
        if(m_pHead==NULL) { m_pHead = this; }
    1a06:	b160      	cbz	r0, 1a22 <Meltdown::executeSetup()+0x8a>
        if(m_pTail != NULL) { m_pTail->m_pNext = this; }
    1a08:	4a11      	ldr	r2, [pc, #68]	; (1a50 <Meltdown::executeSetup()+0xb8>)
    1a0a:	6811      	ldr	r1, [r2, #0]
    1a0c:	b101      	cbz	r1, 1a10 <Meltdown::executeSetup()+0x78>
    1a0e:	608b      	str	r3, [r1, #8]
    }
  }
public:
  COctoWS2811Controller() { pocto = NULL; }
    1a10:	4910      	ldr	r1, [pc, #64]	; (1a54 <Meltdown::executeSetup()+0xbc>)
        m_pTail = this;
    1a12:	6013      	str	r3, [r2, #0]
    1a14:	4808      	ldr	r0, [pc, #32]	; (1a38 <Meltdown::executeSetup()+0xa0>)
    1a16:	6019      	str	r1, [r3, #0]
    1a18:	2200      	movs	r2, #0
    1a1a:	619a      	str	r2, [r3, #24]
    1a1c:	f002 ffce 	bl	49bc <__cxa_guard_release>
    1a20:	e7d3      	b.n	19ca <Meltdown::executeSetup()+0x32>

public:
	/// create an led controller object, add it to the chain of controllers
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
    1a22:	600b      	str	r3, [r1, #0]
    1a24:	e7f0      	b.n	1a08 <Meltdown::executeSetup()+0x70>
    1a26:	bf00      	nop
    1a28:	1fff874c 	.word	0x1fff874c
    1a2c:	00009318 	.word	0x00009318
    1a30:	1fff8760 	.word	0x1fff8760
    1a34:	1fffb2c4 	.word	0x1fffb2c4
    1a38:	1fff91e0 	.word	0x1fff91e0
    1a3c:	1fff9e34 	.word	0x1fff9e34
    1a40:	1fff91e4 	.word	0x1fff91e4
    1a44:	1fffb06c 	.word	0x1fffb06c
    1a48:	1fffb044 	.word	0x1fffb044
    1a4c:	1fffb054 	.word	0x1fffb054
    1a50:	1fffb064 	.word	0x1fffb064
    1a54:	00009118 	.word	0x00009118

00001a58 <setup>:
	}
}

void setup()
{
	Meltdown::executeSetup();
    1a58:	b508      	push	{r3, lr}
    1a5a:	f640 31b8 	movw	r1, #3000	; 0xbb8
    1a5e:	4817      	ldr	r0, [pc, #92]	; (1abc <setup+0x64>)
    1a60:	f000 f92e 	bl	1cc0 <VisualMicroDebug::init(unsigned long)>
    1a64:	f44f 5116 	mov.w	r1, #9600	; 0x2580
    1a68:	4814      	ldr	r0, [pc, #80]	; (1abc <setup+0x64>)
    1a6a:	f000 f925 	bl	1cb8 <VisualMicroDebug::begin(unsigned long)>
    1a6e:	2101      	movs	r1, #1
    1a70:	4812      	ldr	r0, [pc, #72]	; (1abc <setup+0x64>)
    1a72:	f000 f8fb 	bl	1c6c <VisualMicroDebug::outPacketStart(bool)>
    1a76:	b9a0      	cbnz	r0, 1aa2 <setup+0x4a>
    1a78:	2100      	movs	r1, #0
    1a7a:	4810      	ldr	r0, [pc, #64]	; (1abc <setup+0x64>)
    1a7c:	2201      	movs	r2, #1
    1a7e:	f000 f9cb 	bl	1e18 <VisualMicroDebug::start(bool, bool)>
    1a82:	2101      	movs	r1, #1
    1a84:	480d      	ldr	r0, [pc, #52]	; (1abc <setup+0x64>)
    1a86:	f000 f8f1 	bl	1c6c <VisualMicroDebug::outPacketStart(bool)>
    1a8a:	b130      	cbz	r0, 1a9a <setup+0x42>
    1a8c:	2106      	movs	r1, #6
    1a8e:	480c      	ldr	r0, [pc, #48]	; (1ac0 <setup+0x68>)
    1a90:	f004 fd42 	bl	6518 <usb_serial_write>
    1a94:	4809      	ldr	r0, [pc, #36]	; (1abc <setup+0x64>)
    1a96:	f000 f90d 	bl	1cb4 <VisualMicroDebug::outPacketEnd()>
}

void loop()
    1a9a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void setup()
{
	Meltdown::executeSetup();
}

    1a9e:	f7ff bf7b 	b.w	1998 <Meltdown::executeSetup()>
    1aa2:	2110      	movs	r1, #16
    1aa4:	4807      	ldr	r0, [pc, #28]	; (1ac4 <setup+0x6c>)
    1aa6:	f004 fd37 	bl	6518 <usb_serial_write>
	}
}

void setup()
{
	Meltdown::executeSetup();
    1aaa:	210a      	movs	r1, #10
    1aac:	4803      	ldr	r0, [pc, #12]	; (1abc <setup+0x64>)
    1aae:	f000 f841 	bl	1b34 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)>
    1ab2:	4802      	ldr	r0, [pc, #8]	; (1abc <setup+0x64>)
    1ab4:	f000 f8fe 	bl	1cb4 <VisualMicroDebug::outPacketEnd()>
    1ab8:	e7de      	b.n	1a78 <setup+0x20>
    1aba:	bf00      	nop
    1abc:	1fffafcc 	.word	0x1fffafcc
    1ac0:	00009340 	.word	0x00009340
    1ac4:	0000932c 	.word	0x0000932c

00001ac8 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]>:
	BreakStartMillis = DBG_Millis();
	digitalWriteMessageCheck();
}

// Work out if we have a DigitalPin Inbound
void VisualMicroDebug::digitalWriteMessageCheck()
    1ac8:	b530      	push	{r4, r5, lr}
    1aca:	b083      	sub	sp, #12
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    1acc:	f004 fcbe 	bl	644c <usb_serial_getchar>
    1ad0:	f004 fcbc 	bl	644c <usb_serial_getchar>
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
    1ad4:	b2c0      	uxtb	r0, r0
	int pinCharRead = 0;
	if (nxtChar == 'd') {
		// Read Our message back -> dxxxx:1 where xxxxx is the pin number (must be a number!)
		read(); // Remove d
		char nxt = read();
		while (nxt != ':') {
    1ad6:	283a      	cmp	r0, #58	; 0x3a
    1ad8:	ad01      	add	r5, sp, #4
    1ada:	d007      	beq.n	1aec <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x24>
    1adc:	462c      	mov	r4, r5
			pinStr[pinCharRead] = nxt;
    1ade:	f804 0b01 	strb.w	r0, [r4], #1
    1ae2:	f004 fcb3 	bl	644c <usb_serial_getchar>
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
    1ae6:	b2c0      	uxtb	r0, r0
	int pinCharRead = 0;
	if (nxtChar == 'd') {
		// Read Our message back -> dxxxx:1 where xxxxx is the pin number (must be a number!)
		read(); // Remove d
		char nxt = read();
		while (nxt != ':') {
    1ae8:	283a      	cmp	r0, #58	; 0x3a
    1aea:	d1f8      	bne.n	1ade <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x16>
			pinStr[pinCharRead] = nxt;
			pinCharRead++;
			nxt = read();
		}
		int pin = atoi(pinStr);	// at : so skip and read state char
    1aec:	4628      	mov	r0, r5
    1aee:	f006 f849 	bl	7b84 <atoi>
    1af2:	4604      	mov	r4, r0
    1af4:	f004 fcaa 	bl	644c <usb_serial_getchar>
		int state = read() - 48;
    1af8:	b2c0      	uxtb	r0, r0
    1afa:	f1a0 0130 	sub.w	r1, r0, #48	; 0x30
		if (state == 1 || state == 0) { // State check, not sure tri-state truly supported with DigiWrite
    1afe:	2901      	cmp	r1, #1
    1b00:	d802      	bhi.n	1b08 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x40>
    1b02:	e011      	b.n	1b28 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x60>
			digitalWrite(pin, state);
		}
		while (nxt != '\n' && nxt != '\r') {
    1b04:	280d      	cmp	r0, #13
    1b06:	d004      	beq.n	1b12 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x4a>
    1b08:	f004 fca0 	bl	644c <usb_serial_getchar>
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
    1b0c:	b2c0      	uxtb	r0, r0
		int pin = atoi(pinStr);	// at : so skip and read state char
		int state = read() - 48;
		if (state == 1 || state == 0) { // State check, not sure tri-state truly supported with DigiWrite
			digitalWrite(pin, state);
		}
		while (nxt != '\n' && nxt != '\r') {
    1b0e:	280a      	cmp	r0, #10
    1b10:	d1f8      	bne.n	1b04 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x3c>
        virtual int peek() { return usb_serial_peekchar(); }
    1b12:	f004 fcbf 	bl	6494 <usb_serial_peekchar>
			nxt = read();
		}
		if (peek() == '\n') {
    1b16:	b2c0      	uxtb	r0, r0
    1b18:	280a      	cmp	r0, #10
    1b1a:	d001      	beq.n	1b20 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x58>
			read();
		}
	}
}
    1b1c:	b003      	add	sp, #12
    1b1e:	bd30      	pop	{r4, r5, pc}
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    1b20:	f004 fc94 	bl	644c <usb_serial_getchar>
    1b24:	b003      	add	sp, #12
    1b26:	bd30      	pop	{r4, r5, pc}
			nxt = read();
		}
		int pin = atoi(pinStr);	// at : so skip and read state char
		int state = read() - 48;
		if (state == 1 || state == 0) { // State check, not sure tri-state truly supported with DigiWrite
			digitalWrite(pin, state);
    1b28:	b2c9      	uxtb	r1, r1
    1b2a:	b2e0      	uxtb	r0, r4
    1b2c:	f003 f968 	bl	4e00 <digitalWrite>
    1b30:	e7ea      	b.n	1b08 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]+0x40>
    1b32:	bf00      	nop

00001b34 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1b34:	4807      	ldr	r0, [pc, #28]	; (1b54 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)+0x20>)
//#include "VM_mem_check.h"
#endif


void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms)
{
    1b36:	b082      	sub	sp, #8
    1b38:	6803      	ldr	r3, [r0, #0]
    1b3a:	9301      	str	r3, [sp, #4]
	return ret;
    1b3c:	9a01      	ldr	r2, [sp, #4]
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
{
	unsigned long ms_start = DBG_Millis();
	unsigned long ms_end = ms_start + ms;
    1b3e:	4411      	add	r1, r2
    1b40:	e001      	b.n	1b46 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)+0x12>

		//delay(1);

		ms_curr = DBG_Millis();

		if (ms_curr<ms_start || ms_curr>ms_end) {
    1b42:	4299      	cmp	r1, r3
    1b44:	d304      	bcc.n	1b50 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)+0x1c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1b46:	6803      	ldr	r3, [r0, #0]
    1b48:	9300      	str	r3, [sp, #0]
	return ret;
    1b4a:	9b00      	ldr	r3, [sp, #0]
    1b4c:	429a      	cmp	r2, r3
    1b4e:	d9f8      	bls.n	1b42 <VisualMicroDebug::DBG_YieldAndWait(unsigned long)+0xe>


void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms)
{
	DBG_YieldAndWait(ms, true);
}
    1b50:	b002      	add	sp, #8
    1b52:	4770      	bx	lr
    1b54:	1fffb440 	.word	0x1fffb440

00001b58 <VisualMicroDebug::DBG_Millis()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1b58:	4b03      	ldr	r3, [pc, #12]	; (1b68 <VisualMicroDebug::DBG_Millis()+0x10>)
{
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
    1b5a:	b082      	sub	sp, #8
    1b5c:	681b      	ldr	r3, [r3, #0]
    1b5e:	9301      	str	r3, [sp, #4]
	return ret;
    1b60:	9801      	ldr	r0, [sp, #4]
	return millis();
}
    1b62:	b002      	add	sp, #8
    1b64:	4770      	bx	lr
    1b66:	bf00      	nop
    1b68:	1fffb440 	.word	0x1fffb440

00001b6c <VisualMicroDebug::OnBreakPointBegin(unsigned long)>:
{

}

void VisualMicroDebug::OnBreakPointBegin(unsigned long iInBreakMsgRepeatMS)
{
    1b6c:	b510      	push	{r4, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1b6e:	4b0b      	ldr	r3, [pc, #44]	; (1b9c <VisualMicroDebug::OnBreakPointBegin(unsigned long)+0x30>)
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_UDP)
	available();
#endif
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
	InBreakMsgSent = 0L;
	BreakPrevMillis = BreakStartMillis;
    1b70:	6882      	ldr	r2, [r0, #8]
    1b72:	681b      	ldr	r3, [r3, #0]
void VisualMicroDebug::OnBreakPointBegin(unsigned long iInBreakMsgRepeatMS)
{
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_UDP)
	available();
#endif
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
    1b74:	6101      	str	r1, [r0, #16]
{

}

void VisualMicroDebug::OnBreakPointBegin(unsigned long iInBreakMsgRepeatMS)
{
    1b76:	b082      	sub	sp, #8
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_UDP)
	available();
#endif
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
	InBreakMsgSent = 0L;
    1b78:	2400      	movs	r4, #0
    1b7a:	9301      	str	r3, [sp, #4]
	return ret;
    1b7c:	9b01      	ldr	r3, [sp, #4]
    1b7e:	6144      	str	r4, [r0, #20]
	BreakPrevMillis = BreakStartMillis;
    1b80:	60c2      	str	r2, [r0, #12]
	BreakStartMillis = DBG_Millis();
    1b82:	6083      	str	r3, [r0, #8]
        virtual int peek() { return usb_serial_peekchar(); }
    1b84:	f004 fc86 	bl	6494 <usb_serial_peekchar>
void VisualMicroDebug::digitalWriteMessageCheck()
{
	char nxtChar = peek();
	char pinStr[4];
	int pinCharRead = 0;
	if (nxtChar == 'd') {
    1b88:	b2c0      	uxtb	r0, r0
    1b8a:	2864      	cmp	r0, #100	; 0x64
    1b8c:	d001      	beq.n	1b92 <VisualMicroDebug::OnBreakPointBegin(unsigned long)+0x26>
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
	InBreakMsgSent = 0L;
	BreakPrevMillis = BreakStartMillis;
	BreakStartMillis = DBG_Millis();
	digitalWriteMessageCheck();
}
    1b8e:	b002      	add	sp, #8
    1b90:	bd10      	pop	{r4, pc}
    1b92:	f7ff ff99 	bl	1ac8 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]>
    1b96:	b002      	add	sp, #8
    1b98:	bd10      	pop	{r4, pc}
    1b9a:	bf00      	nop
    1b9c:	1fffb440 	.word	0x1fffb440

00001ba0 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)>:
		}
	}
}

void VisualMicroDebug::OnBreakPointPrintBegin(uint8_t breakpoint_id)
{
    1ba0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1ba4:	4b1b      	ldr	r3, [pc, #108]	; (1c14 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)+0x74>)
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ba6:	4c1c      	ldr	r4, [pc, #112]	; (1c18 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)+0x78>)
    1ba8:	681b      	ldr	r3, [r3, #0]
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1baa:	4e1c      	ldr	r6, [pc, #112]	; (1c1c <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)+0x7c>)
    1bac:	b082      	sub	sp, #8
    1bae:	4605      	mov	r5, r0
    1bb0:	9301      	str	r3, [sp, #4]
    1bb2:	4688      	mov	r8, r1
    1bb4:	481a      	ldr	r0, [pc, #104]	; (1c20 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)+0x80>)
	return ret;
    1bb6:	9f01      	ldr	r7, [sp, #4]
    1bb8:	2106      	movs	r1, #6
    1bba:	f004 fcad 	bl	6518 <usb_serial_write>
    1bbe:	4641      	mov	r1, r8
    1bc0:	2300      	movs	r3, #0
    1bc2:	220a      	movs	r2, #10
    1bc4:	4620      	mov	r0, r4
    1bc6:	f004 ff21 	bl	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bca:	2103      	movs	r1, #3
    1bcc:	4815      	ldr	r0, [pc, #84]	; (1c24 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char)+0x84>)
    1bce:	f004 fca3 	bl	6518 <usb_serial_write>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1bd2:	4639      	mov	r1, r7
    1bd4:	2300      	movs	r3, #0
    1bd6:	220a      	movs	r2, #10
    1bd8:	4620      	mov	r0, r4
    1bda:	f004 ff17 	bl	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bde:	4630      	mov	r0, r6
    1be0:	2101      	movs	r1, #1
    1be2:	f004 fc99 	bl	6518 <usb_serial_write>
    1be6:	68a9      	ldr	r1, [r5, #8]
    1be8:	2300      	movs	r3, #0
    1bea:	1a79      	subs	r1, r7, r1
    1bec:	220a      	movs	r2, #10
    1bee:	4620      	mov	r0, r4
    1bf0:	f004 ff0c 	bl	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bf4:	4630      	mov	r0, r6
    1bf6:	2101      	movs	r1, #1
    1bf8:	f004 fc8e 	bl	6518 <usb_serial_write>
    1bfc:	68eb      	ldr	r3, [r5, #12]
    1bfe:	68a9      	ldr	r1, [r5, #8]
    1c00:	4620      	mov	r0, r4
    1c02:	1ac9      	subs	r1, r1, r3
    1c04:	220a      	movs	r2, #10
    1c06:	2300      	movs	r3, #0
    1c08:	f004 ff00 	bl	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	VM_DEBUGGER_SOFT_TRANSPORT.print((m - BreakStartMillis));
	VM_DEBUGGER_SOFT_TRANSPORT.print(":");
	//millis since last bp was hit
	VM_DEBUGGER_SOFT_TRANSPORT.print((BreakStartMillis - BreakPrevMillis));
#endif
}
    1c0c:	b002      	add	sp, #8
    1c0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1c12:	bf00      	nop
    1c14:	1fffb440 	.word	0x1fffb440
    1c18:	1fff8760 	.word	0x1fff8760
    1c1c:	00009354 	.word	0x00009354
    1c20:	00009348 	.word	0x00009348
    1c24:	00009350 	.word	0x00009350

00001c28 <VisualMicroDebug::OnBreakPointPrintEnd()>:
void VisualMicroDebug::OnBreakPointPrintEnd()
{
    1c28:	b508      	push	{r3, lr}
    1c2a:	2106      	movs	r1, #6
    1c2c:	4803      	ldr	r0, [pc, #12]	; (1c3c <VisualMicroDebug::OnBreakPointPrintEnd()+0x14>)
    1c2e:	f004 fc73 	bl	6518 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1c32:	4803      	ldr	r0, [pc, #12]	; (1c40 <VisualMicroDebug::OnBreakPointPrintEnd()+0x18>)
#else
	VM_DEBUGGER_SOFT_TRANSPORT.println("_VMDPE");
#endif

#endif
}
    1c34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    1c38:	f004 bed4 	b.w	69e4 <Print::println()>
    1c3c:	00009358 	.word	0x00009358
    1c40:	1fff8760 	.word	0x1fff8760

00001c44 <VisualMicroDebug::OnBreakPointEnd()>:

void VisualMicroDebug::OnBreakPointEnd()
{
    1c44:	b510      	push	{r4, lr}
    1c46:	b082      	sub	sp, #8
    1c48:	4604      	mov	r4, r0
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    1c4a:	f004 fc23 	bl	6494 <usb_serial_peekchar>
void VisualMicroDebug::digitalWriteMessageCheck()
{
	char nxtChar = peek();
	char pinStr[4];
	int pinCharRead = 0;
	if (nxtChar == 'd') {
    1c4e:	b2c0      	uxtb	r0, r0
    1c50:	2864      	cmp	r0, #100	; 0x64
    1c52:	d006      	beq.n	1c62 <VisualMicroDebug::OnBreakPointEnd()+0x1e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c54:	4b04      	ldr	r3, [pc, #16]	; (1c68 <VisualMicroDebug::OnBreakPointEnd()+0x24>)
    1c56:	681b      	ldr	r3, [r3, #0]
    1c58:	9301      	str	r3, [sp, #4]
	return ret;
    1c5a:	9b01      	ldr	r3, [sp, #4]

void VisualMicroDebug::OnBreakPointEnd()
{
	digitalWriteMessageCheck(); // Check for Digital Pin
	//update millis to now. ensure time taken for debug doesn't affect comparison of the time to the next point
	BreakStartMillis = DBG_Millis();
    1c5c:	60a3      	str	r3, [r4, #8]

}
    1c5e:	b002      	add	sp, #8
    1c60:	bd10      	pop	{r4, pc}
    1c62:	f7ff ff31 	bl	1ac8 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.1]>
    1c66:	e7f5      	b.n	1c54 <VisualMicroDebug::OnBreakPointEnd()+0x10>
    1c68:	1fffb440 	.word	0x1fffb440

00001c6c <VisualMicroDebug::outPacketStart(bool)>:
	return outPacketStart(false);
}


bool VisualMicroDebug::outPacketStart(bool noWait)
{
    1c6c:	b410      	push	{r4}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c6e:	4a10      	ldr	r2, [pc, #64]	; (1cb0 <VisualMicroDebug::outPacketStart(bool)+0x44>)
    1c70:	b085      	sub	sp, #20
	yield();
#endif


#if defined(VM_DEBUG_BANDWIDTH_THROTTLE_MS) //&& (VM_DBT != VM_DBT_NET_UDP)
	if (!noWait)
    1c72:	b9a1      	cbnz	r1, 1c9e <VisualMicroDebug::outPacketStart(bool)+0x32>
    1c74:	6813      	ldr	r3, [r2, #0]
    1c76:	9300      	str	r3, [sp, #0]
	{

		unsigned long ms_wait;
		ms_wait = (DBG_Millis() - lastPacketMS);
    1c78:	6841      	ldr	r1, [r0, #4]
	return ret;
    1c7a:	9b00      	ldr	r3, [sp, #0]
    1c7c:	1a59      	subs	r1, r3, r1
		if (ms_wait < VM_DEBUG_BANDWIDTH_THROTTLE_MS)
    1c7e:	2920      	cmp	r1, #32
    1c80:	d80d      	bhi.n	1c9e <VisualMicroDebug::outPacketStart(bool)+0x32>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c82:	6813      	ldr	r3, [r2, #0]
    1c84:	9302      	str	r3, [sp, #8]
	return ret;
    1c86:	9c02      	ldr	r4, [sp, #8]
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
{
	unsigned long ms_start = DBG_Millis();
	unsigned long ms_end = ms_start + ms;
    1c88:	f104 0321 	add.w	r3, r4, #33	; 0x21
    1c8c:	1a59      	subs	r1, r3, r1
    1c8e:	e001      	b.n	1c94 <VisualMicroDebug::outPacketStart(bool)+0x28>

		//delay(1);

		ms_curr = DBG_Millis();

		if (ms_curr<ms_start || ms_curr>ms_end) {
    1c90:	4299      	cmp	r1, r3
    1c92:	d304      	bcc.n	1c9e <VisualMicroDebug::outPacketStart(bool)+0x32>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c94:	6813      	ldr	r3, [r2, #0]
    1c96:	9301      	str	r3, [sp, #4]
	return ret;
    1c98:	9b01      	ldr	r3, [sp, #4]
    1c9a:	429c      	cmp	r4, r3
    1c9c:	d9f8      	bls.n	1c90 <VisualMicroDebug::outPacketStart(bool)+0x24>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c9e:	6813      	ldr	r3, [r2, #0]
    1ca0:	9303      	str	r3, [sp, #12]
	return ret;
    1ca2:	9b03      	ldr	r3, [sp, #12]
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
    1ca4:	6043      	str	r3, [r0, #4]
	transport->beginPacket();
#endif
#endif

	return true;
}
    1ca6:	2001      	movs	r0, #1
    1ca8:	b005      	add	sp, #20
    1caa:	bc10      	pop	{r4}
    1cac:	4770      	bx	lr
    1cae:	bf00      	nop
    1cb0:	1fffb440 	.word	0x1fffb440

00001cb4 <VisualMicroDebug::outPacketEnd()>:
    1cb4:	4770      	bx	lr
    1cb6:	bf00      	nop

00001cb8 <VisualMicroDebug::begin(unsigned long)>:
{

	//todo: detect usb type ports that need a delay
	//don't wait for the port unless we add a timeout and disable debug. because we might be discntected
	//todo: see if esp can handle this delay wuith wifi also connecting!
	delay(1000);
    1cb8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1cbc:	f003 b8ce 	b.w	4e5c <delay>

00001cc0 <VisualMicroDebug::init(unsigned long)>:
	vmdebug.init();
	vmdebug.stats();
#endif


	baudRate = 0L; //gets a value later if required, only used by cosa for a re-begin!
    1cc0:	2300      	movs	r3, #0
    1cc2:	6443      	str	r3, [r0, #68]	; 0x44

	lastPacketMS = 0L;
    1cc4:	6043      	str	r3, [r0, #4]

	//note: a delay at start causes esp8266 wifi to fail to connect!!
	//		the delay can also be switched off via board/platform.txt property=
	if (delayMs > 0)
    1cc6:	b171      	cbz	r1, 1ce6 <VisualMicroDebug::init(unsigned long)+0x26>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1cc8:	4807      	ldr	r0, [pc, #28]	; (1ce8 <VisualMicroDebug::init(unsigned long)+0x28>)

}
#endif
#else
void VisualMicroDebug::init(unsigned long delayMs)
{
    1cca:	b082      	sub	sp, #8
    1ccc:	6803      	ldr	r3, [r0, #0]
    1cce:	9301      	str	r3, [sp, #4]
	return ret;
    1cd0:	9a01      	ldr	r2, [sp, #4]
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
{
	unsigned long ms_start = DBG_Millis();
	unsigned long ms_end = ms_start + ms;
    1cd2:	4411      	add	r1, r2
    1cd4:	e001      	b.n	1cda <VisualMicroDebug::init(unsigned long)+0x1a>

		//delay(1);

		ms_curr = DBG_Millis();

		if (ms_curr<ms_start || ms_curr>ms_end) {
    1cd6:	4299      	cmp	r1, r3
    1cd8:	d304      	bcc.n	1ce4 <VisualMicroDebug::init(unsigned long)+0x24>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1cda:	6803      	ldr	r3, [r0, #0]
    1cdc:	9300      	str	r3, [sp, #0]
	return ret;
    1cde:	9b00      	ldr	r3, [sp, #0]
    1ce0:	429a      	cmp	r2, r3
    1ce2:	d9f8      	bls.n	1cd6 <VisualMicroDebug::init(unsigned long)+0x16>
	//note: a delay at start causes esp8266 wifi to fail to connect!!
	//		the delay can also be switched off via board/platform.txt property=
	if (delayMs > 0)
		DBG_YieldAndWait(delayMs);

}
    1ce4:	b002      	add	sp, #8
    1ce6:	4770      	bx	lr
    1ce8:	1fffb440 	.word	0x1fffb440

00001cec <VisualMicroDebug::sendContinuedACK(unsigned char)>:
}
#endif


void VisualMicroDebug::sendContinuedACK(uint8_t breakPointId)
{
    1cec:	b530      	push	{r4, r5, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1cee:	4c13      	ldr	r4, [pc, #76]	; (1d3c <VisualMicroDebug::sendContinuedACK(unsigned char)+0x50>)
    1cf0:	b085      	sub	sp, #20
    1cf2:	6823      	ldr	r3, [r4, #0]
    1cf4:	9303      	str	r3, [sp, #12]
	return ret;
    1cf6:	9b03      	ldr	r3, [sp, #12]
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
    1cf8:	6043      	str	r3, [r0, #4]
}
#endif


void VisualMicroDebug::sendContinuedACK(uint8_t breakPointId)
{
    1cfa:	460d      	mov	r5, r1
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1cfc:	4810      	ldr	r0, [pc, #64]	; (1d40 <VisualMicroDebug::sendContinuedACK(unsigned char)+0x54>)
    1cfe:	2106      	movs	r1, #6
    1d00:	f004 fc0a 	bl	6518 <usb_serial_write>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d04:	2300      	movs	r3, #0
    1d06:	220a      	movs	r2, #10
    1d08:	4629      	mov	r1, r5
    1d0a:	480e      	ldr	r0, [pc, #56]	; (1d44 <VisualMicroDebug::sendContinuedACK(unsigned char)+0x58>)
    1d0c:	f004 fe7e 	bl	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d10:	2106      	movs	r1, #6
    1d12:	480d      	ldr	r0, [pc, #52]	; (1d48 <VisualMicroDebug::sendContinuedACK(unsigned char)+0x5c>)
    1d14:	f004 fc00 	bl	6518 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1d18:	480a      	ldr	r0, [pc, #40]	; (1d44 <VisualMicroDebug::sendContinuedACK(unsigned char)+0x58>)
    1d1a:	f004 fe63 	bl	69e4 <Print::println()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d1e:	6823      	ldr	r3, [r4, #0]
    1d20:	9302      	str	r3, [sp, #8]
	return ret;
    1d22:	9a02      	ldr	r2, [sp, #8]
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
{
	unsigned long ms_start = DBG_Millis();
	unsigned long ms_end = ms_start + ms;
    1d24:	f102 0132 	add.w	r1, r2, #50	; 0x32
    1d28:	e001      	b.n	1d2e <VisualMicroDebug::sendContinuedACK(unsigned char)+0x42>

		//delay(1);

		ms_curr = DBG_Millis();

		if (ms_curr<ms_start || ms_curr>ms_end) {
    1d2a:	4299      	cmp	r1, r3
    1d2c:	d304      	bcc.n	1d38 <VisualMicroDebug::sendContinuedACK(unsigned char)+0x4c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d2e:	6823      	ldr	r3, [r4, #0]
    1d30:	9301      	str	r3, [sp, #4]
	return ret;
    1d32:	9b01      	ldr	r3, [sp, #4]
    1d34:	429a      	cmp	r2, r3
    1d36:	d9f8      	bls.n	1d2a <VisualMicroDebug::sendContinuedACK(unsigned char)+0x3e>
		//nb: 2560 looses some chars of 2nd and third print statements after startup. todo: look into this!
		//the following delay seems to sort it out sometimes!
	DBG_YieldAndWait(50);

#endif //#if defined(VM_DBT) 
}
    1d38:	b005      	add	sp, #20
    1d3a:	bd30      	pop	{r4, r5, pc}
    1d3c:	1fffb440 	.word	0x1fffb440
    1d40:	00009360 	.word	0x00009360
    1d44:	1fff8760 	.word	0x1fff8760
    1d48:	00009368 	.word	0x00009368

00001d4c <VisualMicroDebug::breakWait(unsigned char)>:
#if defined(VM_DBT) //&& ( VM_DBT == VM_DBT_HARDWARESERIAL || VM_DBT == VM_DBT_FASTSERIAL)
//TODO: implement sturcture serial com!
//we never get called if break was not set during compliation
//return _vm_cmd so that we can setVariable if required (caller needs to know result)
uint8_t VisualMicroDebug::breakWait(uint8_t breakPointId)
{
    1d4c:	b538      	push	{r3, r4, r5, lr}
	//console write not working yet
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_CONSOLE)
	return 'c';
#endif

	if (!alwaysBreak)
    1d4e:	7e03      	ldrb	r3, [r0, #24]
    1d50:	b90b      	cbnz	r3, 1d56 <VisualMicroDebug::breakWait(unsigned char)+0xa>
		case 'h':
			//Serial.println("Remote debug session started");
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_UDP)
			alwaysBreak = true;
#endif
			return 'c';
    1d52:	2063      	movs	r0, #99	; 0x63
	//sendContinuedACK(breakPointId);
	//return 'c'; //if we get here we are continuing!

	//	return '?'; //software serial rubbish detected?
	return 'e';
}
    1d54:	bd38      	pop	{r3, r4, r5, pc}
    1d56:	460d      	mov	r5, r1
    1d58:	4604      	mov	r4, r0
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1d5a:	f004 fbb3 	bl	64c4 <usb_serial_available>
#endif

	uint8_t b;

	//break/pause until we get a command
	if (available() == 0)
    1d5e:	f010 0fff 	tst.w	r0, #255	; 0xff
    1d62:	d101      	bne.n	1d68 <VisualMicroDebug::breakWait(unsigned char)+0x1c>
		if (!UDPConnectionStarted) {
			return 'c';
		}
#endif

		return 'e';
    1d64:	2065      	movs	r0, #101	; 0x65
    1d66:	bd38      	pop	{r3, r4, r5, pc}
    1d68:	f004 fbac 	bl	64c4 <usb_serial_available>
	//doh!  better if we have any key to continue so users data doesn't get lost so much. 
	//NOTE. pause/breakpoints are best used with dedicated port!
	//while(true)
	//{

	while (available() > 0)
    1d6c:	f010 0fff 	tst.w	r0, #255	; 0xff
    1d70:	d0f8      	beq.n	1d64 <VisualMicroDebug::breakWait(unsigned char)+0x18>
        virtual int read() { return usb_serial_getchar(); }
    1d72:	f004 fb6b 	bl	644c <usb_serial_getchar>
		//		while(VM_DEBUGGER_SOFT_TRANSPORT.available()>0)
		//		{
		//			b = VM_DEBUGGER_SOFT_TRANSPORT.read();
		//#endif
		//debug break commands
		switch (b)
    1d76:	b2c0      	uxtb	r0, r0
    1d78:	f1a0 0358 	sub.w	r3, r0, #88	; 0x58
    1d7c:	2b1e      	cmp	r3, #30
    1d7e:	d8f3      	bhi.n	1d68 <VisualMicroDebug::breakWait(unsigned char)+0x1c>
    1d80:	a201      	add	r2, pc, #4	; (adr r2, 1d88 <VisualMicroDebug::breakWait(unsigned char)+0x3c>)
    1d82:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1d86:	bf00      	nop
    1d88:	00001e11 	.word	0x00001e11
    1d8c:	00001d69 	.word	0x00001d69
    1d90:	00001d69 	.word	0x00001d69
    1d94:	00001d69 	.word	0x00001d69
    1d98:	00001d69 	.word	0x00001d69
    1d9c:	00001d69 	.word	0x00001d69
    1da0:	00001d69 	.word	0x00001d69
    1da4:	00001d69 	.word	0x00001d69
    1da8:	00001d69 	.word	0x00001d69
    1dac:	00001d69 	.word	0x00001d69
    1db0:	00001d69 	.word	0x00001d69
    1db4:	00001e05 	.word	0x00001e05
    1db8:	00001d69 	.word	0x00001d69
    1dbc:	00001d69 	.word	0x00001d69
    1dc0:	00001d69 	.word	0x00001d69
    1dc4:	00001d69 	.word	0x00001d69
    1dc8:	00001d53 	.word	0x00001d53
    1dcc:	00001d69 	.word	0x00001d69
    1dd0:	00001d69 	.word	0x00001d69
    1dd4:	00001d69 	.word	0x00001d69
    1dd8:	00001d69 	.word	0x00001d69
    1ddc:	00001d69 	.word	0x00001d69
    1de0:	00001d69 	.word	0x00001d69
    1de4:	00001d69 	.word	0x00001d69
    1de8:	00001d69 	.word	0x00001d69
    1dec:	00001d53 	.word	0x00001d53
    1df0:	00001d69 	.word	0x00001d69
    1df4:	00001d69 	.word	0x00001d69
    1df8:	00001d69 	.word	0x00001d69
    1dfc:	00001d69 	.word	0x00001d69
    1e00:	00001d55 	.word	0x00001d55
		{

		case 'c':
			sendContinuedACK(breakPointId);
    1e04:	4620      	mov	r0, r4
    1e06:	4629      	mov	r1, r5
    1e08:	f7ff ff70 	bl	1cec <VisualMicroDebug::sendContinuedACK(unsigned char)>
			return 'c'; //if we get here we are continuing!
    1e0c:	2063      	movs	r0, #99	; 0x63
    1e0e:	bd38      	pop	{r3, r4, r5, pc}
					  //	sendContinuedACK(breakPointId);
					  //	return;

					  //switch off break until re-start. for dev/testing
		case 'X':
			alwaysBreak = false;
    1e10:	2300      	movs	r3, #0
    1e12:	7623      	strb	r3, [r4, #24]
			return 'c';
    1e14:	2063      	movs	r0, #99	; 0x63
    1e16:	bd38      	pop	{r3, r4, r5, pc}

00001e18 <VisualMicroDebug::start(bool, bool)>:
}
#endif


void VisualMicroDebug::start(bool waitForKeyToStart, bool _alwaysBreak)
{
    1e18:	b570      	push	{r4, r5, r6, lr}
    1e1a:	4605      	mov	r5, r0
    1e1c:	b082      	sub	sp, #8
    1e1e:	4616      	mov	r6, r2
#if defined (VM_DEBUG_BREAKPAUSE)
	if (waitForKeyToStart)
    1e20:	b1c9      	cbz	r1, 1e56 <VisualMicroDebug::start(bool, bool)+0x3e>
	{
		alwaysBreak = true;
    1e22:	2301      	movs	r3, #1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1e24:	4c0d      	ldr	r4, [pc, #52]	; (1e5c <VisualMicroDebug::start(bool, bool)+0x44>)
    1e26:	7603      	strb	r3, [r0, #24]

		//server should know we are waiting sendMessage("Press any key to continue");
		while (breakWait(0) != 'c') {
    1e28:	2100      	movs	r1, #0
    1e2a:	4628      	mov	r0, r5
    1e2c:	f7ff ff8e 	bl	1d4c <VisualMicroDebug::breakWait(unsigned char)>
    1e30:	2863      	cmp	r0, #99	; 0x63
    1e32:	d010      	beq.n	1e56 <VisualMicroDebug::start(bool, bool)+0x3e>
    1e34:	6823      	ldr	r3, [r4, #0]
    1e36:	9301      	str	r3, [sp, #4]
	return ret;
    1e38:	9a01      	ldr	r2, [sp, #4]
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
{
	unsigned long ms_start = DBG_Millis();
	unsigned long ms_end = ms_start + ms;
    1e3a:	1c51      	adds	r1, r2, #1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1e3c:	6823      	ldr	r3, [r4, #0]
    1e3e:	9300      	str	r3, [sp, #0]
	return ret;
    1e40:	9b00      	ldr	r3, [sp, #0]

		//delay(1);

		ms_curr = DBG_Millis();

		if (ms_curr<ms_start || ms_curr>ms_end) {
    1e42:	429a      	cmp	r2, r3
    1e44:	d8f0      	bhi.n	1e28 <VisualMicroDebug::start(bool, bool)+0x10>
    1e46:	4299      	cmp	r1, r3
    1e48:	d2f8      	bcs.n	1e3c <VisualMicroDebug::start(bool, bool)+0x24>
	if (waitForKeyToStart)
	{
		alwaysBreak = true;

		//server should know we are waiting sendMessage("Press any key to continue");
		while (breakWait(0) != 'c') {
    1e4a:	2100      	movs	r1, #0
    1e4c:	4628      	mov	r0, r5
    1e4e:	f7ff ff7d 	bl	1d4c <VisualMicroDebug::breakWait(unsigned char)>
    1e52:	2863      	cmp	r0, #99	; 0x63
    1e54:	d1ee      	bne.n	1e34 <VisualMicroDebug::start(bool, bool)+0x1c>
			DBG_YieldAndWait(1);
		}
		//breakWait(0);
	}
	alwaysBreak = _alwaysBreak;
    1e56:	762e      	strb	r6, [r5, #24]
#endif

}
    1e58:	b002      	add	sp, #8
    1e5a:	bd70      	pop	{r4, r5, r6, pc}
    1e5c:	1fffb440 	.word	0x1fffb440

00001e60 <_GLOBAL__sub_I__ZN16VisualMicroDebug16DBG_YieldAndWaitEm>:
	//wait if we have to
	//try to prevent new users from overloading bandwidth and filling windows buffer
	//can be overriden via preferences
	//defaults to 50ms; needs to allow time for windows to recover if it pauses, so we need to be slower than the extensions and debugger can process + a bit

	BreakStartMillis = 0L;
    1e60:	4b03      	ldr	r3, [pc, #12]	; (1e70 <_GLOBAL__sub_I__ZN16VisualMicroDebug16DBG_YieldAndWaitEm+0x10>)
    1e62:	2200      	movs	r2, #0
    1e64:	609a      	str	r2, [r3, #8]
	BreakPrevMillis = 0L;
    1e66:	60da      	str	r2, [r3, #12]
	InBreakMsgRepeatMS = 0L;
    1e68:	611a      	str	r2, [r3, #16]
	InBreakMsgSent = 0L;
    1e6a:	615a      	str	r2, [r3, #20]
    1e6c:	4770      	bx	lr
    1e6e:	bf00      	nop
    1e70:	1fffafcc 	.word	0x1fffafcc

00001e74 <OctoWS2811::isr()>:
	dma3.attachInterrupt(isr);
	//pinMode(1, OUTPUT); // testing: oscilloscope trigger
}

void OctoWS2811::isr(void)
{
    1e74:	b508      	push	{r3, lr}
    1e76:	4a06      	ldr	r2, [pc, #24]	; (1e90 <OctoWS2811::isr()+0x1c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    1e78:	4b06      	ldr	r3, [pc, #24]	; (1e94 <OctoWS2811::isr()+0x20>)
    1e7a:	7912      	ldrb	r2, [r2, #4]
    1e7c:	701a      	strb	r2, [r3, #0]
	dma3.clearInterrupt();
	update_completed_at = micros();
    1e7e:	f002 ffcb 	bl	4e18 <micros>
    1e82:	4a05      	ldr	r2, [pc, #20]	; (1e98 <OctoWS2811::isr()+0x24>)
	update_in_progress = 0;
    1e84:	4b05      	ldr	r3, [pc, #20]	; (1e9c <OctoWS2811::isr()+0x28>)
}

void OctoWS2811::isr(void)
{
	dma3.clearInterrupt();
	update_completed_at = micros();
    1e86:	6010      	str	r0, [r2, #0]
	update_in_progress = 0;
    1e88:	2200      	movs	r2, #0
    1e8a:	701a      	strb	r2, [r3, #0]
    1e8c:	bd08      	pop	{r3, pc}
    1e8e:	bf00      	nop
    1e90:	1fffb034 	.word	0x1fffb034
    1e94:	4000801f 	.word	0x4000801f
    1e98:	1fffb018 	.word	0x1fffb018
    1e9c:	1fffb030 	.word	0x1fffb030

00001ea0 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
    1ea0:	b510      	push	{r4, lr}
    1ea2:	4604      	mov	r4, r0
		release();
    1ea4:	f004 fca0 	bl	67e8 <DMAChannel::release()>
	}
    1ea8:	4620      	mov	r0, r4
    1eaa:	bd10      	pop	{r4, pc}

00001eac <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)>:
static const uint8_t ones = 0xFF;
static volatile uint8_t update_in_progress = 0;
static uint32_t update_completed_at = 0;


OctoWS2811::OctoWS2811(uint32_t numPerStrip, void *frameBuf, void *drawBuf, uint8_t config)
    1eac:	b4f0      	push	{r4, r5, r6, r7}
{
	stripLen = numPerStrip;
    1eae:	4f06      	ldr	r7, [pc, #24]	; (1ec8 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x1c>)
	frameBuffer = frameBuf;
    1eb0:	4e06      	ldr	r6, [pc, #24]	; (1ecc <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x20>)
	drawBuffer = drawBuf;
    1eb2:	4d07      	ldr	r5, [pc, #28]	; (1ed0 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x24>)
	params = config;
    1eb4:	4c07      	ldr	r4, [pc, #28]	; (1ed4 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x28>)
static uint32_t update_completed_at = 0;


OctoWS2811::OctoWS2811(uint32_t numPerStrip, void *frameBuf, void *drawBuf, uint8_t config)
{
	stripLen = numPerStrip;
    1eb6:	8039      	strh	r1, [r7, #0]
static const uint8_t ones = 0xFF;
static volatile uint8_t update_in_progress = 0;
static uint32_t update_completed_at = 0;


OctoWS2811::OctoWS2811(uint32_t numPerStrip, void *frameBuf, void *drawBuf, uint8_t config)
    1eb8:	f89d 1010 	ldrb.w	r1, [sp, #16]
{
	stripLen = numPerStrip;
	frameBuffer = frameBuf;
    1ebc:	6032      	str	r2, [r6, #0]
	drawBuffer = drawBuf;
    1ebe:	602b      	str	r3, [r5, #0]
	params = config;
    1ec0:	7021      	strb	r1, [r4, #0]
}
    1ec2:	bcf0      	pop	{r4, r5, r6, r7}
    1ec4:	4770      	bx	lr
    1ec6:	bf00      	nop
    1ec8:	1fffb020 	.word	0x1fffb020
    1ecc:	1fffb01c 	.word	0x1fffb01c
    1ed0:	1fffb02c 	.word	0x1fffb02c
    1ed4:	1fffb014 	.word	0x1fffb014

00001ed8 <OctoWS2811::begin()>:

void OctoWS2811::begin(void)
{
	uint32_t bufsize, frequency;

	bufsize = stripLen*24;
    1ed8:	4b71      	ldr	r3, [pc, #452]	; (20a0 <OctoWS2811::begin()+0x1c8>)
// Discussion about timing and flicker & color shift issues:
// http://forum.pjrc.com/threads/23877-WS2812B-compatible-with-OctoWS2811-library?p=38190&viewfull=1#post38190


void OctoWS2811::begin(void)
{
    1eda:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t bufsize, frequency;

	bufsize = stripLen*24;
    1ede:	881c      	ldrh	r4, [r3, #0]

	// set up the buffers
	memset(frameBuffer, 0, bufsize);
    1ee0:	f8df 8200 	ldr.w	r8, [pc, #512]	; 20e4 <OctoWS2811::begin()+0x20c>

void OctoWS2811::begin(void)
{
	uint32_t bufsize, frequency;

	bufsize = stripLen*24;
    1ee4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    1ee8:	00e4      	lsls	r4, r4, #3

	// set up the buffers
	memset(frameBuffer, 0, bufsize);
    1eea:	f8d8 0000 	ldr.w	r0, [r8]
    1eee:	4622      	mov	r2, r4
    1ef0:	2100      	movs	r1, #0
    1ef2:	f006 f9c9 	bl	8288 <memset>
	if (drawBuffer) {
    1ef6:	4b6b      	ldr	r3, [pc, #428]	; (20a4 <OctoWS2811::begin()+0x1cc>)
    1ef8:	6818      	ldr	r0, [r3, #0]
    1efa:	2800      	cmp	r0, #0
    1efc:	f000 80cc 	beq.w	2098 <OctoWS2811::begin()+0x1c0>
		memset(drawBuffer, 0, bufsize);
    1f00:	4622      	mov	r2, r4
    1f02:	2100      	movs	r1, #0
    1f04:	f006 f9c0 	bl	8288 <memset>
	} else {
		drawBuffer = frameBuffer;
	}
	
	// configure the 8 output pins
	GPIOD_PCOR = 0xFF;
    1f08:	4f67      	ldr	r7, [pc, #412]	; (20a8 <OctoWS2811::begin()+0x1d0>)
	pinMode(20, OUTPUT);	// strip #6
	pinMode(21, OUTPUT);	// strip #7
	pinMode(5, OUTPUT);	// strip #8

	// create the two waveforms for WS2811 low and high bits
	frequency = (params & WS2811_400kHz) ? 400000 : 800000;
    1f0a:	4d68      	ldr	r5, [pc, #416]	; (20ac <OctoWS2811::begin()+0x1d4>)
	dma2.TCD->DLASTSGA = 0;
	dma2.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma2.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #3 clear all the pins low at 48% of the cycle
	dma3.TCD->SADDR = &ones;
    1f0c:	4e68      	ldr	r6, [pc, #416]	; (20b0 <OctoWS2811::begin()+0x1d8>)
	} else {
		drawBuffer = frameBuffer;
	}
	
	// configure the 8 output pins
	GPIOD_PCOR = 0xFF;
    1f0e:	23ff      	movs	r3, #255	; 0xff
    1f10:	603b      	str	r3, [r7, #0]
	pinMode(2, OUTPUT);	// strip #1
    1f12:	2101      	movs	r1, #1
    1f14:	2002      	movs	r0, #2
    1f16:	f002 ff79 	bl	4e0c <pinMode>
	pinMode(14, OUTPUT);	// strip #2
    1f1a:	2101      	movs	r1, #1
    1f1c:	200e      	movs	r0, #14
    1f1e:	f002 ff75 	bl	4e0c <pinMode>
	pinMode(7, OUTPUT);	// strip #3
    1f22:	2101      	movs	r1, #1
    1f24:	2007      	movs	r0, #7
    1f26:	f002 ff71 	bl	4e0c <pinMode>
	pinMode(8, OUTPUT);	// strip #4
    1f2a:	2101      	movs	r1, #1
    1f2c:	2008      	movs	r0, #8
    1f2e:	f002 ff6d 	bl	4e0c <pinMode>
	pinMode(6, OUTPUT);	// strip #5
    1f32:	2101      	movs	r1, #1
    1f34:	2006      	movs	r0, #6
    1f36:	f002 ff69 	bl	4e0c <pinMode>
	pinMode(20, OUTPUT);	// strip #6
    1f3a:	2101      	movs	r1, #1
    1f3c:	2014      	movs	r0, #20
    1f3e:	f002 ff65 	bl	4e0c <pinMode>
	pinMode(21, OUTPUT);	// strip #7
    1f42:	2101      	movs	r1, #1
    1f44:	2015      	movs	r0, #21
    1f46:	f002 ff61 	bl	4e0c <pinMode>
	pinMode(5, OUTPUT);	// strip #8
    1f4a:	2101      	movs	r1, #1
    1f4c:	2005      	movs	r0, #5
    1f4e:	f002 ff5d 	bl	4e0c <pinMode>

	// create the two waveforms for WS2811 low and high bits
	frequency = (params & WS2811_400kHz) ? 400000 : 800000;
    1f52:	4a58      	ldr	r2, [pc, #352]	; (20b4 <OctoWS2811::begin()+0x1dc>)
    1f54:	4b58      	ldr	r3, [pc, #352]	; (20b8 <OctoWS2811::begin()+0x1e0>)
    1f56:	7812      	ldrb	r2, [r2, #0]
    1f58:	f012 0f10 	tst.w	r2, #16
    1f5c:	bf18      	it	ne
    1f5e:	461d      	movne	r5, r3

void pinMode(uint8_t pin, uint8_t mode);
void init_pins(void);
void analogWrite(uint8_t pin, int val);
uint32_t analogWriteRes(uint32_t bits);
static inline uint32_t analogWriteResolution(uint32_t bits) { return analogWriteRes(bits); }
    1f60:	2008      	movs	r0, #8
    1f62:	f002 febb 	bl	4cdc <analogWriteRes>
	analogWriteResolution(8);
	analogWriteFrequency(3, frequency);
    1f66:	4628      	mov	r0, r5
    1f68:	f005 fba8 	bl	76bc <__aeabi_ui2f>
    1f6c:	4605      	mov	r5, r0
    1f6e:	4601      	mov	r1, r0
    1f70:	2003      	movs	r0, #3
    1f72:	f002 fec3 	bl	4cfc <analogWriteFrequency>
	analogWriteFrequency(4, frequency);
    1f76:	4629      	mov	r1, r5
    1f78:	2004      	movs	r0, #4
    1f7a:	f002 febf 	bl	4cfc <analogWriteFrequency>
	analogWrite(3, WS2811_TIMING_T0H);
    1f7e:	213c      	movs	r1, #60	; 0x3c
    1f80:	2003      	movs	r0, #3
    1f82:	f002 fdad 	bl	4ae0 <analogWrite>
	analogWrite(4, WS2811_TIMING_T1H);
    1f86:	21b0      	movs	r1, #176	; 0xb0
    1f88:	2004      	movs	r0, #4
    1f8a:	f002 fda9 	bl	4ae0 <analogWrite>

	// pin 16 triggers DMA(port B) on rising edge (configure for pin 3's waveform)
	CORE_PIN16_CONFIG = PORT_PCR_IRQC(1)|PORT_PCR_MUX(3);
    1f8e:	4b4b      	ldr	r3, [pc, #300]	; (20bc <OctoWS2811::begin()+0x1e4>)
    1f90:	4a4b      	ldr	r2, [pc, #300]	; (20c0 <OctoWS2811::begin()+0x1e8>)
    1f92:	601a      	str	r2, [r3, #0]
	pinMode(3, INPUT_PULLUP); // pin 3 no longer needed
    1f94:	2102      	movs	r1, #2
    1f96:	2003      	movs	r0, #3
    1f98:	f002 ff38 	bl	4e0c <pinMode>

	// pin 15 triggers DMA(port C) on falling edge of low duty waveform
	// pin 15 and 16 must be connected by the user: 16 is output, 15 is input
	pinMode(15, INPUT);
    1f9c:	2100      	movs	r1, #0
    1f9e:	200f      	movs	r0, #15
    1fa0:	f002 ff34 	bl	4e0c <pinMode>

	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
    1fa4:	f8df c140 	ldr.w	ip, [pc, #320]	; 20e8 <OctoWS2811::begin()+0x210>
	pinMode(3, INPUT_PULLUP); // pin 3 no longer needed

	// pin 15 triggers DMA(port C) on falling edge of low duty waveform
	// pin 15 and 16 must be connected by the user: 16 is output, 15 is input
	pinMode(15, INPUT);
	CORE_PIN15_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(1);
    1fa8:	4946      	ldr	r1, [pc, #280]	; (20c4 <OctoWS2811::begin()+0x1ec>)

	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);
    1faa:	4b47      	ldr	r3, [pc, #284]	; (20c8 <OctoWS2811::begin()+0x1f0>)
	pinMode(3, INPUT_PULLUP); // pin 3 no longer needed

	// pin 15 triggers DMA(port C) on falling edge of low duty waveform
	// pin 15 and 16 must be connected by the user: 16 is output, 15 is input
	pinMode(15, INPUT);
	CORE_PIN15_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(1);
    1fac:	4847      	ldr	r0, [pc, #284]	; (20cc <OctoWS2811::begin()+0x1f4>)
    1fae:	6008      	str	r0, [r1, #0]

	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);
    1fb0:	4a47      	ldr	r2, [pc, #284]	; (20d0 <OctoWS2811::begin()+0x1f8>)

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
    1fb2:	f8dc 1000 	ldr.w	r1, [ip]
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma1.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
    1fb6:	f8df e134 	ldr.w	lr, [pc, #308]	; 20ec <OctoWS2811::begin()+0x214>
	// pin 15 and 16 must be connected by the user: 16 is output, 15 is input
	pinMode(15, INPUT);
	CORE_PIN15_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(1);

	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);
    1fba:	601a      	str	r2, [r3, #0]
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma1.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
    1fbc:	f8d8 a000 	ldr.w	sl, [r8]
	dma1.TCD->SADDR = &ones;
	dma1.TCD->SOFF = 0;
	dma1.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma1.TCD->NBYTES_MLNO = 1;
	dma1.TCD->SLAST = 0;
	dma1.TCD->DADDR = &GPIOD_PSOR;
    1fc0:	4a44      	ldr	r2, [pc, #272]	; (20d4 <OctoWS2811::begin()+0x1fc>)

	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
    1fc2:	f8df 812c 	ldr.w	r8, [pc, #300]	; 20f0 <OctoWS2811::begin()+0x218>
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma1.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
    1fc6:	f8de 0000 	ldr.w	r0, [lr]

	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
    1fca:	f8c1 8000 	str.w	r8, [r1]
	dma1.TCD->SOFF = 0;
    1fce:	2300      	movs	r3, #0
	dma1.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma1.TCD->NBYTES_MLNO = 1;
	dma1.TCD->SLAST = 0;
	dma1.TCD->DADDR = &GPIOD_PSOR;
    1fd0:	610a      	str	r2, [r1, #16]
	dma1.TCD->DOFF = 0;
	dma1.TCD->CITER_ELINKNO = bufsize;
    1fd2:	b2a5      	uxth	r5, r4

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
	dma1.TCD->SOFF = 0;
	dma1.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma1.TCD->NBYTES_MLNO = 1;
    1fd4:	2201      	movs	r2, #1
	dma1.TCD->SLAST = 0;
	dma1.TCD->DADDR = &GPIOD_PSOR;
	dma1.TCD->DOFF = 0;
	dma1.TCD->CITER_ELINKNO = bufsize;
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
    1fd6:	f04f 0908 	mov.w	r9, #8
	dma1.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma1.TCD->NBYTES_MLNO = 1;
	dma1.TCD->SLAST = 0;
	dma1.TCD->DADDR = &GPIOD_PSOR;
	dma1.TCD->DOFF = 0;
	dma1.TCD->CITER_ELINKNO = bufsize;
    1fda:	82cd      	strh	r5, [r1, #22]
	// pin 4 triggers DMA(port A) on falling edge of high duty waveform
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
	dma1.TCD->SOFF = 0;
    1fdc:	808b      	strh	r3, [r1, #4]
	dma1.TCD->SLAST = 0;
	dma1.TCD->DADDR = &GPIOD_PSOR;
	dma1.TCD->DOFF = 0;
	dma1.TCD->CITER_ELINKNO = bufsize;
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
    1fde:	f8a1 901c 	strh.w	r9, [r1, #28]
	CORE_PIN4_CONFIG = PORT_PCR_IRQC(2)|PORT_PCR_MUX(3);

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
	dma1.TCD->SOFF = 0;
	dma1.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
    1fe2:	80cb      	strh	r3, [r1, #6]
	dma1.TCD->DADDR = &GPIOD_PSOR;
	dma1.TCD->DOFF = 0;
	dma1.TCD->CITER_ELINKNO = bufsize;
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma1.TCD->BITER_ELINKNO = bufsize;
    1fe4:	83cd      	strh	r5, [r1, #30]

	// DMA channel #1 sets WS2811 high at the beginning of each cycle
	dma1.TCD->SADDR = &ones;
	dma1.TCD->SOFF = 0;
	dma1.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma1.TCD->NBYTES_MLNO = 1;
    1fe6:	608a      	str	r2, [r1, #8]
	dma1.TCD->SLAST = 0;
    1fe8:	60cb      	str	r3, [r1, #12]
	dma1.TCD->DADDR = &GPIOD_PSOR;
	dma1.TCD->DOFF = 0;
    1fea:	828b      	strh	r3, [r1, #20]
	dma1.TCD->CITER_ELINKNO = bufsize;
	dma1.TCD->DLASTSGA = 0;
    1fec:	618b      	str	r3, [r1, #24]
	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
	dma2.TCD->SOFF = 1;
	dma2.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma2.TCD->NBYTES_MLNO = 1;
	dma2.TCD->SLAST = -bufsize;
    1fee:	4264      	negs	r4, r4
	dma2.TCD->DLASTSGA = 0;
	dma2.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma2.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #3 clear all the pins low at 48% of the cycle
	dma3.TCD->SADDR = &ones;
    1ff0:	6831      	ldr	r1, [r6, #0]
	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
	dma2.TCD->SOFF = 1;
	dma2.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma2.TCD->NBYTES_MLNO = 1;
	dma2.TCD->SLAST = -bufsize;
    1ff2:	60c4      	str	r4, [r0, #12]
	dma2.TCD->DADDR = &GPIOD_PDOR;
    1ff4:	4c38      	ldr	r4, [pc, #224]	; (20d8 <OctoWS2811::begin()+0x200>)
	dma1.TCD->DLASTSGA = 0;
	dma1.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma1.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
    1ff6:	f8c0 a000 	str.w	sl, [r0]
	dma2.TCD->SOFF = 1;
    1ffa:	8082      	strh	r2, [r0, #4]
	dma2.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma2.TCD->NBYTES_MLNO = 1;
	dma2.TCD->SLAST = -bufsize;
	dma2.TCD->DADDR = &GPIOD_PDOR;
    1ffc:	6104      	str	r4, [r0, #16]
	dma1.TCD->BITER_ELINKNO = bufsize;

	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
	dma2.TCD->SOFF = 1;
	dma2.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
    1ffe:	80c3      	strh	r3, [r0, #6]
	dma2.TCD->NBYTES_MLNO = 1;
	dma2.TCD->SLAST = -bufsize;
	dma2.TCD->DADDR = &GPIOD_PDOR;
	dma2.TCD->DOFF = 0;
	dma2.TCD->CITER_ELINKNO = bufsize;
    2000:	82c5      	strh	r5, [r0, #22]

	// DMA channel #2 writes the pixel data at 20% of the cycle
	dma2.TCD->SADDR = frameBuffer;
	dma2.TCD->SOFF = 1;
	dma2.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma2.TCD->NBYTES_MLNO = 1;
    2002:	6082      	str	r2, [r0, #8]
	dma2.TCD->SLAST = -bufsize;
	dma2.TCD->DADDR = &GPIOD_PDOR;
	dma2.TCD->DOFF = 0;
	dma2.TCD->CITER_ELINKNO = bufsize;
	dma2.TCD->DLASTSGA = 0;
	dma2.TCD->CSR = DMA_TCD_CSR_DREQ;
    2004:	f8a0 901c 	strh.w	r9, [r0, #28]
	dma2.TCD->SOFF = 1;
	dma2.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma2.TCD->NBYTES_MLNO = 1;
	dma2.TCD->SLAST = -bufsize;
	dma2.TCD->DADDR = &GPIOD_PDOR;
	dma2.TCD->DOFF = 0;
    2008:	8283      	strh	r3, [r0, #20]
	dma2.TCD->CITER_ELINKNO = bufsize;
	dma2.TCD->DLASTSGA = 0;
    200a:	6183      	str	r3, [r0, #24]
	dma2.TCD->CSR = DMA_TCD_CSR_DREQ;
	dma2.TCD->BITER_ELINKNO = bufsize;
    200c:	83c5      	strh	r5, [r0, #30]

	// DMA channel #3 clear all the pins low at 48% of the cycle
	dma3.TCD->SADDR = &ones;
    200e:	f8c1 8000 	str.w	r8, [r1]
	dma3.TCD->SOFF = 0;
    2012:	808b      	strh	r3, [r1, #4]
	dma3.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
    2014:	80cb      	strh	r3, [r1, #6]
	dma3.TCD->NBYTES_MLNO = 1;
    2016:	608a      	str	r2, [r1, #8]
	dma3.TCD->SLAST = 0;
    2018:	60cb      	str	r3, [r1, #12]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    201a:	f89c 0004 	ldrb.w	r0, [ip, #4]
	dma3.TCD->DADDR = &GPIOD_PCOR;
    201e:	610f      	str	r7, [r1, #16]
    2020:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    2024:	f500 3004 	add.w	r0, r0, #135168	; 0x21000
	dma3.TCD->DOFF = 0;
	dma3.TCD->CITER_ELINKNO = bufsize;
	dma3.TCD->DLASTSGA = 0;
	dma3.TCD->CSR = DMA_TCD_CSR_DREQ | DMA_TCD_CSR_INTMAJOR;
    2028:	240a      	movs	r4, #10
	dma3.TCD->BITER_ELINKNO = bufsize;

#ifdef __MK20DX256__
	MCM_CR = MCM_CR_SRAMLAP(1) | MCM_CR_SRAMUAP(0);
    202a:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 20f4 <OctoWS2811::begin()+0x21c>
	dma3.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma3.TCD->NBYTES_MLNO = 1;
	dma3.TCD->SLAST = 0;
	dma3.TCD->DADDR = &GPIOD_PCOR;
	dma3.TCD->DOFF = 0;
	dma3.TCD->CITER_ELINKNO = bufsize;
    202e:	82cd      	strh	r5, [r1, #22]
	dma3.TCD->CSR = DMA_TCD_CSR_DREQ | DMA_TCD_CSR_INTMAJOR;
	dma3.TCD->BITER_ELINKNO = bufsize;

#ifdef __MK20DX256__
	MCM_CR = MCM_CR_SRAMLAP(1) | MCM_CR_SRAMUAP(0);
	AXBS_PRS0 = 0x1032;
    2030:	f04f 2740 	mov.w	r7, #1073758208	; 0x40004000
	dma3.TCD->SLAST = 0;
	dma3.TCD->DADDR = &GPIOD_PCOR;
	dma3.TCD->DOFF = 0;
	dma3.TCD->CITER_ELINKNO = bufsize;
	dma3.TCD->DLASTSGA = 0;
	dma3.TCD->CSR = DMA_TCD_CSR_DREQ | DMA_TCD_CSR_INTMAJOR;
    2034:	838c      	strh	r4, [r1, #28]
	dma3.TCD->BITER_ELINKNO = bufsize;

#ifdef __MK20DX256__
	MCM_CR = MCM_CR_SRAMLAP(1) | MCM_CR_SRAMUAP(0);
    2036:	f04f 5980 	mov.w	r9, #268435456	; 0x10000000
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    203a:	24b2      	movs	r4, #178	; 0xb2
	AXBS_PRS0 = 0x1032;
    203c:	f241 0c32 	movw	ip, #4146	; 0x1032
	dma3.TCD->DADDR = &GPIOD_PCOR;
	dma3.TCD->DOFF = 0;
	dma3.TCD->CITER_ELINKNO = bufsize;
	dma3.TCD->DLASTSGA = 0;
	dma3.TCD->CSR = DMA_TCD_CSR_DREQ | DMA_TCD_CSR_INTMAJOR;
	dma3.TCD->BITER_ELINKNO = bufsize;
    2040:	83cd      	strh	r5, [r1, #30]
	dma3.TCD->SOFF = 0;
	dma3.TCD->ATTR = DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DSIZE(0);
	dma3.TCD->NBYTES_MLNO = 1;
	dma3.TCD->SLAST = 0;
	dma3.TCD->DADDR = &GPIOD_PCOR;
	dma3.TCD->DOFF = 0;
    2042:	828b      	strh	r3, [r1, #20]
	dma3.TCD->CITER_ELINKNO = bufsize;
	dma3.TCD->DLASTSGA = 0;
    2044:	618b      	str	r3, [r1, #24]
	dma3.TCD->CSR = DMA_TCD_CSR_DREQ | DMA_TCD_CSR_INTMAJOR;
	dma3.TCD->BITER_ELINKNO = bufsize;

#ifdef __MK20DX256__
	MCM_CR = MCM_CR_SRAMLAP(1) | MCM_CR_SRAMUAP(0);
    2046:	f8c8 9000 	str.w	r9, [r8]
	AXBS_PRS0 = 0x1032;
    204a:	f8c7 c000 	str.w	ip, [r7]

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    204e:	7003      	strb	r3, [r0, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    2050:	7004      	strb	r4, [r0, #0]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    2052:	f89e 1004 	ldrb.w	r1, [lr, #4]

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    2056:	4821      	ldr	r0, [pc, #132]	; (20dc <OctoWS2811::begin()+0x204>)
    2058:	4c21      	ldr	r4, [pc, #132]	; (20e0 <OctoWS2811::begin()+0x208>)
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    205a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    205e:	f501 3104 	add.w	r1, r1, #135168	; 0x21000
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    2062:	25b3      	movs	r5, #179	; 0xb3

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    2064:	700b      	strb	r3, [r1, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    2066:	700d      	strb	r5, [r1, #0]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    2068:	7931      	ldrb	r1, [r6, #4]
    206a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    206e:	f501 3104 	add.w	r1, r1, #135168	; 0x21000
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    2072:	25b1      	movs	r5, #177	; 0xb1

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    2074:	700b      	strb	r3, [r1, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    2076:	700d      	strb	r5, [r1, #0]
    2078:	7931      	ldrb	r1, [r6, #4]
	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    207a:	114b      	asrs	r3, r1, #5
    207c:	009b      	lsls	r3, r3, #2
    207e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2082:	f001 051f 	and.w	r5, r1, #31
    2086:	f503 4361 	add.w	r3, r3, #57600	; 0xe100

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    208a:	3110      	adds	r1, #16
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    208c:	40aa      	lsls	r2, r5

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    208e:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    2092:	601a      	str	r2, [r3, #0]
    2094:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	// set up the buffers
	memset(frameBuffer, 0, bufsize);
	if (drawBuffer) {
		memset(drawBuffer, 0, bufsize);
	} else {
		drawBuffer = frameBuffer;
    2098:	f8d8 2000 	ldr.w	r2, [r8]
    209c:	601a      	str	r2, [r3, #0]
    209e:	e733      	b.n	1f08 <OctoWS2811::begin()+0x30>
    20a0:	1fffb020 	.word	0x1fffb020
    20a4:	1fffb02c 	.word	0x1fffb02c
    20a8:	400ff0c8 	.word	0x400ff0c8
    20ac:	000c3500 	.word	0x000c3500
    20b0:	1fffb034 	.word	0x1fffb034
    20b4:	1fffb014 	.word	0x1fffb014
    20b8:	00061a80 	.word	0x00061a80
    20bc:	4004a000 	.word	0x4004a000
    20c0:	00010300 	.word	0x00010300
    20c4:	4004b000 	.word	0x4004b000
    20c8:	40049034 	.word	0x40049034
    20cc:	00020100 	.word	0x00020100
    20d0:	00020300 	.word	0x00020300
    20d4:	400ff0c4 	.word	0x400ff0c4
    20d8:	400ff0c0 	.word	0x400ff0c0
    20dc:	1fff8200 	.word	0x1fff8200
    20e0:	00001e75 	.word	0x00001e75
    20e4:	1fffb01c 	.word	0x1fffb01c
    20e8:	1fffb024 	.word	0x1fffb024
    20ec:	1fffb03c 	.word	0x1fffb03c
    20f0:	000093b8 	.word	0x000093b8
    20f4:	e008000c 	.word	0xe008000c

000020f8 <OctoWS2811::show()>:
	if (micros() - update_completed_at < 50) return 1;
	return 0;
}

void OctoWS2811::show(void)
{
    20f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20fa:	4c24      	ldr	r4, [pc, #144]	; (218c <OctoWS2811::show()+0x94>)
	uint32_t cv, sc;

	// wait for any prior DMA operation
	while (update_in_progress) ; 
    20fc:	7823      	ldrb	r3, [r4, #0]
    20fe:	2b00      	cmp	r3, #0
    2100:	d1fc      	bne.n	20fc <OctoWS2811::show()+0x4>
	// it's ok to copy the drawing buffer to the frame buffer
	// during the 50us WS2811 reset time
	if (drawBuffer != frameBuffer) {
    2102:	4a23      	ldr	r2, [pc, #140]	; (2190 <OctoWS2811::show()+0x98>)
    2104:	4b23      	ldr	r3, [pc, #140]	; (2194 <OctoWS2811::show()+0x9c>)
    2106:	6811      	ldr	r1, [r2, #0]
    2108:	6818      	ldr	r0, [r3, #0]
    210a:	4281      	cmp	r1, r0
    210c:	d006      	beq.n	211c <OctoWS2811::show()+0x24>
		// TODO: this could be faster with DMA, especially if the
		// buffers are 32 bit aligned... but does it matter?
		memcpy(frameBuffer, drawBuffer, stripLen * 24);
    210e:	4b22      	ldr	r3, [pc, #136]	; (2198 <OctoWS2811::show()+0xa0>)
    2110:	881a      	ldrh	r2, [r3, #0]
    2112:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    2116:	00d2      	lsls	r2, r2, #3
    2118:	f002 fb30 	bl	477c <memcpy>
    211c:	4d1f      	ldr	r5, [pc, #124]	; (219c <OctoWS2811::show()+0xa4>)
	}
	// wait for WS2811 reset
	while (micros() - update_completed_at < 50) ;
    211e:	f002 fe7b 	bl	4e18 <micros>
    2122:	682b      	ldr	r3, [r5, #0]
    2124:	1ac0      	subs	r0, r0, r3
    2126:	2831      	cmp	r0, #49	; 0x31
    2128:	d9f9      	bls.n	211e <OctoWS2811::show()+0x26>

	// ok to start, but we must be very careful to begin
	// without any prior 3 x 800kHz DMA requests pending
	sc = FTM1_SC;
    212a:	4a1d      	ldr	r2, [pc, #116]	; (21a0 <OctoWS2811::show()+0xa8>)
	cv = FTM1_C1V;
    212c:	4b1d      	ldr	r3, [pc, #116]	; (21a4 <OctoWS2811::show()+0xac>)
	// wait for WS2811 reset
	while (micros() - update_completed_at < 50) ;

	// ok to start, but we must be very careful to begin
	// without any prior 3 x 800kHz DMA requests pending
	sc = FTM1_SC;
    212e:	6810      	ldr	r0, [r2, #0]
	cv = FTM1_C1V;
    2130:	681b      	ldr	r3, [r3, #0]
	noInterrupts();
    2132:	b672      	cpsid	i
	// factors, like flash cache misses and bus arbitration from USB
	// or other DMA.  Testing should be done with the oscilloscope
	// display set at infinite persistence and a variety of other I/O
	// performed to create realistic bus usage.  Even then, you really
	// should not mess with this timing critical code!
	update_in_progress = 1;
    2134:	2201      	movs	r2, #1
	while (FTM1_CNT <= cv) ; 
    2136:	491c      	ldr	r1, [pc, #112]	; (21a8 <OctoWS2811::show()+0xb0>)
	// factors, like flash cache misses and bus arbitration from USB
	// or other DMA.  Testing should be done with the oscilloscope
	// display set at infinite persistence and a variety of other I/O
	// performed to create realistic bus usage.  Even then, you really
	// should not mess with this timing critical code!
	update_in_progress = 1;
    2138:	7022      	strb	r2, [r4, #0]
	while (FTM1_CNT <= cv) ; 
    213a:	680a      	ldr	r2, [r1, #0]
    213c:	4293      	cmp	r3, r2
    213e:	d2fc      	bcs.n	213a <OctoWS2811::show()+0x42>
	while (FTM1_CNT > cv) ; // wait for beginning of an 800 kHz cycle
    2140:	4919      	ldr	r1, [pc, #100]	; (21a8 <OctoWS2811::show()+0xb0>)
    2142:	680a      	ldr	r2, [r1, #0]
    2144:	4293      	cmp	r3, r2
    2146:	d3fc      	bcc.n	2142 <OctoWS2811::show()+0x4a>
	while (FTM1_CNT < cv) ;
    2148:	4917      	ldr	r1, [pc, #92]	; (21a8 <OctoWS2811::show()+0xb0>)
    214a:	680a      	ldr	r2, [r1, #0]
    214c:	4293      	cmp	r3, r2
    214e:	d8fc      	bhi.n	214a <OctoWS2811::show()+0x52>
    2150:	4916      	ldr	r1, [pc, #88]	; (21ac <OctoWS2811::show()+0xb4>)
	FTM1_SC = sc & 0xE7;	// stop FTM1 timer (hopefully before it rolls over)
    2152:	4a13      	ldr	r2, [pc, #76]	; (21a0 <OctoWS2811::show()+0xa8>)
    2154:	4c16      	ldr	r4, [pc, #88]	; (21b0 <OctoWS2811::show()+0xb8>)
    2156:	4b17      	ldr	r3, [pc, #92]	; (21b4 <OctoWS2811::show()+0xbc>)
    2158:	790d      	ldrb	r5, [r1, #4]
	//digitalWriteFast(1, HIGH); // oscilloscope trigger
	PORTB_ISFR = (1<<0);    // clear any prior rising edge
    215a:	f8df c064 	ldr.w	ip, [pc, #100]	; 21c0 <OctoWS2811::show()+0xc8>
	PORTC_ISFR = (1<<0);	// clear any prior low duty falling edge
    215e:	f8df e064 	ldr.w	lr, [pc, #100]	; 21c4 <OctoWS2811::show()+0xcc>
    2162:	7926      	ldrb	r6, [r4, #4]
	PORTA_ISFR = (1<<13);	// clear any prior high duty falling edge
    2164:	4f14      	ldr	r7, [pc, #80]	; (21b8 <OctoWS2811::show()+0xc0>)
    2166:	791c      	ldrb	r4, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    2168:	4b14      	ldr	r3, [pc, #80]	; (21bc <OctoWS2811::show()+0xc4>)
	// should not mess with this timing critical code!
	update_in_progress = 1;
	while (FTM1_CNT <= cv) ; 
	while (FTM1_CNT > cv) ; // wait for beginning of an 800 kHz cycle
	while (FTM1_CNT < cv) ;
	FTM1_SC = sc & 0xE7;	// stop FTM1 timer (hopefully before it rolls over)
    216a:	f000 01e7 	and.w	r1, r0, #231	; 0xe7
    216e:	6011      	str	r1, [r2, #0]
	//digitalWriteFast(1, HIGH); // oscilloscope trigger
	PORTB_ISFR = (1<<0);    // clear any prior rising edge
    2170:	2101      	movs	r1, #1
    2172:	f8cc 1000 	str.w	r1, [ip]
	PORTC_ISFR = (1<<0);	// clear any prior low duty falling edge
    2176:	f8ce 1000 	str.w	r1, [lr]
	PORTA_ISFR = (1<<13);	// clear any prior high duty falling edge
    217a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    217e:	6039      	str	r1, [r7, #0]
    2180:	701e      	strb	r6, [r3, #0]
    2182:	701d      	strb	r5, [r3, #0]
    2184:	701c      	strb	r4, [r3, #0]
	dma1.enable();
	dma2.enable();		// enable all 3 DMA channels
	dma3.enable();
	FTM1_SC = sc;		// restart FTM1 timer
    2186:	6010      	str	r0, [r2, #0]
	//digitalWriteFast(1, LOW);
	interrupts();
    2188:	b662      	cpsie	i
    218a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    218c:	1fffb030 	.word	0x1fffb030
    2190:	1fffb02c 	.word	0x1fffb02c
    2194:	1fffb01c 	.word	0x1fffb01c
    2198:	1fffb020 	.word	0x1fffb020
    219c:	1fffb018 	.word	0x1fffb018
    21a0:	40039000 	.word	0x40039000
    21a4:	40039018 	.word	0x40039018
    21a8:	40039004 	.word	0x40039004
    21ac:	1fffb03c 	.word	0x1fffb03c
    21b0:	1fffb024 	.word	0x1fffb024
    21b4:	1fffb034 	.word	0x1fffb034
    21b8:	400490a0 	.word	0x400490a0
    21bc:	4000801b 	.word	0x4000801b
    21c0:	4004a0a0 	.word	0x4004a0a0
    21c4:	4004b0a0 	.word	0x4004b0a0

000021c8 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE>:
		break;
	  default:
		break;
	}
	return color;
}
    21c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
    21cc:	f8df 8054 	ldr.w	r8, [pc, #84]	; 2224 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x5c>

uint16_t OctoWS2811::stripLen;
void * OctoWS2811::frameBuffer;
void * OctoWS2811::drawBuffer;
uint8_t OctoWS2811::params;
DMAChannel OctoWS2811::dma1;
    21d0:	4d10      	ldr	r5, [pc, #64]	; (2214 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x4c>)
    21d2:	4c11      	ldr	r4, [pc, #68]	; (2218 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x50>)
    21d4:	4f11      	ldr	r7, [pc, #68]	; (221c <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x54>)
    21d6:	4e12      	ldr	r6, [pc, #72]	; (2220 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x58>)
    21d8:	4640      	mov	r0, r8
    21da:	2100      	movs	r1, #0
    21dc:	f004 faa0 	bl	6720 <DMAChannel::begin(bool)>
    21e0:	462a      	mov	r2, r5
    21e2:	4621      	mov	r1, r4
    21e4:	4640      	mov	r0, r8
    21e6:	f004 ffd5 	bl	7194 <__aeabi_atexit>
    21ea:	4638      	mov	r0, r7
    21ec:	2100      	movs	r1, #0
    21ee:	f004 fa97 	bl	6720 <DMAChannel::begin(bool)>
DMAChannel OctoWS2811::dma2;
    21f2:	462a      	mov	r2, r5
    21f4:	4621      	mov	r1, r4
    21f6:	4638      	mov	r0, r7
    21f8:	f004 ffcc 	bl	7194 <__aeabi_atexit>
    21fc:	4630      	mov	r0, r6
    21fe:	2100      	movs	r1, #0
    2200:	f004 fa8e 	bl	6720 <DMAChannel::begin(bool)>
DMAChannel OctoWS2811::dma3;
    2204:	462a      	mov	r2, r5
    2206:	4621      	mov	r1, r4
    2208:	4630      	mov	r0, r6
		break;
	  default:
		break;
	}
	return color;
}
    220a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
void * OctoWS2811::frameBuffer;
void * OctoWS2811::drawBuffer;
uint8_t OctoWS2811::params;
DMAChannel OctoWS2811::dma1;
DMAChannel OctoWS2811::dma2;
DMAChannel OctoWS2811::dma3;
    220e:	f004 bfc1 	b.w	7194 <__aeabi_atexit>
    2212:	bf00      	nop
    2214:	1fff8720 	.word	0x1fff8720
    2218:	00001ea1 	.word	0x00001ea1
    221c:	1fffb03c 	.word	0x1fffb03c
    2220:	1fffb034 	.word	0x1fffb034
    2224:	1fffb024 	.word	0x1fffb024

00002228 <nblend(CRGB&, CRGB const&, unsigned char)>:
}


CRGB& nblend( CRGB& existing, const CRGB& overlay, fract8 amountOfOverlay )
{
    if( amountOfOverlay == 0) {
    2228:	b322      	cbz	r2, 2274 <nblend(CRGB&, CRGB const&, unsigned char)+0x4c>
        return existing;
    }

    if( amountOfOverlay == 255) {
    222a:	2aff      	cmp	r2, #255	; 0xff
    222c:	d023      	beq.n	2276 <nblend(CRGB&, CRGB const&, unsigned char)+0x4e>
    }
}


CRGB& nblend( CRGB& existing, const CRGB& overlay, fract8 amountOfOverlay )
{
    222e:	b4f0      	push	{r4, r5, r6, r7}
    uint16_t partial;
    uint8_t result;
    
    uint8_t amountOfA = 255 - amountOfB;
    
    partial = (a * amountOfA);
    2230:	7804      	ldrb	r4, [r0, #0]
#if (FASTLED_SCALE8_FIXED == 1)
    partial += a;
    //partial = add8to16( a, partial);
#endif
    
    partial += (b * amountOfB);
    2232:	780e      	ldrb	r6, [r1, #0]
    uint16_t partial;
    uint8_t result;
    
    uint8_t amountOfA = 255 - amountOfB;
    
    partial = (a * amountOfA);
    2234:	7843      	ldrb	r3, [r0, #1]
#if (FASTLED_SCALE8_FIXED == 1)
    partial += a;
    //partial = add8to16( a, partial);
#endif
    
    partial += (b * amountOfB);
    2236:	b295      	uxth	r5, r2
                    + scale8_LEAVING_R1_DIRTY( overlay.blue,   amountOfOverlay);

    cleanup_R1();
#else
    // Corrected blend method, with no loss-of-precision rounding errors
    existing.red   = blend8( existing.red,   overlay.red,   amountOfOverlay);
    2238:	19a7      	adds	r7, r4, r6
    uint16_t partial;
    uint8_t result;
    
    uint8_t amountOfA = 255 - amountOfB;
    
    partial = (a * amountOfA);
    223a:	43d2      	mvns	r2, r2
    223c:	fb06 7605 	mla	r6, r6, r5, r7
    2240:	b2d2      	uxtb	r2, r2
    2242:	fb04 6402 	mla	r4, r4, r2, r6
    2246:	f3c4 2407 	ubfx	r4, r4, #8, #8
    224a:	7004      	strb	r4, [r0, #0]
#if (FASTLED_SCALE8_FIXED == 1)
    partial += a;
    //partial = add8to16( a, partial);
#endif
    
    partial += (b * amountOfB);
    224c:	784c      	ldrb	r4, [r1, #1]
    uint16_t partial;
    uint8_t result;
    
    uint8_t amountOfA = 255 - amountOfB;
    
    partial = (a * amountOfA);
    224e:	7886      	ldrb	r6, [r0, #2]
    existing.green = blend8( existing.green, overlay.green, amountOfOverlay);
    2250:	191f      	adds	r7, r3, r4
    2252:	fb04 7405 	mla	r4, r4, r5, r7
    2256:	fb03 4302 	mla	r3, r3, r2, r4
    225a:	f3c3 2307 	ubfx	r3, r3, #8, #8
    225e:	7043      	strb	r3, [r0, #1]
#if (FASTLED_SCALE8_FIXED == 1)
    partial += a;
    //partial = add8to16( a, partial);
#endif
    
    partial += (b * amountOfB);
    2260:	788b      	ldrb	r3, [r1, #2]
    existing.blue  = blend8( existing.blue,  overlay.blue,  amountOfOverlay);
    2262:	18f1      	adds	r1, r6, r3
    2264:	fb03 1505 	mla	r5, r3, r5, r1
    2268:	fb06 5202 	mla	r2, r6, r2, r5
#endif
    
    return existing;
}
    226c:	bcf0      	pop	{r4, r5, r6, r7}
    cleanup_R1();
#else
    // Corrected blend method, with no loss-of-precision rounding errors
    existing.red   = blend8( existing.red,   overlay.red,   amountOfOverlay);
    existing.green = blend8( existing.green, overlay.green, amountOfOverlay);
    existing.blue  = blend8( existing.blue,  overlay.blue,  amountOfOverlay);
    226e:	f3c2 2207 	ubfx	r2, r2, #8, #8
    2272:	7082      	strb	r2, [r0, #2]
#endif
    
    return existing;
}
    2274:	4770      	bx	lr
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2276:	780b      	ldrb	r3, [r1, #0]
    2278:	7003      	strb	r3, [r0, #0]
        g = rhs.g;
    227a:	784b      	ldrb	r3, [r1, #1]
    227c:	7043      	strb	r3, [r0, #1]
        b = rhs.b;
    227e:	788b      	ldrb	r3, [r1, #2]
    2280:	7083      	strb	r3, [r0, #2]
    2282:	4770      	bx	lr

00002284 <blend(CRGB const&, CRGB const&, unsigned char)>:
        overlay++;
    }
}

CRGB blend( const CRGB& p1, const CRGB& p2, fract8 amountOfP2 )
{
    2284:	b538      	push	{r3, r4, r5, lr}
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2286:	780d      	ldrb	r5, [r1, #0]
    2288:	7005      	strb	r5, [r0, #0]
        g = rhs.g;
    228a:	784d      	ldrb	r5, [r1, #1]
    228c:	7045      	strb	r5, [r0, #1]
        b = rhs.b;
    228e:	7889      	ldrb	r1, [r1, #2]
    2290:	7081      	strb	r1, [r0, #2]
    2292:	4604      	mov	r4, r0
    CRGB nu(p1);
    nblend( nu, p2, amountOfP2);
    2294:	4611      	mov	r1, r2
    2296:	461a      	mov	r2, r3
    2298:	f7ff ffc6 	bl	2228 <nblend(CRGB&, CRGB const&, unsigned char)>
    return nu;
}
    229c:	4620      	mov	r0, r4
    229e:	bd38      	pop	{r3, r4, r5, pc}

000022a0 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)>:
    return dividend;
}


CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
    22a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    dividend /= 2;
    dividend /= 2;
    dividend /= 2;
    dividend /= 2;
#else
    dividend >>= 4;
    22a4:	1114      	asrs	r4, r2, #4
    // since hi4 is always 0..15, hi4 * sizeof(CRGB) can be a single-byte value,
    // instead of the two byte 'int' that avr-gcc defaults to.
    // So, we multiply hi4 X sizeof(CRGB), giving hi4XsizeofCRGB;
    uint8_t hi4XsizeofCRGB = hi4 * sizeof(CRGB);
    // We then add that to a base array pointer.
    const CRGB* entry = (CRGB*)( (uint8_t*)(&(pal[0])) + hi4XsizeofCRGB);
    22a6:	eb04 0544 	add.w	r5, r4, r4, lsl #1
    
    uint8_t blend = lo4 && (blendType != NOBLEND);
    22aa:	f012 020f 	ands.w	r2, r2, #15
    // since hi4 is always 0..15, hi4 * sizeof(CRGB) can be a single-byte value,
    // instead of the two byte 'int' that avr-gcc defaults to.
    // So, we multiply hi4 X sizeof(CRGB), giving hi4XsizeofCRGB;
    uint8_t hi4XsizeofCRGB = hi4 * sizeof(CRGB);
    // We then add that to a base array pointer.
    const CRGB* entry = (CRGB*)( (uint8_t*)(&(pal[0])) + hi4XsizeofCRGB);
    22ae:	440d      	add	r5, r1
    return dividend;
}


CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
    22b0:	f89d 601c 	ldrb.w	r6, [sp, #28]
    // So, we multiply hi4 X sizeof(CRGB), giving hi4XsizeofCRGB;
    uint8_t hi4XsizeofCRGB = hi4 * sizeof(CRGB);
    // We then add that to a base array pointer.
    const CRGB* entry = (CRGB*)( (uint8_t*)(&(pal[0])) + hi4XsizeofCRGB);
    
    uint8_t blend = lo4 && (blendType != NOBLEND);
    22b4:	d000      	beq.n	22b8 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x18>
    22b6:	b9e6      	cbnz	r6, 22f2 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x52>
    
    uint8_t red1   = entry->red;
    22b8:	782c      	ldrb	r4, [r5, #0]
    uint8_t green1 = entry->green;
    22ba:	7869      	ldrb	r1, [r5, #1]
    uint8_t blue1  = entry->blue;
    22bc:	78aa      	ldrb	r2, [r5, #2]
        blue1  += blue2;
        
        cleanup_R1();
    }
    
    if( brightness != 255) {
    22be:	2bff      	cmp	r3, #255	; 0xff
    22c0:	d012      	beq.n	22e8 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x48>
        if( brightness ) {
    22c2:	2b00      	cmp	r3, #0
    22c4:	d043      	beq.n	234e <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0xae>
            brightness++; // adjust for rounding
    22c6:	3301      	adds	r3, #1
    22c8:	b2db      	uxtb	r3, r3
            // Now, since brightness is nonzero, we don't need the full scale8_video logic;
            // we can just to scale8 and then add one (unless scale8 fixed) to all nonzero inputs.
            if( red1 )   {
    22ca:	b11c      	cbz	r4, 22d4 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x34>
/// then explicitly call cleanup_R1.
LIB8STATIC_ALWAYS_INLINE uint8_t scale8_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * ((uint16_t)(scale)+1)) >> 8;
    22cc:	fb03 4404 	mla	r4, r3, r4, r4
    22d0:	f3c4 2407 	ubfx	r4, r4, #8, #8
                red1 = scale8_LEAVING_R1_DIRTY( red1, brightness);
#if !(FASTLED_SCALE8_FIXED==1)
                red1++;
#endif
            }
            if( green1 ) {
    22d4:	b119      	cbz	r1, 22de <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x3e>
    22d6:	fb03 1101 	mla	r1, r3, r1, r1
    22da:	f3c1 2107 	ubfx	r1, r1, #8, #8
                green1 = scale8_LEAVING_R1_DIRTY( green1, brightness);
#if !(FASTLED_SCALE8_FIXED==1)
                green1++;
#endif
            }
            if( blue1 )  {
    22de:	b11a      	cbz	r2, 22e8 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x48>
    22e0:	fb03 2202 	mla	r2, r3, r2, r2
    22e4:	f3c2 2207 	ubfx	r2, r2, #8, #8
    {
    }

    /// allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
    22e8:	7004      	strb	r4, [r0, #0]
    22ea:	7041      	strb	r1, [r0, #1]
    22ec:	7082      	strb	r2, [r0, #2]
            blue1 = 0;
        }
    }
    
    return CRGB( red1, green1, blue1);
}
    22ee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    uint8_t blue1  = entry->blue;
    
    
    if( blend ) {
        
        if( hi4 == 15 ) {
    22f2:	2c0f      	cmp	r4, #15
    // We then add that to a base array pointer.
    const CRGB* entry = (CRGB*)( (uint8_t*)(&(pal[0])) + hi4XsizeofCRGB);
    
    uint8_t blend = lo4 && (blendType != NOBLEND);
    
    uint8_t red1   = entry->red;
    22f4:	782e      	ldrb	r6, [r5, #0]
    uint8_t green1 = entry->green;
    22f6:	f895 9001 	ldrb.w	r9, [r5, #1]
    uint8_t blue1  = entry->blue;
    22fa:	78af      	ldrb	r7, [r5, #2]
    
    
    if( blend ) {
        
        if( hi4 == 15 ) {
    22fc:	d000      	beq.n	2300 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x60>
            entry = &(pal[0]);
        } else {
            entry++;
    22fe:	1ce9      	adds	r1, r5, #3
        }
        
        uint8_t f2 = lo4 << 4;
    2300:	0112      	lsls	r2, r2, #4
    2302:	f082 05ff 	eor.w	r5, r2, #255	; 0xff
    2306:	1c6c      	adds	r4, r5, #1
        
        //    rgb1.nscale8(f1);
        uint8_t red2   = entry->red;
        red1   = scale8_LEAVING_R1_DIRTY( red1,   f1);
        red2   = scale8_LEAVING_R1_DIRTY( red2,   f2);
        red1   += red2;
    2308:	f891 c000 	ldrb.w	ip, [r1]

        uint8_t green2 = entry->green;
        green1 = scale8_LEAVING_R1_DIRTY( green1, f1);
        green2 = scale8_LEAVING_R1_DIRTY( green2, f2);
        green1 += green2;
    230c:	f891 e001 	ldrb.w	lr, [r1, #1]

        uint8_t blue2  = entry->blue;
        blue1  = scale8_LEAVING_R1_DIRTY( blue1,  f1);
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);
        blue1  += blue2;
    2310:	f891 8002 	ldrb.w	r8, [r1, #2]
    2314:	fb04 f606 	mul.w	r6, r4, r6
    2318:	1c51      	adds	r1, r2, #1
    231a:	fb04 f509 	mul.w	r5, r4, r9
    231e:	fb04 f407 	mul.w	r4, r4, r7
    2322:	f3c4 2407 	ubfx	r4, r4, #8, #8
    2326:	f3c6 2707 	ubfx	r7, r6, #8, #8
    232a:	fb01 f208 	mul.w	r2, r1, r8
        
        //    rgb1.nscale8(f1);
        uint8_t red2   = entry->red;
        red1   = scale8_LEAVING_R1_DIRTY( red1,   f1);
        red2   = scale8_LEAVING_R1_DIRTY( red2,   f2);
        red1   += red2;
    232e:	fb01 f60c 	mul.w	r6, r1, ip
    2332:	f3c5 2507 	ubfx	r5, r5, #8, #8

        uint8_t green2 = entry->green;
        green1 = scale8_LEAVING_R1_DIRTY( green1, f1);
        green2 = scale8_LEAVING_R1_DIRTY( green2, f2);
        green1 += green2;
    2336:	fb01 fe0e 	mul.w	lr, r1, lr

        uint8_t blue2  = entry->blue;
        blue1  = scale8_LEAVING_R1_DIRTY( blue1,  f1);
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);
        blue1  += blue2;
    233a:	eb04 2222 	add.w	r2, r4, r2, asr #8
        
        //    rgb1.nscale8(f1);
        uint8_t red2   = entry->red;
        red1   = scale8_LEAVING_R1_DIRTY( red1,   f1);
        red2   = scale8_LEAVING_R1_DIRTY( red2,   f2);
        red1   += red2;
    233e:	eb07 2626 	add.w	r6, r7, r6, asr #8

        uint8_t green2 = entry->green;
        green1 = scale8_LEAVING_R1_DIRTY( green1, f1);
        green2 = scale8_LEAVING_R1_DIRTY( green2, f2);
        green1 += green2;
    2342:	eb05 212e 	add.w	r1, r5, lr, asr #8
        
        //    rgb1.nscale8(f1);
        uint8_t red2   = entry->red;
        red1   = scale8_LEAVING_R1_DIRTY( red1,   f1);
        red2   = scale8_LEAVING_R1_DIRTY( red2,   f2);
        red1   += red2;
    2346:	b2f4      	uxtb	r4, r6

        uint8_t green2 = entry->green;
        green1 = scale8_LEAVING_R1_DIRTY( green1, f1);
        green2 = scale8_LEAVING_R1_DIRTY( green2, f2);
        green1 += green2;
    2348:	b2c9      	uxtb	r1, r1

        uint8_t blue2  = entry->blue;
        blue1  = scale8_LEAVING_R1_DIRTY( blue1,  f1);
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);
        blue1  += blue2;
    234a:	b2d2      	uxtb	r2, r2
    234c:	e7b7      	b.n	22be <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)+0x1e>
            }
            cleanup_R1();
        } else {
            red1 = 0;
            green1 = 0;
            blue1 = 0;
    234e:	461a      	mov	r2, r3
#endif
            }
            cleanup_R1();
        } else {
            red1 = 0;
            green1 = 0;
    2350:	4619      	mov	r1, r3
                blue1++;
#endif
            }
            cleanup_R1();
        } else {
            red1 = 0;
    2352:	461c      	mov	r4, r3
    2354:	7004      	strb	r4, [r0, #0]
    2356:	7041      	strb	r1, [r0, #1]
    2358:	7082      	strb	r2, [r0, #2]
            blue1 = 0;
        }
    }
    
    return CRGB( red1, green1, blue1);
}
    235a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    235e:	bf00      	nop

00002360 <CFastLED::addLeds(CLEDController*, CRGB*, int, int)>:
	m_nPowerData = 0xFFFFFFFF;
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
    2360:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
    2362:	1e1e      	subs	r6, r3, #0
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;

	pLed->init();
    2364:	6803      	ldr	r3, [r0, #0]
	m_nPowerData = 0xFFFFFFFF;
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
    2366:	4604      	mov	r4, r0
    2368:	bfcc      	ite	gt
    236a:	eb02 0542 	addgt.w	r5, r2, r2, lsl #1
    236e:	2500      	movle	r5, #0
    2370:	460f      	mov	r7, r1
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;

	pLed->init();
    2372:	689b      	ldr	r3, [r3, #8]

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;
    2374:	bfd8      	it	le
    2376:	4616      	movle	r6, r2

	pLed->init();
    2378:	4798      	blx	r3
    /// get the next controller in the chain after this one.  will return NULL at the end of the chain
    CLEDController *next() { return m_pNext; }

	/// set the default array of leds to be used by this controller
    CLEDController & setLeds(CRGB *data, int nLeds) {
        m_Data = data;
    237a:	197a      	adds	r2, r7, r5
	pLed->setLeds(data + nOffset, nLeds);
	FastLED.setMaxRefreshRate(pLed->getMaxRefreshRate(),true);
    237c:	6823      	ldr	r3, [r4, #0]
    237e:	6062      	str	r2, [r4, #4]
    2380:	695b      	ldr	r3, [r3, #20]
    2382:	4a0a      	ldr	r2, [pc, #40]	; (23ac <CFastLED::addLeds(CLEDController*, CRGB*, int, int)+0x4c>)
        m_nLeds = nLeds;
    2384:	6166      	str	r6, [r4, #20]
    2386:	4293      	cmp	r3, r2
    2388:	d101      	bne.n	238e <CFastLED::addLeds(CLEDController*, CRGB*, int, int)+0x2e>
	return *pLed;
}
    238a:	4620      	mov	r0, r4
    238c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;

	pLed->init();
	pLed->setLeds(data + nOffset, nLeds);
	FastLED.setMaxRefreshRate(pLed->getMaxRefreshRate(),true);
    238e:	4620      	mov	r0, r4
    2390:	4798      	blx	r3

void CFastLED::setMaxRefreshRate(uint16_t refresh, bool constrain) {
  if(constrain) {
    // if we're constraining, the new value of m_nMinMicros _must_ be higher than previously (because we're only
    // allowed to slow things down if constraining)
    if(refresh > 0) {
    2392:	2800      	cmp	r0, #0
    2394:	d0f9      	beq.n	238a <CFastLED::addLeds(CLEDController*, CRGB*, int, int)+0x2a>
      m_nMinMicros = ( (1000000/refresh) >  m_nMinMicros) ? (1000000/refresh) : m_nMinMicros;
    2396:	4a06      	ldr	r2, [pc, #24]	; (23b0 <CFastLED::addLeds(CLEDController*, CRGB*, int, int)+0x50>)
    2398:	4b06      	ldr	r3, [pc, #24]	; (23b4 <CFastLED::addLeds(CLEDController*, CRGB*, int, int)+0x54>)
    239a:	6851      	ldr	r1, [r2, #4]
    239c:	fb93 f0f0 	sdiv	r0, r3, r0
    23a0:	4288      	cmp	r0, r1
    23a2:	bf38      	it	cc
    23a4:	4608      	movcc	r0, r1
    23a6:	6050      	str	r0, [r2, #4]

	pLed->init();
	pLed->setLeds(data + nOffset, nLeds);
	FastLED.setMaxRefreshRate(pLed->getMaxRefreshRate(),true);
	return *pLed;
}
    23a8:	4620      	mov	r0, r4
    23aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    23ac:	0000046d 	.word	0x0000046d
    23b0:	1fffb044 	.word	0x1fffb044
    23b4:	000f4240 	.word	0x000f4240

000023b8 <CFastLED::countFPS(int)>:
// }

extern int noise_min;
extern int noise_max;

void CFastLED::countFPS(int nFrames) {
    23b8:	b470      	push	{r4, r5, r6}
  static int br = 0;
  static uint32_t lastframe = 0; // millis();

  if(br++ >= nFrames) {
    23ba:	4c0f      	ldr	r4, [pc, #60]	; (23f8 <CFastLED::countFPS(int)+0x40>)
    23bc:	6822      	ldr	r2, [r4, #0]
    23be:	1c53      	adds	r3, r2, #1
    23c0:	428a      	cmp	r2, r1
// }

extern int noise_min;
extern int noise_max;

void CFastLED::countFPS(int nFrames) {
    23c2:	b083      	sub	sp, #12
  static int br = 0;
  static uint32_t lastframe = 0; // millis();

  if(br++ >= nFrames) {
    23c4:	6023      	str	r3, [r4, #0]
    23c6:	db13      	blt.n	23f0 <CFastLED::countFPS(int)+0x38>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    23c8:	4d0c      	ldr	r5, [pc, #48]	; (23fc <CFastLED::countFPS(int)+0x44>)
		uint32_t now = millis();
		now -= lastframe;
    23ca:	4a0d      	ldr	r2, [pc, #52]	; (2400 <CFastLED::countFPS(int)+0x48>)
    23cc:	6829      	ldr	r1, [r5, #0]
    23ce:	9101      	str	r1, [sp, #4]
	return ret;
    23d0:	9901      	ldr	r1, [sp, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    23d2:	682d      	ldr	r5, [r5, #0]
    23d4:	9500      	str	r5, [sp, #0]
		m_nFPS = (br * 1000) / now;
    23d6:	6816      	ldr	r6, [r2, #0]
	return ret;
    23d8:	9d00      	ldr	r5, [sp, #0]
    br = 0;
    lastframe = millis();
    23da:	6015      	str	r5, [r2, #0]
  static uint32_t lastframe = 0; // millis();

  if(br++ >= nFrames) {
		uint32_t now = millis();
		now -= lastframe;
		m_nFPS = (br * 1000) / now;
    23dc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    br = 0;
    23e0:	2500      	movs	r5, #0
  static uint32_t lastframe = 0; // millis();

  if(br++ >= nFrames) {
		uint32_t now = millis();
		now -= lastframe;
		m_nFPS = (br * 1000) / now;
    23e2:	1b89      	subs	r1, r1, r6
    23e4:	fb02 f303 	mul.w	r3, r2, r3
    br = 0;
    23e8:	6025      	str	r5, [r4, #0]
  static uint32_t lastframe = 0; // millis();

  if(br++ >= nFrames) {
		uint32_t now = millis();
		now -= lastframe;
		m_nFPS = (br * 1000) / now;
    23ea:	fbb3 f3f1 	udiv	r3, r3, r1
    23ee:	8043      	strh	r3, [r0, #2]
    br = 0;
    lastframe = millis();
  }
}
    23f0:	b003      	add	sp, #12
    23f2:	bc70      	pop	{r4, r5, r6}
    23f4:	4770      	bx	lr
    23f6:	bf00      	nop
    23f8:	1fffb058 	.word	0x1fffb058
    23fc:	1fffb440 	.word	0x1fffb440
    2400:	1fffb060 	.word	0x1fffb060

00002404 <CFastLED::show(unsigned char)>:
	pLed->setLeds(data + nOffset, nLeds);
	FastLED.setMaxRefreshRate(pLed->getMaxRefreshRate(),true);
	return *pLed;
}

void CFastLED::show(uint8_t scale) {
    2404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2408:	6843      	ldr	r3, [r0, #4]
    240a:	4c2d      	ldr	r4, [pc, #180]	; (24c0 <CFastLED::show(unsigned char)+0xbc>)
    240c:	b083      	sub	sp, #12
    240e:	4606      	mov	r6, r0
    2410:	4689      	mov	r9, r1
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
    2412:	2b00      	cmp	r3, #0
    2414:	d14b      	bne.n	24ae <CFastLED::show(unsigned char)+0xaa>
	lastshow = micros();
    2416:	f002 fcff 	bl	4e18 <micros>

	// If we have a function for computing power, use it!
	if(m_pPowerFunc) {
    241a:	68f3      	ldr	r3, [r6, #12]
}

void CFastLED::show(uint8_t scale) {
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
	lastshow = micros();
    241c:	6020      	str	r0, [r4, #0]

	// If we have a function for computing power, use it!
	if(m_pPowerFunc) {
    241e:	b11b      	cbz	r3, 2428 <CFastLED::show(unsigned char)+0x24>
		scale = (*m_pPowerFunc)(scale, m_nPowerData);
    2420:	4648      	mov	r0, r9
    2422:	68b1      	ldr	r1, [r6, #8]
    2424:	4798      	blx	r3
    2426:	4681      	mov	r9, r0
    void showColor(const struct CRGB & data, uint8_t brightness=255) {
        showColor(data, m_nLeds, getAdjustment(brightness));
    }

    /// get the first led controller in the chain of controllers
    static CLEDController *head() { return m_pHead; }
    2428:	4b26      	ldr	r3, [pc, #152]	; (24c4 <CFastLED::show(unsigned char)+0xc0>)
    242a:	681c      	ldr	r4, [r3, #0]

    /// Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

	/// set the dithering mode for this controller to use
    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
    242c:	2500      	movs	r5, #0
	}

	CLEDController *pCur = CLEDController::head();
	while(pCur) {
    242e:	2c00      	cmp	r4, #0
    2430:	d036      	beq.n	24a0 <CFastLED::show(unsigned char)+0x9c>
		uint8_t d = pCur->getDither();
		if(m_nFPS < 100) { pCur->setDither(0); }
    2432:	8873      	ldrh	r3, [r6, #2]
    2434:	7ca7      	ldrb	r7, [r4, #18]
        showColor(data, nLeds, getAdjustment(brightness));
    }

    /// show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
    2436:	6861      	ldr	r1, [r4, #4]
    2438:	6962      	ldr	r2, [r4, #20]
    243a:	2b63      	cmp	r3, #99	; 0x63
    243c:	6823      	ldr	r3, [r4, #0]

    /// Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

	/// set the dithering mode for this controller to use
    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
    243e:	bf98      	it	ls
    2440:	74a5      	strbls	r5, [r4, #18]
        showColor(data, nLeds, getAdjustment(brightness));
    }

    /// show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
    2442:	f8d3 8004 	ldr.w	r8, [r3, #4]
    2446:	f88d 5004 	strb.w	r5, [sp, #4]
    244a:	f88d 5005 	strb.w	r5, [sp, #5]
    244e:	f88d 5006 	strb.w	r5, [sp, #6]
      #if defined(NO_CORRECTION) && (NO_CORRECTION==1)
              return CRGB(scale,scale,scale);
      #else
              CRGB adj(0,0,0);

              if(scale > 0) {
    2452:	f1b9 0f00 	cmp.w	r9, #0
    2456:	d01c      	beq.n	2492 <CFastLED::show(unsigned char)+0x8e>
    2458:	f104 030b 	add.w	r3, r4, #11
    245c:	f10d 0e04 	add.w	lr, sp, #4
    2460:	f104 0c0e 	add.w	ip, r4, #14
                  for(uint8_t i = 0; i < 3; i++) {
                      uint8_t cc = colorCorrection.raw[i];
    2464:	f813 bf01 	ldrb.w	fp, [r3, #1]!
                      uint8_t ct = colorTemperature.raw[i];
                      if(cc > 0 && ct > 0) {
    2468:	f1bb 0f00 	cmp.w	fp, #0
    246c:	d00d      	beq.n	248a <CFastLED::show(unsigned char)+0x86>
              CRGB adj(0,0,0);

              if(scale > 0) {
                  for(uint8_t i = 0; i < 3; i++) {
                      uint8_t cc = colorCorrection.raw[i];
                      uint8_t ct = colorTemperature.raw[i];
    246e:	f893 a003 	ldrb.w	sl, [r3, #3]
                      if(cc > 0 && ct > 0) {
                          uint32_t work = (((uint32_t)cc)+1) * (((uint32_t)ct)+1) * scale;
    2472:	f10a 0001 	add.w	r0, sl, #1
    2476:	fb0b 0000 	mla	r0, fp, r0, r0

              if(scale > 0) {
                  for(uint8_t i = 0; i < 3; i++) {
                      uint8_t cc = colorCorrection.raw[i];
                      uint8_t ct = colorTemperature.raw[i];
                      if(cc > 0 && ct > 0) {
    247a:	f1ba 0f00 	cmp.w	sl, #0
    247e:	d004      	beq.n	248a <CFastLED::show(unsigned char)+0x86>
                          uint32_t work = (((uint32_t)cc)+1) * (((uint32_t)ct)+1) * scale;
    2480:	fb09 f000 	mul.w	r0, r9, r0
                          work /= 0x10000L;
                          adj.raw[i] = work & 0xFF;
    2484:	0c00      	lsrs	r0, r0, #16
    2486:	f88e 0000 	strb.w	r0, [lr]
              return CRGB(scale,scale,scale);
      #else
              CRGB adj(0,0,0);

              if(scale > 0) {
                  for(uint8_t i = 0; i < 3; i++) {
    248a:	4563      	cmp	r3, ip
    248c:	f10e 0e01 	add.w	lr, lr, #1
    2490:	d1e8      	bne.n	2464 <CFastLED::show(unsigned char)+0x60>
        showColor(data, nLeds, getAdjustment(brightness));
    }

    /// show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
    2492:	4620      	mov	r0, r4
    2494:	ab01      	add	r3, sp, #4
    2496:	47c0      	blx	r8

    /// Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

	/// set the dithering mode for this controller to use
    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
    2498:	74a7      	strb	r7, [r4, #18]
    249a:	68a4      	ldr	r4, [r4, #8]
	if(m_pPowerFunc) {
		scale = (*m_pPowerFunc)(scale, m_nPowerData);
	}

	CLEDController *pCur = CLEDController::head();
	while(pCur) {
    249c:	2c00      	cmp	r4, #0
    249e:	d1c8      	bne.n	2432 <CFastLED::show(unsigned char)+0x2e>
		if(m_nFPS < 100) { pCur->setDither(0); }
		pCur->showLeds(scale);
		pCur->setDither(d);
		pCur = pCur->next();
	}
	countFPS();
    24a0:	4630      	mov	r0, r6
    24a2:	2119      	movs	r1, #25
    24a4:	f7ff ff88 	bl	23b8 <CFastLED::countFPS(int)>
}
    24a8:	b003      	add	sp, #12
    24aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return *pLed;
}

void CFastLED::show(uint8_t scale) {
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
    24ae:	f002 fcb3 	bl	4e18 <micros>
    24b2:	6822      	ldr	r2, [r4, #0]
    24b4:	6873      	ldr	r3, [r6, #4]
    24b6:	1a80      	subs	r0, r0, r2
    24b8:	4298      	cmp	r0, r3
    24ba:	d3aa      	bcc.n	2412 <CFastLED::show(unsigned char)+0xe>
    24bc:	e7ab      	b.n	2416 <CFastLED::show(unsigned char)+0x12>
    24be:	bf00      	nop
    24c0:	1fffb05c 	.word	0x1fffb05c
    24c4:	1fffb054 	.word	0x1fffb054

000024c8 <atexit>:
  } else {
    m_nMinMicros = 0;
  }
}

extern "C" int atexit(void (* /*func*/ )()) { return 0; }
    24c8:	2000      	movs	r0, #0
    24ca:	4770      	bx	lr

000024cc <_GLOBAL__sub_I_pSmartMatrix>:
// uint32_t CRGB::Squant = ((uint32_t)((__TIME__[4]-'0') * 28))<<16 | ((__TIME__[6]-'0')*50)<<8 | ((__TIME__[7]-'0')*28);

CFastLED::CFastLED() {
	// clear out the array of led controllers
	// m_nControllers = 0;
	m_Scale = 255;
    24cc:	4b04      	ldr	r3, [pc, #16]	; (24e0 <_GLOBAL__sub_I_pSmartMatrix+0x14>)
	m_nFPS = 0;
    24ce:	2200      	movs	r2, #0
// uint32_t CRGB::Squant = ((uint32_t)((__TIME__[4]-'0') * 28))<<16 | ((__TIME__[6]-'0')*50)<<8 | ((__TIME__[7]-'0')*28);

CFastLED::CFastLED() {
	// clear out the array of led controllers
	// m_nControllers = 0;
	m_Scale = 255;
    24d0:	20ff      	movs	r0, #255	; 0xff
	m_nFPS = 0;
	m_pPowerFunc = NULL;
	m_nPowerData = 0xFFFFFFFF;
    24d2:	f04f 31ff 	mov.w	r1, #4294967295
// uint32_t CRGB::Squant = ((uint32_t)((__TIME__[4]-'0') * 28))<<16 | ((__TIME__[6]-'0')*50)<<8 | ((__TIME__[7]-'0')*28);

CFastLED::CFastLED() {
	// clear out the array of led controllers
	// m_nControllers = 0;
	m_Scale = 255;
    24d6:	7018      	strb	r0, [r3, #0]
	m_nFPS = 0;
	m_pPowerFunc = NULL;
	m_nPowerData = 0xFFFFFFFF;
    24d8:	6099      	str	r1, [r3, #8]

CFastLED::CFastLED() {
	// clear out the array of led controllers
	// m_nControllers = 0;
	m_Scale = 255;
	m_nFPS = 0;
    24da:	805a      	strh	r2, [r3, #2]
	m_pPowerFunc = NULL;
    24dc:	60da      	str	r2, [r3, #12]
    24de:	4770      	bx	lr
    24e0:	1fffb044 	.word	0x1fffb044

000024e4 <hsv2rgb_rainbow(CHSV const&, CRGB&)>:
#define K171 171
#define K170 170
#define K85  85

void hsv2rgb_rainbow( const CHSV& hsv, CRGB& rgb)
{
    24e4:	b4f0      	push	{r4, r5, r6, r7}
    // Gscale: what to scale green down by.
    // Depends GREATLY on your particular LEDs
    const uint8_t Gscale = 0;
    
    
    uint8_t hue = hsv.hue;
    24e6:	7804      	ldrb	r4, [r0, #0]
    uint8_t sat = hsv.sat;
    24e8:	7846      	ldrb	r6, [r0, #1]
    uint8_t val = hsv.val;
    24ea:	7882      	ldrb	r2, [r0, #2]
    24ec:	00e0      	lsls	r0, r4, #3
///  4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC_ALWAYS_INLINE uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * (1+(uint16_t)(scale))) >> 8;
    24ee:	f000 00f8 	and.w	r0, r0, #248	; 0xf8
    24f2:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    24f6:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    24fa:	4403      	add	r3, r0
    
    uint8_t third = scale8( offset8, (256 / 3)); // max = 85
    
    uint8_t r, g, b;
    
    if( ! (hue & 0x80) ) {
    24fc:	0625      	lsls	r5, r4, #24
    24fe:	f3c3 2307 	ubfx	r3, r3, #8, #8
    2502:	d45f      	bmi.n	25c4 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0xe0>
        // 0XX
        if( ! (hue & 0x40) ) {
    2504:	f004 0540 	and.w	r5, r4, #64	; 0x40
    2508:	f005 07ff 	and.w	r7, r5, #255	; 0xff
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
    250c:	f004 0420 	and.w	r4, r4, #32
    
    uint8_t r, g, b;
    
    if( ! (hue & 0x80) ) {
        // 0XX
        if( ! (hue & 0x40) ) {
    2510:	2d00      	cmp	r5, #0
    2512:	d146      	bne.n	25a2 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0xbe>
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
    2514:	f004 00ff 	and.w	r0, r4, #255	; 0xff
    2518:	2c00      	cmp	r4, #0
    251a:	d06c      	beq.n	25f6 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x112>
            } else {
                // 001
                //case 1: // O -> Y
                if( Y1 ) {
                    r = K171;
                    g = K85 + third ;
    251c:	3355      	adds	r3, #85	; 0x55
    251e:	b2dd      	uxtb	r5, r3
                FORCE_REFERENCE(b);
            } else {
                // 001
                //case 1: // O -> Y
                if( Y1 ) {
                    r = K171;
    2520:	24ab      	movs	r4, #171	; 0xab
                    g = K85 + third ;
                    b = 0;
    2522:	463b      	mov	r3, r7
    if( G2 ) g = g >> 1;
    if( Gscale ) g = scale8_video_LEAVING_R1_DIRTY( g, Gscale);
    
    // Scale down colors if we're desaturated at all
    // and add the brightness_floor to r, g, and b.
    if( sat != 255 ) {
    2524:	2eff      	cmp	r6, #255	; 0xff
    2526:	d01c      	beq.n	2562 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x7e>
        if( sat == 0) {
    2528:	2e00      	cmp	r6, #0
    252a:	d079      	beq.n	2620 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x13c>
            r = 255; b = 255; g = 255;
        } else {
            //nscale8x3_video( r, g, b, sat);
#if (FASTLED_SCALE8_FIXED==1)
            if( r ) r = scale8_LEAVING_R1_DIRTY( r, sat);
    252c:	b11c      	cbz	r4, 2536 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x52>
/// then explicitly call cleanup_R1.
LIB8STATIC_ALWAYS_INLINE uint8_t scale8_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * ((uint16_t)(scale)+1)) >> 8;
    252e:	fb06 4404 	mla	r4, r6, r4, r4
    2532:	f3c4 2407 	ubfx	r4, r4, #8, #8
            if( g ) g = scale8_LEAVING_R1_DIRTY( g, sat);
    2536:	b11d      	cbz	r5, 2540 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x5c>
    2538:	fb06 5505 	mla	r5, r6, r5, r5
    253c:	f3c5 2507 	ubfx	r5, r5, #8, #8
            if( b ) b = scale8_LEAVING_R1_DIRTY( b, sat);
    2540:	b11b      	cbz	r3, 254a <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x66>
    2542:	fb06 3303 	mla	r3, r6, r3, r3
    2546:	f3c3 2307 	ubfx	r3, r3, #8, #8
///  4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC_ALWAYS_INLINE uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * (1+(uint16_t)(scale))) >> 8;
    254a:	43f0      	mvns	r0, r6
    254c:	b2c0      	uxtb	r0, r0
    254e:	fb00 0000 	mla	r0, r0, r0, r0
    2552:	f3c0 2007 	ubfx	r0, r0, #8, #8
            
            uint8_t desat = 255 - sat;
            desat = scale8( desat, desat);
            
            uint8_t brightness_floor = desat;
            r += brightness_floor;
    2556:	4404      	add	r4, r0
            g += brightness_floor;
    2558:	4405      	add	r5, r0
            b += brightness_floor;
    255a:	4403      	add	r3, r0
            
            uint8_t desat = 255 - sat;
            desat = scale8( desat, desat);
            
            uint8_t brightness_floor = desat;
            r += brightness_floor;
    255c:	b2e4      	uxtb	r4, r4
            g += brightness_floor;
    255e:	b2ed      	uxtb	r5, r5
            b += brightness_floor;
    2560:	b2db      	uxtb	r3, r3
        }
    }
    
    // Now scale everything down if we're at value < 255.
    if( val != 255 ) {
    2562:	2aff      	cmp	r2, #255	; 0xff
    2564:	d018      	beq.n	2598 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0xb4>
/// If you are doing several 'scale8_video's in a row, use this, and
/// then explicitly call cleanup_R1.
LIB8STATIC_ALWAYS_INLINE uint8_t scale8_video_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1 || defined(LIB8_ATTINY)
    uint8_t j = (((int)i * (int)scale) >> 8) + ((i&&scale)?1:0);
    2566:	fb12 f002 	smulbb	r0, r2, r2
    256a:	3200      	adds	r2, #0
    256c:	bf18      	it	ne
    256e:	2201      	movne	r2, #1
    2570:	eb02 2210 	add.w	r2, r2, r0, lsr #8
        
        val = scale8_video_LEAVING_R1_DIRTY( val, val);
        if( val == 0 ) {
    2574:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    2578:	d056      	beq.n	2628 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x144>
            r=0; g=0; b=0;
        } else {
            // nscale8x3_video( r, g, b, val);
#if (FASTLED_SCALE8_FIXED==1)
            if( r ) r = scale8_LEAVING_R1_DIRTY( r, val);
    257a:	b11c      	cbz	r4, 2584 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0xa0>
/// then explicitly call cleanup_R1.
LIB8STATIC_ALWAYS_INLINE uint8_t scale8_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * ((uint16_t)(scale)+1)) >> 8;
    257c:	fb02 4404 	mla	r4, r2, r4, r4
    2580:	f3c4 2407 	ubfx	r4, r4, #8, #8
            if( g ) g = scale8_LEAVING_R1_DIRTY( g, val);
    2584:	b11d      	cbz	r5, 258e <hsv2rgb_rainbow(CHSV const&, CRGB&)+0xaa>
    2586:	fb02 5505 	mla	r5, r2, r5, r5
    258a:	f3c5 2507 	ubfx	r5, r5, #8, #8
            if( b ) b = scale8_LEAVING_R1_DIRTY( b, val);
    258e:	b11b      	cbz	r3, 2598 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0xb4>
    2590:	fb02 3303 	mla	r3, r2, r3, r3
    2594:	f3c3 2307 	ubfx	r3, r3, #8, #8
    // It turns out that fixing it winds up costing more than
    // not fixing it.
    // To paraphrase Dr Bronner, profile! profile! profile!
    //asm volatile(  ""  :  :  : "r26", "r27" );
    //asm volatile (" movw r30, r26 \n" : : : "r30", "r31");
    rgb.r = r;
    2598:	700c      	strb	r4, [r1, #0]
    rgb.g = g;
    259a:	704d      	strb	r5, [r1, #1]
    rgb.b = b;
    259c:	708b      	strb	r3, [r1, #2]
}
    259e:	bcf0      	pop	{r4, r5, r6, r7}
    25a0:	4770      	bx	lr
                }
            }
        } else {
            //01X
            // section 2-3
            if( !  (hue & 0x20) ) {
    25a2:	f004 07ff 	and.w	r7, r4, #255	; 0xff
    25a6:	bb5c      	cbnz	r4, 2600 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x11c>
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                    r = K171 - twothirds;
    25a8:	eb00 04c0 	add.w	r4, r0, r0, lsl #3
    25ac:	eb00 0044 	add.w	r0, r0, r4, lsl #1
    25b0:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    25b4:	1204      	asrs	r4, r0, #8
                    g = K170 + third;
    25b6:	3b56      	subs	r3, #86	; 0x56
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                    r = K171 - twothirds;
    25b8:	f1c4 04ab 	rsb	r4, r4, #171	; 0xab
                    g = K170 + third;
    25bc:	b2dd      	uxtb	r5, r3
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                    r = K171 - twothirds;
    25be:	b2e4      	uxtb	r4, r4
                    g = K170 + third;
                    b = 0;
    25c0:	463b      	mov	r3, r7
    25c2:	e7af      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>
            }
        }
    } else {
        // section 4-7
        // 1XX
        if( ! (hue & 0x40) ) {
    25c4:	f004 0740 	and.w	r7, r4, #64	; 0x40
    25c8:	f007 05ff 	and.w	r5, r7, #255	; 0xff
    25cc:	b9e7      	cbnz	r7, 2608 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x124>
            // 10X
            if( ! ( hue & 0x20) ) {
    25ce:	f004 0720 	and.w	r7, r4, #32
    25d2:	f007 04ff 	and.w	r4, r7, #255	; 0xff
    25d6:	2f00      	cmp	r7, #0
    25d8:	d136      	bne.n	2648 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x164>
///  4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC_ALWAYS_INLINE uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * (1+(uint16_t)(scale))) >> 8;
    25da:	eb00 03c0 	add.w	r3, r0, r0, lsl #3
    25de:	eb00 0043 	add.w	r0, r0, r3, lsl #1
    25e2:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    25e6:	f3c0 2007 	ubfx	r0, r0, #8, #8
                //case 4: // A -> B
                r = 0;
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                g = K171 - twothirds; //K170?
    25ea:	f1c0 05ab 	rsb	r5, r0, #171	; 0xab
                b = K85  + twothirds;
    25ee:	3055      	adds	r0, #85	; 0x55
                //case 4: // A -> B
                r = 0;
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                g = K171 - twothirds; //K170?
    25f0:	b2ed      	uxtb	r5, r5
                b = K85  + twothirds;
    25f2:	b2c3      	uxtb	r3, r0
    25f4:	e796      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
                // 000
                //case 0: // R -> O
                r = K255 - third;
    25f6:	43dc      	mvns	r4, r3
    25f8:	b2e4      	uxtb	r4, r4
                g = third;
    25fa:	461d      	mov	r5, r3
                b = 0;
    25fc:	4603      	mov	r3, r0
    25fe:	e791      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>
                }
            } else {
                // 011
                // case 3: // G -> A
                r = 0;
                FORCE_REFERENCE(r);
    2600:	2400      	movs	r4, #0
                g = K255 - third;
    2602:	43dd      	mvns	r5, r3
    2604:	b2ed      	uxtb	r5, r5
    2606:	e78d      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>
                FORCE_REFERENCE(g);
                b = K255 - third;
                
            }
        } else {
            if( !  (hue & 0x20)  ) {
    2608:	f004 0420 	and.w	r4, r4, #32
    260c:	f004 05ff 	and.w	r5, r4, #255	; 0xff
    2610:	b994      	cbnz	r4, 2638 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x154>
                // 110
                //case 6: // P -- K
                r = K85 + third;
    2612:	f103 0455 	add.w	r4, r3, #85	; 0x55
    2616:	b2e4      	uxtb	r4, r4
                g = 0;
                FORCE_REFERENCE(g);
                b = K171 - third;
    2618:	f1c3 03ab 	rsb	r3, r3, #171	; 0xab
    261c:	b2db      	uxtb	r3, r3
    261e:	e781      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>
    
    // Scale down colors if we're desaturated at all
    // and add the brightness_floor to r, g, and b.
    if( sat != 255 ) {
        if( sat == 0) {
            r = 255; b = 255; g = 255;
    2620:	23ff      	movs	r3, #255	; 0xff
    2622:	461d      	mov	r5, r3
    2624:	461c      	mov	r4, r3
    2626:	e79c      	b.n	2562 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x7e>
    // Now scale everything down if we're at value < 255.
    if( val != 255 ) {
        
        val = scale8_video_LEAVING_R1_DIRTY( val, val);
        if( val == 0 ) {
            r=0; g=0; b=0;
    2628:	4615      	mov	r5, r2
    262a:	4614      	mov	r4, r2
    262c:	4613      	mov	r3, r2
    // It turns out that fixing it winds up costing more than
    // not fixing it.
    // To paraphrase Dr Bronner, profile! profile! profile!
    //asm volatile(  ""  :  :  : "r26", "r27" );
    //asm volatile (" movw r30, r26 \n" : : : "r30", "r31");
    rgb.r = r;
    262e:	700c      	strb	r4, [r1, #0]
    rgb.g = g;
    2630:	704d      	strb	r5, [r1, #1]
    rgb.b = b;
    2632:	708b      	strb	r3, [r1, #2]
}
    2634:	bcf0      	pop	{r4, r5, r6, r7}
    2636:	4770      	bx	lr
                b = K171 - third;
                
            } else {
                // 111
                //case 7: // K -> R
                r = K170 + third;
    2638:	f1a3 0456 	sub.w	r4, r3, #86	; 0x56
    263c:	b2e4      	uxtb	r4, r4
                g = 0;
                FORCE_REFERENCE(g);
    263e:	2500      	movs	r5, #0
                b = K85 - third;
    2640:	f1c3 0355 	rsb	r3, r3, #85	; 0x55
    2644:	b2db      	uxtb	r3, r3
    2646:	e76d      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>
                // 101
                //case 5: // B -> P
                r = third;
                g = 0;
                FORCE_REFERENCE(g);
                b = K255 - third;
    2648:	43d8      	mvns	r0, r3
                b = K85  + twothirds;
                
            } else {
                // 101
                //case 5: // B -> P
                r = third;
    264a:	461c      	mov	r4, r3
                g = 0;
                FORCE_REFERENCE(g);
                b = K255 - third;
    264c:	b2c3      	uxtb	r3, r0
    264e:	e769      	b.n	2524 <hsv2rgb_rainbow(CHSV const&, CRGB&)+0x40>

00002650 <Meltdown::CMeltdownLED::NullEffect(CRGB*, unsigned short*, int)>:
			  return SetEffectNumber(gCurrentEffectNumber + 1);
		  }

		  void ExecuteEffect(CRGB leds[], uint16_t indexes[], int numLeds, int offset = 0) { (this->*(gEffects[GetEffectNumber(offset)]))(leds, indexes, numLeds); }

		  void NullEffect(CRGB leds[], uint16_t indexes[], int numLeds) { }
    2650:	4770      	bx	lr
    2652:	bf00      	nop

00002654 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)>:

				  FillGradientRgb(leds, indexes, numLeds, startPos, blend1, endPos, blend2);
			  }
		  }

		  void SolidColors(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    2654:	b5f0      	push	{r4, r5, r6, r7, lr}
    2656:	9e05      	ldr	r6, [sp, #20]
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    2658:	2e00      	cmp	r6, #0
    265a:	db1e      	blt.n	269a <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x46>

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    265c:	6805      	ldr	r5, [r0, #0]
    265e:	4c76      	ldr	r4, [pc, #472]	; (2838 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1e4>)
		  }

		  void SolidColors(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
		  {
			  // Modes
			  switch (GetModeNumber(modeOffset))
    2660:	6887      	ldr	r7, [r0, #8]

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    2662:	fba4 e405 	umull	lr, r4, r4, r5
    2666:	08e4      	lsrs	r4, r4, #3
    2668:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    266c:	eba5 0444 	sub.w	r4, r5, r4, lsl #1
    2670:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    2674:	eb00 0484 	add.w	r4, r0, r4, lsl #2
		  }

		  void SolidColors(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
		  {
			  // Modes
			  switch (GetModeNumber(modeOffset))
    2678:	443e      	add	r6, r7
    267a:	6d24      	ldr	r4, [r4, #80]	; 0x50
    267c:	3401      	adds	r4, #1
    267e:	fb96 f0f4 	sdiv	r0, r6, r4
    2682:	fb04 6610 	mls	r6, r4, r0, r6
    2686:	3e01      	subs	r6, #1
    2688:	2e09      	cmp	r6, #9
    268a:	d806      	bhi.n	269a <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x46>
    268c:	e8df f006 	tbb	[pc, r6]
    2690:	4f3d2a17 	.word	0x4f3d2a17
    2694:	94837261 	.word	0x94837261
    2698:	b7a6      	.short	0xb7a6

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    269a:	2b00      	cmp	r3, #0
    269c:	f340 80c0 	ble.w	2820 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1cc>
    26a0:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    26a4:	26ff      	movs	r6, #255	; 0xff
        g = (colorcode >>  8) & 0xFF;
    26a6:	2500      	movs	r5, #0
			  {
				  leds[indexes[i]] = color;
    26a8:	f832 0b02 	ldrh.w	r0, [r2], #2
    26ac:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    26b0:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    26b2:	4293      	cmp	r3, r2
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    26b4:	540e      	strb	r6, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    26b6:	7065      	strb	r5, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    26b8:	70a5      	strb	r5, [r4, #2]
    26ba:	d1f5      	bne.n	26a8 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x54>
    26bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26be:	2b00      	cmp	r3, #0
    26c0:	f340 80b8 	ble.w	2834 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1e0>
    26c4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    26c8:	27ff      	movs	r7, #255	; 0xff
        g = (colorcode >>  8) & 0xFF;
    26ca:	2645      	movs	r6, #69	; 0x45
        b = (colorcode >>  0) & 0xFF;
    26cc:	2500      	movs	r5, #0
			  {
				  leds[indexes[i]] = color;
    26ce:	f832 0b02 	ldrh.w	r0, [r2], #2
    26d2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    26d6:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    26d8:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    26da:	540f      	strb	r7, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    26dc:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    26de:	70a5      	strb	r5, [r4, #2]
    26e0:	d1f5      	bne.n	26ce <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x7a>
    26e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26e4:	2b00      	cmp	r3, #0
    26e6:	f340 80a4 	ble.w	2832 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1de>
    26ea:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    26ee:	27ff      	movs	r7, #255	; 0xff
        g = (colorcode >>  8) & 0xFF;
    26f0:	26a5      	movs	r6, #165	; 0xa5
        b = (colorcode >>  0) & 0xFF;
    26f2:	2500      	movs	r5, #0
			  {
				  leds[indexes[i]] = color;
    26f4:	f832 0b02 	ldrh.w	r0, [r2], #2
    26f8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    26fc:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    26fe:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2700:	540f      	strb	r7, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    2702:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    2704:	70a5      	strb	r5, [r4, #2]
    2706:	d1f5      	bne.n	26f4 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0xa0>
    2708:	bdf0      	pop	{r4, r5, r6, r7, pc}
    270a:	2b00      	cmp	r3, #0
    270c:	f340 8090 	ble.w	2830 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1dc>
    2710:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2714:	25ff      	movs	r5, #255	; 0xff
        g = (colorcode >>  8) & 0xFF;
        b = (colorcode >>  0) & 0xFF;
    2716:	2600      	movs	r6, #0
			  {
				  leds[indexes[i]] = color;
    2718:	f832 0b02 	ldrh.w	r0, [r2], #2
    271c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    2720:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    2722:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2724:	540d      	strb	r5, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    2726:	7065      	strb	r5, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    2728:	70a6      	strb	r6, [r4, #2]
    272a:	d1f5      	bne.n	2718 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0xc4>
    272c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    272e:	2b00      	cmp	r3, #0
    2730:	dd7d      	ble.n	282e <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1da>
    2732:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2736:	27ad      	movs	r7, #173	; 0xad
        g = (colorcode >>  8) & 0xFF;
    2738:	26ff      	movs	r6, #255	; 0xff
        b = (colorcode >>  0) & 0xFF;
    273a:	252f      	movs	r5, #47	; 0x2f
			  {
				  leds[indexes[i]] = color;
    273c:	f832 0b02 	ldrh.w	r0, [r2], #2
    2740:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    2744:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    2746:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2748:	540f      	strb	r7, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    274a:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    274c:	70a5      	strb	r5, [r4, #2]
    274e:	d1f5      	bne.n	273c <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0xe8>
    2750:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2752:	2b00      	cmp	r3, #0
    2754:	dd6a      	ble.n	282c <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1d8>
    2756:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    275a:	2500      	movs	r5, #0
        g = (colorcode >>  8) & 0xFF;
    275c:	2680      	movs	r6, #128	; 0x80
			  {
				  leds[indexes[i]] = color;
    275e:	f832 0b02 	ldrh.w	r0, [r2], #2
    2762:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    2766:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    2768:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    276a:	540d      	strb	r5, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    276c:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    276e:	70a5      	strb	r5, [r4, #2]
    2770:	d1f5      	bne.n	275e <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x10a>
    2772:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2774:	2b00      	cmp	r3, #0
    2776:	dd58      	ble.n	282a <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1d6>
    2778:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    277c:	2600      	movs	r6, #0
        g = (colorcode >>  8) & 0xFF;
    277e:	2580      	movs	r5, #128	; 0x80
			  {
				  leds[indexes[i]] = color;
    2780:	f832 0b02 	ldrh.w	r0, [r2], #2
    2784:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    2788:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    278a:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    278c:	540e      	strb	r6, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    278e:	7065      	strb	r5, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    2790:	70a5      	strb	r5, [r4, #2]
    2792:	d1f5      	bne.n	2780 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x12c>
    2794:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2796:	2b00      	cmp	r3, #0
    2798:	dd46      	ble.n	2828 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1d4>
    279a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    279e:	2500      	movs	r5, #0
        g = (colorcode >>  8) & 0xFF;
        b = (colorcode >>  0) & 0xFF;
    27a0:	26ff      	movs	r6, #255	; 0xff
			  {
				  leds[indexes[i]] = color;
    27a2:	f832 0b02 	ldrh.w	r0, [r2], #2
    27a6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    27aa:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    27ac:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    27ae:	540d      	strb	r5, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    27b0:	7065      	strb	r5, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    27b2:	70a6      	strb	r6, [r4, #2]
    27b4:	d1f5      	bne.n	27a2 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x14e>
    27b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    27b8:	2b00      	cmp	r3, #0
    27ba:	dd34      	ble.n	2826 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1d2>
    27bc:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    27c0:	274b      	movs	r7, #75	; 0x4b
        g = (colorcode >>  8) & 0xFF;
    27c2:	2600      	movs	r6, #0
        b = (colorcode >>  0) & 0xFF;
    27c4:	2582      	movs	r5, #130	; 0x82
			  {
				  leds[indexes[i]] = color;
    27c6:	f832 0b02 	ldrh.w	r0, [r2], #2
    27ca:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    27ce:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    27d0:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    27d2:	540f      	strb	r7, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    27d4:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    27d6:	70a5      	strb	r5, [r4, #2]
    27d8:	d1f5      	bne.n	27c6 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x172>
    27da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    27dc:	2b00      	cmp	r3, #0
    27de:	dd21      	ble.n	2824 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1d0>
    27e0:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    27e4:	25ee      	movs	r5, #238	; 0xee
        g = (colorcode >>  8) & 0xFF;
    27e6:	2682      	movs	r6, #130	; 0x82
			  {
				  leds[indexes[i]] = color;
    27e8:	f832 0b02 	ldrh.w	r0, [r2], #2
    27ec:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    27f0:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    27f2:	429a      	cmp	r2, r3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    27f4:	540d      	strb	r5, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    27f6:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    27f8:	70a5      	strb	r5, [r4, #2]
    27fa:	d1f5      	bne.n	27e8 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x194>
    27fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    27fe:	2b00      	cmp	r3, #0
    2800:	dd0f      	ble.n	2822 <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1ce>
    2802:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2806:	25ff      	movs	r5, #255	; 0xff
        g = (colorcode >>  8) & 0xFF;
    2808:	2600      	movs	r6, #0
			  {
				  leds[indexes[i]] = color;
    280a:	f832 0b02 	ldrh.w	r0, [r2], #2
    280e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    2812:	180c      	adds	r4, r1, r0

#pragma region UTILITY

		  void SetAllColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB::HTMLColorCode color)
		  {
			  for (int i = 0; i < numLeds; i++)
    2814:	4293      	cmp	r3, r2
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    2816:	540d      	strb	r5, [r1, r0]
        g = (colorcode >>  8) & 0xFF;
    2818:	7066      	strb	r6, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
    281a:	70a5      	strb	r5, [r4, #2]
    281c:	d1f5      	bne.n	280a <Meltdown::CMeltdownLED::SolidColors(CRGB*, unsigned short*, int, int)+0x1b6>
    281e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2820:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2822:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2824:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2826:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2828:	bdf0      	pop	{r4, r5, r6, r7, pc}
    282a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    282c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    282e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2830:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2832:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2834:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2836:	bf00      	nop
    2838:	cccccccd 	.word	0xcccccccd

0000283c <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)>:
			  default:
				  SetAllColor(leds, indexes, numLeds, CRGB::Red);
			  }
		  }

		  void Rainbow(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    283c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2840:	4681      	mov	r9, r0
    2842:	b083      	sub	sp, #12
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2844:	69c0      	ldr	r0, [r0, #28]
		  void Rainbow(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
		  {
			  static int hue = 1;

			  int deltaHue = GetAnalogPattern(1, 15);
			  FillRainbow(leds, indexes, numLeds, gPos + hue, deltaHue);
    2846:	f8df a13c 	ldr.w	sl, [pc, #316]	; 2984 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x148>
			  default:
				  SetAllColor(leds, indexes, numLeds, CRGB::Red);
			  }
		  }

		  void Rainbow(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    284a:	4698      	mov	r8, r3
    284c:	4615      	mov	r5, r2
    284e:	460c      	mov	r4, r1
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2850:	f004 ff38 	bl	76c4 <__aeabi_i2f>
    2854:	4948      	ldr	r1, [pc, #288]	; (2978 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x13c>)
    2856:	f004 ff89 	bl	776c <__aeabi_fmul>
    285a:	4948      	ldr	r1, [pc, #288]	; (297c <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x140>)
    285c:	f005 f83a 	bl	78d4 <__aeabi_fdiv>
    2860:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    2864:	f004 fe7a 	bl	755c <__addsf3>
    2868:	f005 f946 	bl	7af8 <__aeabi_f2iz>
		  }

		  void FillRainbow(CRGB leds[], uint16_t indexes[], int numLeds, int initialHue, int deltaHue)
		  {
			  CHSV hsv;
			  hsv.hue = initialHue;
    286c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
    2870:	f8da 3000 	ldr.w	r3, [sl]
    2874:	4413      	add	r3, r2
    2876:	f88d 3004 	strb.w	r3, [sp, #4]
			  hsv.val = 255;
    287a:	22ff      	movs	r2, #255	; 0xff
			  hsv.sat = 240;
    287c:	23f0      	movs	r3, #240	; 0xf0
			  for (int i = 0; i < numLeds; i++)
    287e:	f1b8 0f00 	cmp.w	r8, #0

		  void FillRainbow(CRGB leds[], uint16_t indexes[], int numLeds, int initialHue, int deltaHue)
		  {
			  CHSV hsv;
			  hsv.hue = initialHue;
			  hsv.val = 255;
    2882:	f88d 2006 	strb.w	r2, [sp, #6]
			  hsv.sat = 240;
    2886:	f88d 3005 	strb.w	r3, [sp, #5]
			  for (int i = 0; i < numLeds; i++)
    288a:	dd12      	ble.n	28b2 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x76>
    288c:	b2c6      	uxtb	r6, r0
    288e:	46ab      	mov	fp, r5
    2890:	eb05 0748 	add.w	r7, r5, r8, lsl #1
			  {
				  leds[indexes[i]] = hsv;
    2894:	f83b 1b02 	ldrh.w	r1, [fp], #2
    }

    /// allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
    2898:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    289c:	4421      	add	r1, r4
    289e:	a801      	add	r0, sp, #4
    28a0:	f7ff fe20 	bl	24e4 <hsv2rgb_rainbow(CHSV const&, CRGB&)>
				  hsv.hue += deltaHue;
    28a4:	f89d 2004 	ldrb.w	r2, [sp, #4]
		  {
			  CHSV hsv;
			  hsv.hue = initialHue;
			  hsv.val = 255;
			  hsv.sat = 240;
			  for (int i = 0; i < numLeds; i++)
    28a8:	45bb      	cmp	fp, r7
			  {
				  leds[indexes[i]] = hsv;
				  hsv.hue += deltaHue;
    28aa:	4432      	add	r2, r6
    28ac:	f88d 2004 	strb.w	r2, [sp, #4]
		  {
			  CHSV hsv;
			  hsv.hue = initialHue;
			  hsv.val = 255;
			  hsv.sat = 240;
			  for (int i = 0; i < numLeds; i++)
    28b0:	d1f0      	bne.n	2894 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x58>
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    28b2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    28b4:	2b00      	cmp	r3, #0
    28b6:	db27      	blt.n	2908 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xcc>

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    28b8:	f8d9 2000 	ldr.w	r2, [r9]
    28bc:	4b30      	ldr	r3, [pc, #192]	; (2980 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x144>)

			  int deltaHue = GetAnalogPattern(1, 15);
			  FillRainbow(leds, indexes, numLeds, gPos + hue, deltaHue);

			  // Modes
			  switch (GetModeNumber(modeOffset))
    28be:	f8d9 1008 	ldr.w	r1, [r9, #8]

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    28c2:	fba3 0302 	umull	r0, r3, r3, r2
    28c6:	08db      	lsrs	r3, r3, #3
    28c8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    28cc:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    28d0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    28d4:	eb09 0983 	add.w	r9, r9, r3, lsl #2

			  int deltaHue = GetAnalogPattern(1, 15);
			  FillRainbow(leds, indexes, numLeds, gPos + hue, deltaHue);

			  // Modes
			  switch (GetModeNumber(modeOffset))
    28d8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    28da:	eb03 0b01 	add.w	fp, r3, r1
    28de:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
    28e2:	3301      	adds	r3, #1
    28e4:	fb9b f1f3 	sdiv	r1, fp, r3
    28e8:	fb03 bb11 	mls	fp, r3, r1, fp
    28ec:	f1bb 0f02 	cmp.w	fp, #2
    28f0:	d00d      	beq.n	290e <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xd2>
    28f2:	f1bb 0f03 	cmp.w	fp, #3
    28f6:	d023      	beq.n	2940 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x104>
    28f8:	f1bb 0f01 	cmp.w	fp, #1
    28fc:	d104      	bne.n	2908 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xcc>
			  {
			  case 1:
				  // Increment the hue.
				  hue++;
    28fe:	f8da 3000 	ldr.w	r3, [sl]
    2902:	3301      	adds	r3, #1
    2904:	f8ca 3000 	str.w	r3, [sl]
				  // Invert rainbox colors and increment the hue.
				  Invert(leds, indexes, numLeds);
				  hue++;
				  break;
			  }
		  }
    2908:	b003      	add	sp, #12
    290a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

		  int IncrementModeNumber() { return SetModeNumber(gCurrentModeNumber + 1); }

		  void Invert(CRGB leds[], uint16_t indexes[], int numLeds)
		  {
			  for (int i = 0; i < numLeds; i++)
    290e:	f1b8 0f00 	cmp.w	r8, #0
    2912:	bfc8      	it	gt
    2914:	eb05 0848 	addgt.w	r8, r5, r8, lsl #1
    2918:	ddf6      	ble.n	2908 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xcc>
			  {
				  leds[indexes[i]] = -leds[indexes[i]];
    291a:	f835 3b02 	ldrh.w	r3, [r5], #2
    291e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2922:	18e2      	adds	r2, r4, r3
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2924:	5ce6      	ldrb	r6, [r4, r3]
    /// invert each channel
    inline CRGB operator- ()
    {
        CRGB retval;
        retval.r = 255 - r;
        retval.g = 255 - g;
    2926:	7850      	ldrb	r0, [r2, #1]
        retval.b = 255 - b;
    2928:	7891      	ldrb	r1, [r2, #2]
    /// invert each channel
    inline CRGB operator- ()
    {
        CRGB retval;
        retval.r = 255 - r;
        retval.g = 255 - g;
    292a:	43c0      	mvns	r0, r0
        retval.b = 255 - b;
    292c:	43c9      	mvns	r1, r1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    292e:	43f6      	mvns	r6, r6

		  int IncrementModeNumber() { return SetModeNumber(gCurrentModeNumber + 1); }

		  void Invert(CRGB leds[], uint16_t indexes[], int numLeds)
		  {
			  for (int i = 0; i < numLeds; i++)
    2930:	45a8      	cmp	r8, r5
    2932:	54e6      	strb	r6, [r4, r3]
        g = rhs.g;
    2934:	7050      	strb	r0, [r2, #1]
        b = rhs.b;
    2936:	7091      	strb	r1, [r2, #2]
    2938:	d1ef      	bne.n	291a <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xde>
				  // Invert rainbox colors and increment the hue.
				  Invert(leds, indexes, numLeds);
				  hue++;
				  break;
			  }
		  }
    293a:	b003      	add	sp, #12
    293c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

		  int IncrementModeNumber() { return SetModeNumber(gCurrentModeNumber + 1); }

		  void Invert(CRGB leds[], uint16_t indexes[], int numLeds)
		  {
			  for (int i = 0; i < numLeds; i++)
    2940:	f1b8 0f00 	cmp.w	r8, #0
    2944:	bfc8      	it	gt
    2946:	eb05 0848 	addgt.w	r8, r5, r8, lsl #1
    294a:	ddd8      	ble.n	28fe <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xc2>
			  {
				  leds[indexes[i]] = -leds[indexes[i]];
    294c:	f835 3b02 	ldrh.w	r3, [r5], #2
    2950:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2954:	18e2      	adds	r2, r4, r3
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2956:	5ce6      	ldrb	r6, [r4, r3]
    /// invert each channel
    inline CRGB operator- ()
    {
        CRGB retval;
        retval.r = 255 - r;
        retval.g = 255 - g;
    2958:	7850      	ldrb	r0, [r2, #1]
        retval.b = 255 - b;
    295a:	7891      	ldrb	r1, [r2, #2]
    /// invert each channel
    inline CRGB operator- ()
    {
        CRGB retval;
        retval.r = 255 - r;
        retval.g = 255 - g;
    295c:	43c0      	mvns	r0, r0
        retval.b = 255 - b;
    295e:	43c9      	mvns	r1, r1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2960:	43f6      	mvns	r6, r6

		  int IncrementModeNumber() { return SetModeNumber(gCurrentModeNumber + 1); }

		  void Invert(CRGB leds[], uint16_t indexes[], int numLeds)
		  {
			  for (int i = 0; i < numLeds; i++)
    2962:	4545      	cmp	r5, r8
    2964:	54e6      	strb	r6, [r4, r3]
        g = rhs.g;
    2966:	7050      	strb	r0, [r2, #1]
        b = rhs.b;
    2968:	7091      	strb	r1, [r2, #2]
    296a:	d1ef      	bne.n	294c <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0x110>
			  // Modes
			  switch (GetModeNumber(modeOffset))
			  {
			  case 1:
				  // Increment the hue.
				  hue++;
    296c:	f8da 3000 	ldr.w	r3, [sl]
    2970:	3301      	adds	r3, #1
    2972:	f8ca 3000 	str.w	r3, [sl]
    2976:	e7c7      	b.n	2908 <Meltdown::CMeltdownLED::Rainbow(CRGB*, unsigned short*, int, int)+0xcc>
    2978:	41600000 	.word	0x41600000
    297c:	447fc000 	.word	0x447fc000
    2980:	cccccccd 	.word	0xcccccccd
    2984:	1fff8728 	.word	0x1fff8728

00002988 <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)>:

		  void ExecuteEffect(CRGB leds[], uint16_t indexes[], int numLeds, int offset = 0) { (this->*(gEffects[GetEffectNumber(offset)]))(leds, indexes, numLeds); }

		  void NullEffect(CRGB leds[], uint16_t indexes[], int numLeds) { }

		  void GlitterEffect(CRGB leds[], uint16_t indexes[], int numLeds)
    2988:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    298c:	6a05      	ldr	r5, [r0, #32]
	if (out_range >= 0) {
		num += in_range / 2;
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
    298e:	4c32      	ldr	r4, [pc, #200]	; (2a58 <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0xd0>)
    2990:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 2a60 <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0xd8>
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    2994:	f240 10db 	movw	r0, #475	; 0x1db
    2998:	fb00 f005 	mul.w	r0, r0, r5
	if (out_range >= 0) {
		num += in_range / 2;
    299c:	f200 10ff 	addw	r0, r0, #511	; 0x1ff
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
    29a0:	fb84 5400 	smull	r5, r4, r4, r0
    29a4:	1826      	adds	r6, r4, r0
	if (out_range >= 0) {
		if (in_range * num < 0) return result - 1;
    29a6:	2800      	cmp	r0, #0
	if (out_range >= 0) {
		num += in_range / 2;
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
    29a8:	ea4f 74e0 	mov.w	r4, r0, asr #31
    29ac:	f8ba 0000 	ldrh.w	r0, [sl]
    29b0:	ebc4 2466 	rsb	r4, r4, r6, asr #9
    29b4:	bfac      	ite	ge
    29b6:	f104 0619 	addge.w	r6, r4, #25
	if (out_range >= 0) {
		if (in_range * num < 0) return result - 1;
    29ba:	f104 0618 	addlt.w	r6, r4, #24
    29be:	eb00 2440 	add.w	r4, r0, r0, lsl #9
    29c2:	eb00 0484 	add.w	r4, r0, r4, lsl #2
    29c6:	f504 5458 	add.w	r4, r4, #13824	; 0x3600
    29ca:	3419      	adds	r4, #25
    29cc:	b2a4      	uxth	r4, r4
		  {
			  int chanceOfGlitter = GetAnalogEffect(25, 500);
			  if (random8() < chanceOfGlitter)
    29ce:	eb04 2014 	add.w	r0, r4, r4, lsr #8
    29d2:	b2c0      	uxtb	r0, r0
    29d4:	42b0      	cmp	r0, r6
    29d6:	f8aa 4000 	strh.w	r4, [sl]
    29da:	db01      	blt.n	29e0 <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0x58>
    29dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    29e0:	4690      	mov	r8, r2
    29e2:	460f      	mov	r7, r1
			  for (int i = 0; i < numPositions; i++)
			  {
				  uint8_t random = random8(1, 255);
				  if (random < 255 * frequency)
				  {
					  uint16_t index = indexes[random16(numLeds)];
    29e4:	b29d      	uxth	r5, r3
    29e6:	f04f 0903 	mov.w	r9, #3
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    29ea:	26ff      	movs	r6, #255	; 0xff
    29ec:	e006      	b.n	29fc <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0x74>
    29ee:	f8aa 4000 	strh.w	r4, [sl]
		  }

		  /// Add a specific color in random locations.
		  void SetRandomColor(CRGB leds[], uint16_t indexes[], int numLeds, int numPositions, CRGB::HTMLColorCode color, float frequency = .05)
		  {
			  for (int i = 0; i < numPositions; i++)
    29f2:	f1b9 0901 	subs.w	r9, r9, #1
    29f6:	d0f1      	beq.n	29dc <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0x54>
    29f8:	f8ba 4000 	ldrh.w	r4, [sl]
    29fc:	eb04 2344 	add.w	r3, r4, r4, lsl #9
    2a00:	eb04 0483 	add.w	r4, r4, r3, lsl #2
    2a04:	f504 5458 	add.w	r4, r4, #13824	; 0x3600
    2a08:	3419      	adds	r4, #25
    2a0a:	b2a4      	uxth	r4, r4
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
    2a0c:	eb04 2014 	add.w	r0, r4, r4, lsr #8
			  {
				  uint8_t random = random8(1, 255);
				  if (random < 255 * frequency)
    2a10:	b2c0      	uxtb	r0, r0
    2a12:	ebc0 10c0 	rsb	r0, r0, r0, lsl #7
    2a16:	11c0      	asrs	r0, r0, #7
    2a18:	3001      	adds	r0, #1
    2a1a:	b2c0      	uxtb	r0, r0
    2a1c:	f004 fe52 	bl	76c4 <__aeabi_i2f>
    2a20:	490e      	ldr	r1, [pc, #56]	; (2a5c <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0xd4>)
    2a22:	f005 f841 	bl	7aa8 <__aeabi_fcmplt>
}

/// Generate a 16 bit random number
LIB8STATIC uint16_t random16()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    2a26:	eb04 2344 	add.w	r3, r4, r4, lsl #9
    2a2a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2a2e:	f503 5358 	add.w	r3, r3, #13824	; 0x3600
    2a32:	3319      	adds	r3, #25
    2a34:	b29b      	uxth	r3, r3
				  {
					  uint16_t index = indexes[random16(numLeds)];
    2a36:	fb03 f205 	mul.w	r2, r3, r5
    2a3a:	0c12      	lsrs	r2, r2, #16
		  void SetRandomColor(CRGB leds[], uint16_t indexes[], int numLeds, int numPositions, CRGB::HTMLColorCode color, float frequency = .05)
		  {
			  for (int i = 0; i < numPositions; i++)
			  {
				  uint8_t random = random8(1, 255);
				  if (random < 255 * frequency)
    2a3c:	2800      	cmp	r0, #0
    2a3e:	d0d6      	beq.n	29ee <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0x66>
    2a40:	f8aa 3000 	strh.w	r3, [sl]
				  {
					  uint16_t index = indexes[random16(numLeds)];
					  leds[index] = color;
    2a44:	f838 3012 	ldrh.w	r3, [r8, r2, lsl #1]
    2a48:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2a4c:	18fa      	adds	r2, r7, r3
    2a4e:	54fe      	strb	r6, [r7, r3]
        g = (colorcode >>  8) & 0xFF;
    2a50:	7056      	strb	r6, [r2, #1]
        b = (colorcode >>  0) & 0xFF;
    2a52:	7096      	strb	r6, [r2, #2]
    2a54:	e7cd      	b.n	29f2 <Meltdown::CMeltdownLED::GlitterEffect(CRGB*, unsigned short*, int)+0x6a>
    2a56:	bf00      	nop
    2a58:	80200803 	.word	0x80200803
    2a5c:	42cc0000 	.word	0x42cc0000
    2a60:	1fff8724 	.word	0x1fff8724

00002a64 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)>:
			 // }

			 // SetAllColor(leds, indexes, numLeds, hue);
		  //}

		  void Confetti(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    2a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2a68:	b0f7      	sub	sp, #476	; 0x1dc
    2a6a:	4605      	mov	r5, r0
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2a6c:	69c0      	ldr	r0, [r0, #28]
			 // }

			 // SetAllColor(leds, indexes, numLeds, hue);
		  //}

		  void Confetti(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    2a6e:	9205      	str	r2, [sp, #20]
    2a70:	469a      	mov	sl, r3
    2a72:	4688      	mov	r8, r1
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2a74:	f004 fe26 	bl	76c4 <__aeabi_i2f>
    2a78:	498d      	ldr	r1, [pc, #564]	; (2cb0 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x24c>)
    2a7a:	f004 fe77 	bl	776c <__aeabi_fmul>
    2a7e:	498d      	ldr	r1, [pc, #564]	; (2cb4 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x250>)
    2a80:	f004 ff28 	bl	78d4 <__aeabi_fdiv>
    2a84:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    2a88:	f004 fd68 	bl	755c <__addsf3>
    2a8c:	f005 f834 	bl	7af8 <__aeabi_f2iz>
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    2a90:	f1ba 0f00 	cmp.w	sl, #0
    2a94:	dd20      	ble.n	2ad8 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x74>
    2a96:	f1c0 01ff 	rsb	r1, r0, #255	; 0xff
    2a9a:	9b05      	ldr	r3, [sp, #20]
    2a9c:	b2c9      	uxtb	r1, r1
    2a9e:	3101      	adds	r1, #1
    2aa0:	4618      	mov	r0, r3
    2aa2:	eb03 044a 	add.w	r4, r3, sl, lsl #1
			  {
				  int scale = 255 - fade;
				  (leds[indexes[i]]).nscale8(scale);
    2aa6:	f830 3b02 	ldrh.w	r3, [r0], #2
    2aaa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2aae:	eb08 0603 	add.w	r6, r8, r3
LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    2ab2:	f818 2003 	ldrb.w	r2, [r8, r3]
    2ab6:	fb01 f202 	mul.w	r2, r1, r2
    2aba:	1212      	asrs	r2, r2, #8
    2abc:	f808 2003 	strb.w	r2, [r8, r3]
    g = (((uint16_t)g) * scale_fixed) >> 8;
    2ac0:	7872      	ldrb	r2, [r6, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    2ac2:	78b3      	ldrb	r3, [r6, #2]
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    2ac4:	fb01 f202 	mul.w	r2, r1, r2
    b = (((uint16_t)b) * scale_fixed) >> 8;
    2ac8:	fb01 f303 	mul.w	r3, r1, r3
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    2acc:	1212      	asrs	r2, r2, #8
    b = (((uint16_t)b) * scale_fixed) >> 8;
    2ace:	121b      	asrs	r3, r3, #8
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    2ad0:	4284      	cmp	r4, r0
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    2ad2:	7072      	strb	r2, [r6, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    2ad4:	70b3      	strb	r3, [r6, #2]
    2ad6:	d1e6      	bne.n	2aa6 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x42>
extern uint16_t rand16seed;// = RAND16_SEED;

/// Generate an 8-bit random number
LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    2ad8:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 2cb8 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x254>
			  return palettes[index % ARRAY_SIZE(palettes)];
		  }

		  PaletteData GetRandomPalette()
		  {
			  return GetPalette(gRandomPaletteNumber);
    2adc:	f8d5 b010 	ldr.w	fp, [r5, #16]
    2ae0:	f8b9 3000 	ldrh.w	r3, [r9]
        entries[12]=c12; entries[13]=c13; entries[14]=c14; entries[15]=c15;
    };

    CRGBPalette16( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
    2ae4:	f505 71cc 	add.w	r1, r5, #408	; 0x198
    2ae8:	eb03 2443 	add.w	r4, r3, r3, lsl #9
    2aec:	2230      	movs	r2, #48	; 0x30
    2aee:	a814      	add	r0, sp, #80	; 0x50
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    2af0:	2601      	movs	r6, #1
    2af2:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2af6:	f001 fe41 	bl	477c <memcpy>
    2afa:	f505 7184 	add.w	r1, r5, #264	; 0x108
    2afe:	2230      	movs	r2, #48	; 0x30
    2b00:	f10d 0081 	add.w	r0, sp, #129	; 0x81
    2b04:	f88d 6080 	strb.w	r6, [sp, #128]	; 0x80
    2b08:	f001 fe38 	bl	477c <memcpy>
    2b0c:	f505 71e4 	add.w	r1, r5, #456	; 0x1c8
    2b10:	2230      	movs	r2, #48	; 0x30
    2b12:	f10d 00b2 	add.w	r0, sp, #178	; 0xb2
    2b16:	f88d 60b1 	strb.w	r6, [sp, #177]	; 0xb1
    2b1a:	f001 fe2f 	bl	477c <memcpy>
    2b1e:	f505 719c 	add.w	r1, r5, #312	; 0x138
    2b22:	2230      	movs	r2, #48	; 0x30
    2b24:	f10d 00e3 	add.w	r0, sp, #227	; 0xe3
    2b28:	f88d 60e2 	strb.w	r6, [sp, #226]	; 0xe2
    2b2c:	f001 fe26 	bl	477c <memcpy>
    2b30:	f505 71b4 	add.w	r1, r5, #360	; 0x168
    2b34:	2230      	movs	r2, #48	; 0x30
    2b36:	a845      	add	r0, sp, #276	; 0x114
    2b38:	f88d 6113 	strb.w	r6, [sp, #275]	; 0x113
    2b3c:	f001 fe1e 	bl	477c <memcpy>
    2b40:	f105 01d8 	add.w	r1, r5, #216	; 0xd8
    2b44:	2230      	movs	r2, #48	; 0x30
    2b46:	f20d 1045 	addw	r0, sp, #325	; 0x145
    2b4a:	f88d 6144 	strb.w	r6, [sp, #324]	; 0x144
    2b4e:	f001 fe15 	bl	477c <memcpy>
    2b52:	f505 710a 	add.w	r1, r5, #552	; 0x228
    2b56:	2230      	movs	r2, #48	; 0x30
    2b58:	f50d 70bb 	add.w	r0, sp, #374	; 0x176
    2b5c:	f88d 6175 	strb.w	r6, [sp, #373]	; 0x175
    2b60:	f504 5458 	add.w	r4, r4, #13824	; 0x3600
    2b64:	f001 fe0a 	bl	477c <memcpy>
    2b68:	f505 71fc 	add.w	r1, r5, #504	; 0x1f8

			  return palettes[index % ARRAY_SIZE(palettes)];
    2b6c:	f00b 0507 	and.w	r5, fp, #7
    2b70:	2230      	movs	r2, #48	; 0x30
    2b72:	3419      	adds	r4, #25
    2b74:	f20d 10a7 	addw	r0, sp, #423	; 0x1a7
    2b78:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    2b7c:	f88d 61a6 	strb.w	r6, [sp, #422]	; 0x1a6
    2b80:	b2a4      	uxth	r4, r4
    2b82:	f001 fdfb 	bl	477c <memcpy>

			  return palettes[index % ARRAY_SIZE(palettes)];
    2b86:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
    2b8a:	ab14      	add	r3, sp, #80	; 0x50
    2b8c:	441d      	add	r5, r3
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
    2b8e:	eb04 2714 	add.w	r7, r4, r4, lsr #8
		  {
			  int fade = GetAnalogPattern(2, 30);
			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  // Get some slight variation in the selected colors.
			  int numColors = random8(4, 8);
    2b92:	f3c7 1781 	ubfx	r7, r7, #6, #2
    2b96:	4629      	mov	r1, r5
    2b98:	a807      	add	r0, sp, #28
    2b9a:	2230      	movs	r2, #48	; 0x30
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    2b9c:	f88d 61d7 	strb.w	r6, [sp, #471]	; 0x1d7
		  {
			  int fade = GetAnalogPattern(2, 30);
			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  // Get some slight variation in the selected colors.
			  int numColors = random8(4, 8);
    2ba0:	3704      	adds	r7, #4
    2ba2:	f001 fdeb 	bl	477c <memcpy>

		int numModes;
		PatternFunc patternFunc;
	};

	struct PaletteData
    2ba6:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
    2baa:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
    2bae:	fa47 f306 	asr.w	r3, r7, r6
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
			  }
			  else
			  {
				  return ColorFromPalette(palette, mappedPos, brightness, blendType);
    2bb2:	9604      	str	r6, [sp, #16]
    2bb4:	9303      	str	r3, [sp, #12]
			  // Get some slight variation in the selected colors.
			  int numColors = random8(4, 8);
			  // Get a random palette to select our colors.
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numColors; i++)
    2bb6:	2600      	movs	r6, #0
    2bb8:	e006      	b.n	2bc8 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x164>
extern uint16_t rand16seed;// = RAND16_SEED;

/// Generate an 8-bit random number
LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    2bba:	4b3f      	ldr	r3, [pc, #252]	; (2cb8 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x254>)
    2bbc:	3601      	adds	r6, #1
    2bbe:	42b7      	cmp	r7, r6
    2bc0:	801c      	strh	r4, [r3, #0]
    2bc2:	dd72      	ble.n	2caa <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x246>
    2bc4:	f8b9 4000 	ldrh.w	r4, [r9]
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    2bc8:	fb96 fcf7 	sdiv	ip, r6, r7
    2bcc:	ad07      	add	r5, sp, #28
    2bce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2bd0:	eb04 2e44 	add.w	lr, r4, r4, lsl #9
    2bd4:	eb04 0e8e 	add.w	lr, r4, lr, lsl #2
    2bd8:	ac14      	add	r4, sp, #80	; 0x50
    2bda:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2bdc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2bde:	f50e 5e58 	add.w	lr, lr, #13824	; 0x3600
    2be2:	f10e 0e19 	add.w	lr, lr, #25
    2be6:	fa1f fe8e 	uxth.w	lr, lr
    2bea:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2bec:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
    2bf0:	eb0e 2b1e 	add.w	fp, lr, lr, lsr #8
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
			  }
			  else
			  {
				  return ColorFromPalette(palette, mappedPos, brightness, blendType);
    2bf4:	fa5f fb8b 	uxtb.w	fp, fp
    2bf8:	eb0b 158b 	add.w	r5, fp, fp, lsl #6
    2bfc:	eb0b 0b45 	add.w	fp, fp, r5, lsl #1
    2c00:	9d04      	ldr	r5, [sp, #16]
    2c02:	9500      	str	r5, [sp, #0]
    2c04:	ea4f 2b2b 	mov.w	fp, fp, asr #8
    2c08:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    2c0c:	fb07 6c1c 	mls	ip, r7, ip, r6
    2c10:	9b03      	ldr	r3, [sp, #12]
extern uint16_t rand16seed;// = RAND16_SEED;

/// Generate an 8-bit random number
LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    2c12:	f8a9 e000 	strh.w	lr, [r9]
    2c16:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
    2c1a:	ebcc 2c0c 	rsb	ip, ip, ip, lsl #8
    2c1e:	449c      	add	ip, r3
    2c20:	a914      	add	r1, sp, #80	; 0x50
    2c22:	fb9c f2f7 	sdiv	r2, ip, r7
    2c26:	fa5f f38b 	uxtb.w	r3, fp
    2c2a:	b2d2      	uxtb	r2, r2
    2c2c:	a806      	add	r0, sp, #24
    2c2e:	f7ff fb37 	bl	22a0 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)>
    2c32:	f8b9 3000 	ldrh.w	r3, [r9]
    2c36:	eb03 2443 	add.w	r4, r3, r3, lsl #9
    2c3a:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2c3e:	f504 5458 	add.w	r4, r4, #13824	; 0x3600
    2c42:	3419      	adds	r4, #25
    2c44:	b2a4      	uxth	r4, r4
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
    2c46:	eb04 2314 	add.w	r3, r4, r4, lsr #8
		  void SetRandomColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB color, int numPositions, float frequency = .25)
		  {
			  for (int i = 0; i < numPositions; i++)
			  {
				  uint8_t random = random8(1, 255);
				  if (random < 255 * frequency)
    2c4a:	b2db      	uxtb	r3, r3
    2c4c:	ebc3 10c3 	rsb	r0, r3, r3, lsl #7
    2c50:	11c0      	asrs	r0, r0, #7
    2c52:	3001      	adds	r0, #1
    2c54:	b2c0      	uxtb	r0, r0
    2c56:	f004 fd35 	bl	76c4 <__aeabi_i2f>
    2c5a:	4918      	ldr	r1, [pc, #96]	; (2cbc <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x258>)
    2c5c:	f004 ff24 	bl	7aa8 <__aeabi_fcmplt>
}

/// Generate a 16 bit random number
LIB8STATIC uint16_t random16()
{
    rand16seed = (rand16seed * FASTLED_RAND16_2053) + FASTLED_RAND16_13849;
    2c60:	eb04 2344 	add.w	r3, r4, r4, lsl #9
    2c64:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2c68:	f503 5358 	add.w	r3, r3, #13824	; 0x3600
    2c6c:	3319      	adds	r3, #25
    2c6e:	b29b      	uxth	r3, r3
				  {
					  leds[indexes[random16(numLeds)]] = CRGB(color);
    2c70:	fa1f f28a 	uxth.w	r2, sl
    2c74:	fb03 f202 	mul.w	r2, r3, r2
    2c78:	0c12      	lsrs	r2, r2, #16
		  void SetRandomColor(CRGB leds[], uint16_t indexes[], int numLeds, CRGB color, int numPositions, float frequency = .25)
		  {
			  for (int i = 0; i < numPositions; i++)
			  {
				  uint8_t random = random8(1, 255);
				  if (random < 255 * frequency)
    2c7a:	2800      	cmp	r0, #0
    2c7c:	d09d      	beq.n	2bba <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x156>
    2c7e:	490e      	ldr	r1, [pc, #56]	; (2cb8 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x254>)
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2c80:	f89d 0018 	ldrb.w	r0, [sp, #24]
    2c84:	800b      	strh	r3, [r1, #0]
				  {
					  leds[indexes[random16(numLeds)]] = CRGB(color);
    2c86:	9b05      	ldr	r3, [sp, #20]

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    2c88:	f89d 1019 	ldrb.w	r1, [sp, #25]
    2c8c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    2c90:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2c94:	eb08 0203 	add.w	r2, r8, r3
			  // Get some slight variation in the selected colors.
			  int numColors = random8(4, 8);
			  // Get a random palette to select our colors.
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numColors; i++)
    2c98:	3601      	adds	r6, #1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2c9a:	f808 0003 	strb.w	r0, [r8, r3]
    2c9e:	42b7      	cmp	r7, r6
    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
        b = rhs.b;
    2ca0:	f89d 301a 	ldrb.w	r3, [sp, #26]

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    2ca4:	7051      	strb	r1, [r2, #1]
        b = rhs.b;
    2ca6:	7093      	strb	r3, [r2, #2]
    2ca8:	dc8c      	bgt.n	2bc4 <Meltdown::CMeltdownLED::Confetti(CRGB*, unsigned short*, int, int)+0x160>
			  {
				  SetRandomColor(leds, indexes, numLeds, ColorGradientFromPalette(paletteData.palette, numColors, i, random8(64, 195)), 1, .3);
			  }
		  }
    2caa:	b077      	add	sp, #476	; 0x1dc
    2cac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2cb0:	41e00000 	.word	0x41e00000
    2cb4:	447fc000 	.word	0x447fc000
    2cb8:	1fff8724 	.word	0x1fff8724
    2cbc:	42990000 	.word	0x42990000

00002cc0 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)>:
					  leds[indexes[i]] = CRGB::Black;
				  }
			  }
		  }

		  void RunningLights(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    2cc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2cc4:	4682      	mov	sl, r0
    2cc6:	b087      	sub	sp, #28
		  int SetFrameStep(int val)
		  {
			  if (val < -1) val = -1;
			  if (val == 0) val = 1;

			  gFrameStep = val;
    2cc8:	2003      	movs	r0, #3
    2cca:	f8ca 0030 	str.w	r0, [sl, #48]	; 0x30
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2cce:	f8da 001c 	ldr.w	r0, [sl, #28]
					  leds[indexes[i]] = CRGB::Black;
				  }
			  }
		  }

		  void RunningLights(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    2cd2:	9102      	str	r1, [sp, #8]
    2cd4:	461d      	mov	r5, r3
    2cd6:	4614      	mov	r4, r2
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2cd8:	f004 fcf4 	bl	76c4 <__aeabi_i2f>
    2cdc:	49c4      	ldr	r1, [pc, #784]	; (2ff0 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x330>)
    2cde:	f004 fd45 	bl	776c <__aeabi_fmul>
    2ce2:	49c4      	ldr	r1, [pc, #784]	; (2ff4 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x334>)
    2ce4:	f004 fdf6 	bl	78d4 <__aeabi_fdiv>
    2ce8:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
    2cec:	f004 fc36 	bl	755c <__addsf3>
    2cf0:	f004 ff02 	bl	7af8 <__aeabi_f2iz>
		  {
			  SetFrameStep(3);

			  int length = GetAnalogPattern(4, 40);

			  for (int i = 0; i < numLeds; i++)
    2cf4:	2d00      	cmp	r5, #0
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    2cf6:	9001      	str	r0, [sp, #4]
		  {
			  SetFrameStep(3);

			  int length = GetAnalogPattern(4, 40);

			  for (int i = 0; i < numLeds; i++)
    2cf8:	f340 80cb 	ble.w	2e92 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x1d2>
    2cfc:	46a1      	mov	r9, r4
    2cfe:	eb09 0345 	add.w	r3, r9, r5, lsl #1
    2d02:	4cbd      	ldr	r4, [pc, #756]	; (2ff8 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x338>)
    2d04:	9303      	str	r3, [sp, #12]
    2d06:	f04f 0800 	mov.w	r8, #0
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    2d0a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    2d0c:	2b00      	cmp	r3, #0
    2d0e:	f2c0 8179 	blt.w	3004 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x344>

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    2d12:	f8da 2000 	ldr.w	r2, [sl]
    2d16:	4bb9      	ldr	r3, [pc, #740]	; (2ffc <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x33c>)
				  double redSin;
				  double greenSin;
				  double blueSin;

				  // Modes
				  switch (GetModeNumber(modeOffset))
    2d18:	f8da 1008 	ldr.w	r1, [sl, #8]

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    2d1c:	fba3 0302 	umull	r0, r3, r3, r2
    2d20:	08db      	lsrs	r3, r3, #3
    2d22:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    2d26:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    2d2a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2d2e:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
				  double redSin;
				  double greenSin;
				  double blueSin;

				  // Modes
				  switch (GetModeNumber(modeOffset))
    2d32:	9a10      	ldr	r2, [sp, #64]	; 0x40
    2d34:	4411      	add	r1, r2
    2d36:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    2d38:	3201      	adds	r2, #1
    2d3a:	fb91 f3f2 	sdiv	r3, r1, r2
    2d3e:	fb02 1113 	mls	r1, r2, r3, r1
    2d42:	3901      	subs	r1, #1
    2d44:	2903      	cmp	r1, #3
    2d46:	f200 815d 	bhi.w	3004 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x344>
    2d4a:	e8df f011 	tbh	[pc, r1, lsl #1]
    2d4e:	010d      	.short	0x010d
    2d50:	00a500e2 	.word	0x00a500e2
    2d54:	0004      	.short	0x0004
						  blueSin = (i * length) + (float)GetFrame() / 2;
						  break;
					  }
					  case 4:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2d56:	4640      	mov	r0, r8
    2d58:	f004 fcb4 	bl	76c4 <__aeabi_i2f>
    2d5c:	4606      	mov	r6, r0

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    2d5e:	f8da 002c 	ldr.w	r0, [sl, #44]	; 0x2c
    2d62:	2800      	cmp	r0, #0
    2d64:	f340 816d 	ble.w	3042 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x382>
    2d68:	f004 fcac 	bl	76c4 <__aeabi_i2f>
    2d6c:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
    2d70:	4607      	mov	r7, r0
    2d72:	f004 fcfb 	bl	776c <__aeabi_fmul>
    2d76:	4605      	mov	r5, r0
						  blueSin = (i * length) + (float)GetFrame() / 2;
						  break;
					  }
					  case 4:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2d78:	4639      	mov	r1, r7
    2d7a:	4630      	mov	r0, r6
    2d7c:	f004 fbee 	bl	755c <__addsf3>
    2d80:	f004 fb72 	bl	7468 <__aeabi_f2d>
    2d84:	4602      	mov	r2, r0
						  greenSin = 0;
						  blueSin = (i * length / 2) + (float)GetFrame() / 2;
    2d86:	eb08 70d8 	add.w	r0, r8, r8, lsr #31
						  blueSin = (i * length) + (float)GetFrame() / 2;
						  break;
					  }
					  case 4:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2d8a:	460b      	mov	r3, r1
						  greenSin = 0;
						  blueSin = (i * length / 2) + (float)GetFrame() / 2;
    2d8c:	1040      	asrs	r0, r0, #1
						  blueSin = (i * length) + (float)GetFrame() / 2;
						  break;
					  }
					  case 4:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2d8e:	e9cd 2304 	strd	r2, r3, [sp, #16]
						  greenSin = 0;
						  blueSin = (i * length / 2) + (float)GetFrame() / 2;
    2d92:	f004 fc97 	bl	76c4 <__aeabi_i2f>
    2d96:	4629      	mov	r1, r5
    2d98:	f004 fbe0 	bl	755c <__addsf3>
						  break;
    2d9c:	2300      	movs	r3, #0
    2d9e:	461d      	mov	r5, r3
    2da0:	9300      	str	r3, [sp, #0]
					  }
					  case 4:
					  {
						  redSin = (i * length) + (float)GetFrame();
						  greenSin = 0;
						  blueSin = (i * length / 2) + (float)GetFrame() / 2;
    2da2:	f004 fb61 	bl	7468 <__aeabi_f2d>
						  break;
    2da6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
					  }
					  case 4:
					  {
						  redSin = (i * length) + (float)GetFrame();
						  greenSin = 0;
						  blueSin = (i * length / 2) + (float)GetFrame() / 2;
    2daa:	4606      	mov	r6, r0
    2dac:	460f      	mov	r7, r1
						  break;
    2dae:	46ab      	mov	fp, r5
						  blueSin = (i * length) + (float)GetFrame();
						  break;
					  }
				  }

				  byte redMult = sin8(redSin);
    2db0:	4610      	mov	r0, r2
    2db2:	4619      	mov	r1, r3
    2db4:	f004 fbac 	bl	7510 <__aeabi_d2uiz>
    2db8:	b2c3      	uxtb	r3, r0
/// @param theta input angle from 0-255
/// @returns sin of theta, value between 0 and 255
LIB8STATIC uint8_t sin8_C( uint8_t theta)
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
    2dba:	065a      	lsls	r2, r3, #25
    2dbc:	f140 80fe 	bpl.w	2fbc <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x2fc>
        offset = (uint8_t)255 - offset;
    2dc0:	43da      	mvns	r2, r3
    2dc2:	b2d2      	uxtb	r2, r2
    2dc4:	f3c2 1001 	ubfx	r0, r2, #4, #2
    2dc8:	0040      	lsls	r0, r0, #1
    2dca:	eb04 0e00 	add.w	lr, r4, r0
    }
    offset &= 0x3F; // 0..63

    uint8_t secoffset  = offset & 0x0F; // 0..15
    2dce:	f002 010f 	and.w	r1, r2, #15
    2dd2:	f89e 2001 	ldrb.w	r2, [lr, #1]
    2dd6:	f814 e000 	ldrb.w	lr, [r4, r0]
    2dda:	fb01 2202 	mla	r2, r1, r2, r2
    2dde:	eb0e 1222 	add.w	r2, lr, r2, asr #4
    2de2:	4639      	mov	r1, r7
    2de4:	4630      	mov	r0, r6
    2de6:	b2d7      	uxtb	r7, r2
    2de8:	b25e      	sxtb	r6, r3
    2dea:	f004 fb91 	bl	7510 <__aeabi_d2uiz>
    2dee:	b2c0      	uxtb	r0, r0
    2df0:	f000 0240 	and.w	r2, r0, #64	; 0x40
    2df4:	b27b      	sxtb	r3, r7
    2df6:	b2d2      	uxtb	r2, r2
    2df8:	b241      	sxtb	r1, r0
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    if( theta & 0x80 ) y = -y;
    2dfa:	2e00      	cmp	r6, #0
    2dfc:	bfbc      	itt	lt
    2dfe:	427f      	neglt	r7, r7
    2e00:	b27b      	sxtblt	r3, r7

    y += 128;
    2e02:	f1a3 0780 	sub.w	r7, r3, #128	; 0x80
    2e06:	b2ff      	uxtb	r7, r7
/// @param theta input angle from 0-255
/// @returns sin of theta, value between 0 and 255
LIB8STATIC uint8_t sin8_C( uint8_t theta)
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
    2e08:	2d00      	cmp	r5, #0
    2e0a:	f000 80d2 	beq.w	2fb2 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x2f2>
        offset = (uint8_t)255 - offset;
    2e0e:	ea6f 030b 	mvn.w	r3, fp
    2e12:	b2db      	uxtb	r3, r3
    }
    offset &= 0x3F; // 0..63

    uint8_t secoffset  = offset & 0x0F; // 0..15
    2e14:	f003 050f 	and.w	r5, r3, #15
    if( theta & 0x40) secoffset++;
    2e18:	3501      	adds	r5, #1
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    2e1a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    if( theta & 0x40) secoffset++;

    uint8_t section = offset >> 4; // 0..3
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    2e1e:	111b      	asrs	r3, r3, #4
    2e20:	005b      	lsls	r3, r3, #1
    2e22:	18e6      	adds	r6, r4, r3
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    2e24:	5ce3      	ldrb	r3, [r4, r3]
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    uint8_t b   =  *p;
    p++;
    uint8_t m16 =  *p;
    2e26:	7876      	ldrb	r6, [r6, #1]

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    2e28:	fb16 f505 	smulbb	r5, r6, r5
    2e2c:	eb03 1325 	add.w	r3, r3, r5, asr #4
    if( theta & 0x80 ) y = -y;
    2e30:	9d00      	ldr	r5, [sp, #0]
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    2e32:	b2db      	uxtb	r3, r3
    if( theta & 0x80 ) y = -y;
    2e34:	2d00      	cmp	r5, #0
    2e36:	bfb8      	it	lt
    2e38:	425b      	neglt	r3, r3
    2e3a:	b25b      	sxtb	r3, r3

    y += 128;
    2e3c:	3b80      	subs	r3, #128	; 0x80
    2e3e:	b2db      	uxtb	r3, r3
/// @param theta input angle from 0-255
/// @returns sin of theta, value between 0 and 255
LIB8STATIC uint8_t sin8_C( uint8_t theta)
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
    2e40:	2a00      	cmp	r2, #0
    2e42:	f000 80b1 	beq.w	2fa8 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x2e8>
        offset = (uint8_t)255 - offset;
    2e46:	43c5      	mvns	r5, r0
    2e48:	b2ed      	uxtb	r5, r5
    }
    offset &= 0x3F; // 0..63

    uint8_t secoffset  = offset & 0x0F; // 0..15
    2e4a:	f005 000f 	and.w	r0, r5, #15
    if( theta & 0x40) secoffset++;
    2e4e:	3001      	adds	r0, #1
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    2e50:	f005 053f 	and.w	r5, r5, #63	; 0x3f
    if( theta & 0x40) secoffset++;

    uint8_t section = offset >> 4; // 0..3
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    2e54:	112d      	asrs	r5, r5, #4
    2e56:	006d      	lsls	r5, r5, #1
    2e58:	1962      	adds	r2, r4, r5
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    2e5a:	5d65      	ldrb	r5, [r4, r5]
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    uint8_t b   =  *p;
    p++;
    uint8_t m16 =  *p;
    2e5c:	7852      	ldrb	r2, [r2, #1]
    2e5e:	9e01      	ldr	r6, [sp, #4]

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    2e60:	fb12 f000 	smulbb	r0, r2, r0
    2e64:	eb05 1020 	add.w	r0, r5, r0, asr #4
    if( theta & 0x80 ) y = -y;
    2e68:	2900      	cmp	r1, #0
				  byte greenMult = sin8(greenSin);
				  byte blueMult = sin8(blueSin);

				  leds[indexes[i]] = CRGB(redMult, greenMult, blueMult);
    2e6a:	9d02      	ldr	r5, [sp, #8]
    2e6c:	f839 1b02 	ldrh.w	r1, [r9], #2
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    2e70:	b2c2      	uxtb	r2, r0
    2e72:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    2e76:	4628      	mov	r0, r5
    2e78:	4408      	add	r0, r1
    if( theta & 0x80 ) y = -y;
    2e7a:	bfb8      	it	lt
    2e7c:	4252      	neglt	r2, r2
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    2e7e:	546f      	strb	r7, [r5, r1]
        g = rhs.g;
    2e80:	7043      	strb	r3, [r0, #1]
		  {
			  SetFrameStep(3);

			  int length = GetAnalogPattern(4, 40);

			  for (int i = 0; i < numLeds; i++)
    2e82:	9b03      	ldr	r3, [sp, #12]
    2e84:	b252      	sxtb	r2, r2
        b = rhs.b;
    2e86:	3a80      	subs	r2, #128	; 0x80
    2e88:	454b      	cmp	r3, r9
    2e8a:	44b0      	add	r8, r6
    2e8c:	7082      	strb	r2, [r0, #2]
    2e8e:	f47f af3c 	bne.w	2d0a <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x4a>
				  byte greenMult = sin8(greenSin);
				  byte blueMult = sin8(blueSin);

				  leds[indexes[i]] = CRGB(redMult, greenMult, blueMult);
			  }
		  }
    2e92:	b007      	add	sp, #28
    2e94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
						  break;
					  }
					  case 3:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2e98:	4640      	mov	r0, r8
    2e9a:	f004 fc13 	bl	76c4 <__aeabi_i2f>
    2e9e:	4606      	mov	r6, r0

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    2ea0:	f8da 002c 	ldr.w	r0, [sl, #44]	; 0x2c
    2ea4:	2800      	cmp	r0, #0
    2ea6:	f340 80d4 	ble.w	3052 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x392>
    2eaa:	f004 fc0b 	bl	76c4 <__aeabi_i2f>
    2eae:	4605      	mov	r5, r0
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
						  break;
					  }
					  case 3:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2eb0:	4629      	mov	r1, r5
    2eb2:	4630      	mov	r0, r6
    2eb4:	f004 fb52 	bl	755c <__addsf3>
    2eb8:	f004 fad6 	bl	7468 <__aeabi_f2d>
						  greenSin = (i * length / 4) - (float)GetFrame();
    2ebc:	f1b8 0f00 	cmp.w	r8, #0
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
						  break;
					  }
					  case 3:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2ec0:	4602      	mov	r2, r0
						  greenSin = (i * length / 4) - (float)GetFrame();
    2ec2:	4640      	mov	r0, r8
    2ec4:	bfb8      	it	lt
    2ec6:	f108 0003 	addlt.w	r0, r8, #3
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
						  break;
					  }
					  case 3:
					  {
						  redSin = (i * length) + (float)GetFrame();
    2eca:	460b      	mov	r3, r1
						  greenSin = (i * length / 4) - (float)GetFrame();
    2ecc:	1080      	asrs	r0, r0, #2
    2ece:	e9cd 2304 	strd	r2, r3, [sp, #16]
    2ed2:	f004 fbf7 	bl	76c4 <__aeabi_i2f>
    2ed6:	4629      	mov	r1, r5
    2ed8:	f004 fb3e 	bl	7558 <__aeabi_fsub>
						  blueSin = (i * length) + (float)GetFrame() / 2;
    2edc:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
						  break;
					  }
					  case 3:
					  {
						  redSin = (i * length) + (float)GetFrame();
						  greenSin = (i * length / 4) - (float)GetFrame();
    2ee0:	4683      	mov	fp, r0
						  blueSin = (i * length) + (float)GetFrame() / 2;
    2ee2:	4628      	mov	r0, r5
    2ee4:	f004 fc42 	bl	776c <__aeabi_fmul>
    2ee8:	4631      	mov	r1, r6
					  }
					  case 2:
					  {
						  redSin = (i * length) + (float)GetFrame() * 1.5;
						  greenSin = (i * length) + (float)GetFrame() * 3;
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
    2eea:	f004 fb37 	bl	755c <__addsf3>
    2eee:	f004 fabb 	bl	7468 <__aeabi_f2d>
    2ef2:	4606      	mov	r6, r0
    2ef4:	4658      	mov	r0, fp
    2ef6:	460f      	mov	r7, r1
    2ef8:	f004 fe24 	bl	7b44 <__aeabi_f2uiz>
    2efc:	fa5f fb80 	uxtb.w	fp, r0
    2f00:	fa4f f38b 	sxtb.w	r3, fp
    2f04:	f00b 0540 	and.w	r5, fp, #64	; 0x40
    2f08:	9300      	str	r3, [sp, #0]
    2f0a:	b2ed      	uxtb	r5, r5
						  break;
    2f0c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    2f10:	e74e      	b.n	2db0 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0xf0>
						  blueSin = (i * length) + (float)GetFrame() / 3;
						  break;
					  }
					  case 2:
					  {
						  redSin = (i * length) + (float)GetFrame() * 1.5;
    2f12:	4640      	mov	r0, r8
    2f14:	f004 fbd6 	bl	76c4 <__aeabi_i2f>
    2f18:	4605      	mov	r5, r0

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    2f1a:	f8da 002c 	ldr.w	r0, [sl, #44]	; 0x2c
    2f1e:	2800      	cmp	r0, #0
    2f20:	f340 809d 	ble.w	305e <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x39e>
    2f24:	f004 fbce 	bl	76c4 <__aeabi_i2f>
    2f28:	4935      	ldr	r1, [pc, #212]	; (3000 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x340>)
    2f2a:	4606      	mov	r6, r0
    2f2c:	f004 fc1e 	bl	776c <__aeabi_fmul>
    2f30:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
    2f34:	4607      	mov	r7, r0
    2f36:	4630      	mov	r0, r6
    2f38:	f004 fc18 	bl	776c <__aeabi_fmul>
    2f3c:	4601      	mov	r1, r0
						  blueSin = (i * length) + (float)GetFrame() / 3;
						  break;
					  }
					  case 2:
					  {
						  redSin = (i * length) + (float)GetFrame() * 1.5;
    2f3e:	4628      	mov	r0, r5
    2f40:	f004 fb0c 	bl	755c <__addsf3>
    2f44:	f004 fa90 	bl	7468 <__aeabi_f2d>
    2f48:	4602      	mov	r2, r0
    2f4a:	460b      	mov	r3, r1
						  greenSin = (i * length) + (float)GetFrame() * 3;
    2f4c:	4628      	mov	r0, r5
    2f4e:	4639      	mov	r1, r7
						  blueSin = (i * length) + (float)GetFrame() / 3;
						  break;
					  }
					  case 2:
					  {
						  redSin = (i * length) + (float)GetFrame() * 1.5;
    2f50:	e9cd 2304 	strd	r2, r3, [sp, #16]
						  greenSin = (i * length) + (float)GetFrame() * 3;
    2f54:	f004 fb02 	bl	755c <__addsf3>
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
    2f58:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
						  break;
					  }
					  case 2:
					  {
						  redSin = (i * length) + (float)GetFrame() * 1.5;
						  greenSin = (i * length) + (float)GetFrame() * 3;
    2f5c:	4683      	mov	fp, r0
						  blueSin = (i * length) + (float)GetFrame() / 1.5;
    2f5e:	4630      	mov	r0, r6
    2f60:	f004 fcb8 	bl	78d4 <__aeabi_fdiv>
    2f64:	4629      	mov	r1, r5
    2f66:	e7c0      	b.n	2eea <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x22a>
				  // Modes
				  switch (GetModeNumber(modeOffset))
				  {
					  case 1:
					  {
						  redSin = (i * length) + (float)GetFrame() / 1.5;
    2f68:	4640      	mov	r0, r8
    2f6a:	f004 fbab 	bl	76c4 <__aeabi_i2f>
    2f6e:	4605      	mov	r5, r0

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    2f70:	f8da 002c 	ldr.w	r0, [sl, #44]	; 0x2c
    2f74:	2800      	cmp	r0, #0
    2f76:	dd7b      	ble.n	3070 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x3b0>
    2f78:	f004 fba4 	bl	76c4 <__aeabi_i2f>
    2f7c:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
    2f80:	4606      	mov	r6, r0
    2f82:	f004 fca7 	bl	78d4 <__aeabi_fdiv>
    2f86:	4601      	mov	r1, r0
				  // Modes
				  switch (GetModeNumber(modeOffset))
				  {
					  case 1:
					  {
						  redSin = (i * length) + (float)GetFrame() / 1.5;
    2f88:	4628      	mov	r0, r5
    2f8a:	f004 fae7 	bl	755c <__addsf3>
    2f8e:	f004 fa6b 	bl	7468 <__aeabi_f2d>
    2f92:	4602      	mov	r2, r0
    2f94:	460b      	mov	r3, r1
						  greenSin = (i * length) + (float)GetFrame();
    2f96:	4628      	mov	r0, r5
    2f98:	4631      	mov	r1, r6
				  // Modes
				  switch (GetModeNumber(modeOffset))
				  {
					  case 1:
					  {
						  redSin = (i * length) + (float)GetFrame() / 1.5;
    2f9a:	e9cd 2304 	strd	r2, r3, [sp, #16]
						  greenSin = (i * length) + (float)GetFrame();
    2f9e:	f004 fadd 	bl	755c <__addsf3>
						  blueSin = (i * length) + (float)GetFrame() / 3;
    2fa2:	4917      	ldr	r1, [pc, #92]	; (3000 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x340>)
				  switch (GetModeNumber(modeOffset))
				  {
					  case 1:
					  {
						  redSin = (i * length) + (float)GetFrame() / 1.5;
						  greenSin = (i * length) + (float)GetFrame();
    2fa4:	4683      	mov	fp, r0
    2fa6:	e7da      	b.n	2f5e <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x29e>
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    2fa8:	f000 053f 	and.w	r5, r0, #63	; 0x3f

    uint8_t secoffset  = offset & 0x0F; // 0..15
    2fac:	f000 000f 	and.w	r0, r0, #15
    2fb0:	e750      	b.n	2e54 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x194>
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    2fb2:	f00b 033f 	and.w	r3, fp, #63	; 0x3f

    uint8_t secoffset  = offset & 0x0F; // 0..15
    2fb6:	f00b 050f 	and.w	r5, fp, #15
    2fba:	e730      	b.n	2e1e <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x15e>
    2fbc:	f3c3 1201 	ubfx	r2, r3, #4, #2
    2fc0:	0052      	lsls	r2, r2, #1
    2fc2:	18a1      	adds	r1, r4, r2
    2fc4:	5ca2      	ldrb	r2, [r4, r2]
    2fc6:	f891 e001 	ldrb.w	lr, [r1, #1]
    2fca:	f003 010f 	and.w	r1, r3, #15
    2fce:	fb1e fe01 	smulbb	lr, lr, r1
    2fd2:	4630      	mov	r0, r6
    2fd4:	4639      	mov	r1, r7
    2fd6:	b25e      	sxtb	r6, r3
    2fd8:	eb02 171e 	add.w	r7, r2, lr, lsr #4
    2fdc:	f004 fa98 	bl	7510 <__aeabi_d2uiz>
    2fe0:	b2c0      	uxtb	r0, r0
    2fe2:	b2ff      	uxtb	r7, r7
    2fe4:	f000 0240 	and.w	r2, r0, #64	; 0x40
    2fe8:	b27b      	sxtb	r3, r7
    2fea:	b2d2      	uxtb	r2, r2
    2fec:	b241      	sxtb	r1, r0
    2fee:	e704      	b.n	2dfa <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x13a>
    2ff0:	42100000 	.word	0x42100000
    2ff4:	447fc000 	.word	0x447fc000
    2ff8:	00009454 	.word	0x00009454
    2ffc:	cccccccd 	.word	0xcccccccd
    3000:	40400000 	.word	0x40400000
						  break;
					  }
					  default:
					  {
						  redSin = 0;
						  greenSin = (i * length) + (float)GetFrame();
    3004:	4640      	mov	r0, r8
    3006:	f004 fb5d 	bl	76c4 <__aeabi_i2f>
    300a:	4605      	mov	r5, r0

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    300c:	f8da 002c 	ldr.w	r0, [sl, #44]	; 0x2c
    3010:	2800      	cmp	r0, #0
    3012:	dd34      	ble.n	307e <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x3be>
    3014:	f004 fb56 	bl	76c4 <__aeabi_i2f>
    3018:	4601      	mov	r1, r0
						  break;
					  }
					  default:
					  {
						  redSin = 0;
						  greenSin = (i * length) + (float)GetFrame();
    301a:	4628      	mov	r0, r5
    301c:	f004 fa9e 	bl	755c <__addsf3>
    3020:	f004 fd90 	bl	7b44 <__aeabi_f2uiz>
    3024:	fa5f fb80 	uxtb.w	fp, r0
    3028:	f00b 0540 	and.w	r5, fp, #64	; 0x40
    302c:	fa4f f38b 	sxtb.w	r3, fp
    3030:	2600      	movs	r6, #0
    3032:	b2ed      	uxtb	r5, r5
    3034:	9300      	str	r3, [sp, #0]
    3036:	4619      	mov	r1, r3
    3038:	462a      	mov	r2, r5
    303a:	4658      	mov	r0, fp
    303c:	4633      	mov	r3, r6
    303e:	4637      	mov	r7, r6
    3040:	e6db      	b.n	2dfa <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x13a>

		  long GetFrame()
		  {
			  if (gFrame < 1)
			  {
				  gFrame = 1;
    3042:	2301      	movs	r3, #1
    3044:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    3048:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
    304c:	f04f 557c 	mov.w	r5, #1056964608	; 0x3f000000
    3050:	e692      	b.n	2d78 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0xb8>
    3052:	2301      	movs	r3, #1
    3054:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    3058:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
    305c:	e728      	b.n	2eb0 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x1f0>
    305e:	2301      	movs	r3, #1
    3060:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    3064:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
    3068:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
    306c:	4f07      	ldr	r7, [pc, #28]	; (308c <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x3cc>)
    306e:	e766      	b.n	2f3e <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x27e>
    3070:	2301      	movs	r3, #1
    3072:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    3076:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
    307a:	4905      	ldr	r1, [pc, #20]	; (3090 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x3d0>)
    307c:	e784      	b.n	2f88 <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x2c8>
    307e:	2301      	movs	r3, #1
    3080:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    3084:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    3088:	e7c7      	b.n	301a <Meltdown::CMeltdownLED::RunningLights(CRGB*, unsigned short*, int, int)+0x35a>
    308a:	bf00      	nop
    308c:	40400000 	.word	0x40400000
    3090:	3f2aaaab 	.word	0x3f2aaaab

00003094 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)>:
			  }

			  counter++;
		  }

		  void Sinelon(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3094:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3098:	4682      	mov	sl, r0
    309a:	b083      	sub	sp, #12
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    309c:	69c0      	ldr	r0, [r0, #28]
			  }

			  counter++;
		  }

		  void Sinelon(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    309e:	4699      	mov	r9, r3
    30a0:	4690      	mov	r8, r2
    30a2:	460c      	mov	r4, r1
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    30a4:	f004 fb0e 	bl	76c4 <__aeabi_i2f>
    30a8:	495a      	ldr	r1, [pc, #360]	; (3214 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x180>)
    30aa:	f004 fb5f 	bl	776c <__aeabi_fmul>
    30ae:	495a      	ldr	r1, [pc, #360]	; (3218 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x184>)
    30b0:	f004 fc10 	bl	78d4 <__aeabi_fdiv>
    30b4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    30b8:	f004 fa50 	bl	755c <__addsf3>
    30bc:	f004 fd1c 	bl	7af8 <__aeabi_f2iz>
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    30c0:	f1b9 0f00 	cmp.w	r9, #0
    30c4:	dd22      	ble.n	310c <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x78>
    30c6:	f1c0 01ff 	rsb	r1, r0, #255	; 0xff
    30ca:	b2c9      	uxtb	r1, r1
    30cc:	3101      	adds	r1, #1
    30ce:	4640      	mov	r0, r8
    30d0:	eb08 0e49 	add.w	lr, r8, r9, lsl #1
			  {
				  int scale = 255 - fade;
				  (leds[indexes[i]]).nscale8(scale);
    30d4:	f830 3b02 	ldrh.w	r3, [r0], #2
    30d8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    30dc:	18e2      	adds	r2, r4, r3
LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    30de:	f814 c003 	ldrb.w	ip, [r4, r3]
    30e2:	fb01 fc0c 	mul.w	ip, r1, ip
    30e6:	ea4f 2c2c 	mov.w	ip, ip, asr #8
    30ea:	f804 c003 	strb.w	ip, [r4, r3]
    g = (((uint16_t)g) * scale_fixed) >> 8;
    30ee:	f892 c001 	ldrb.w	ip, [r2, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    30f2:	7893      	ldrb	r3, [r2, #2]
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    30f4:	fb01 fc0c 	mul.w	ip, r1, ip
    b = (((uint16_t)b) * scale_fixed) >> 8;
    30f8:	fb01 f303 	mul.w	r3, r1, r3
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    30fc:	ea4f 2c2c 	mov.w	ip, ip, asr #8
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3100:	121b      	asrs	r3, r3, #8
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    3102:	4570      	cmp	r0, lr
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3104:	f882 c001 	strb.w	ip, [r2, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3108:	7093      	strb	r3, [r2, #2]
    310a:	d1e3      	bne.n	30d4 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x40>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    310c:	4b43      	ldr	r3, [pc, #268]	; (321c <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x188>)
			  // Display a dot moving back and forth in a sin wave pattern.
			  int fade = GetAnalogPattern(2, 30);
			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  uint8_t beats = 8;
			  if (!gMirror)
    310e:	f89a 1038 	ldrb.w	r1, [sl, #56]	; 0x38
    3112:	681b      	ldr	r3, [r3, #0]
    3114:	9301      	str	r3, [sp, #4]
	return ret;
    3116:	9a01      	ldr	r2, [sp, #4]
    // and then use a simple, fast bit-shift to divide by 65536.
    //
    // The ratio 65536:60000 is 279.620266667:256; we'll call it 280:256.
    // The conversion is accurate to about 0.05%, more or less,
    // e.g. if you ask for "120 BPM", you'll get about "119.93".
    return (((GET_MILLIS()) - timebase) * beats_per_minute_88 * 280) >> 16;
    3118:	f44f 738c 	mov.w	r3, #280	; 0x118
    311c:	2900      	cmp	r1, #0
    311e:	fb03 fe02 	mul.w	lr, r3, r2
    3122:	bf14      	ite	ne
    3124:	f44f 6300 	movne.w	r3, #2048	; 0x800
    3128:	f44f 6380 	moveq.w	r3, #1024	; 0x400
    312c:	fb03 fe0e 	mul.w	lr, r3, lr
    3130:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
			  {
				  beats = 4;
			  }

			  uint16_t index = beatsin16(beats, 0, numLeds - 1);
    3134:	f109 30ff 	add.w	r0, r9, #4294967295
    { 0, 6393, 12539, 18204, 23170, 27245, 30273, 32137 };
    static const uint8_t slope[] =
    { 49, 48, 44, 38, 31, 23, 14, 4 };

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    if( theta & 0x4000 ) offset = 2047 - offset;
    3138:	f41e 4f80 	tst.w	lr, #16384	; 0x4000
    static const uint16_t base[] =
    { 0, 6393, 12539, 18204, 23170, 27245, 30273, 32137 };
    static const uint8_t slope[] =
    { 49, 48, 44, 38, 31, 23, 14, 4 };

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    313c:	f3ce 03ca 	ubfx	r3, lr, #3, #11
    3140:	b281      	uxth	r1, r0
    if( theta & 0x4000 ) offset = 2047 - offset;
    3142:	d003      	beq.n	314c <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0xb8>
    3144:	f5c3 63ff 	rsb	r3, r3, #2040	; 0x7f8
    3148:	3307      	adds	r3, #7
    314a:	b29b      	uxth	r3, r3

    uint8_t section = offset / 256; // 0..7
    uint16_t b   = base[section];
    314c:	0a1a      	lsrs	r2, r3, #8
    uint8_t  m   = slope[section];
    314e:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 3228 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x194>

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    if( theta & 0x4000 ) offset = 2047 - offset;

    uint8_t section = offset / 256; // 0..7
    uint16_t b   = base[section];
    3152:	4833      	ldr	r0, [pc, #204]	; (3220 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x18c>)
    uint8_t  m   = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t  y  = mx + b;
    3154:	f81c c002 	ldrb.w	ip, [ip, r2]
    3158:	f830 0012 	ldrh.w	r0, [r0, r2, lsl #1]
    315c:	f3c3 0246 	ubfx	r2, r3, #1, #7
    3160:	fb0c 0302 	mla	r3, ip, r2, r0

    if( theta & 0x8000 ) y = -y;
    3164:	f41e 4f00 	tst.w	lr, #32768	; 0x8000
    uint8_t  m   = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t  y  = mx + b;
    3168:	b29b      	uxth	r3, r3

    if( theta & 0x8000 ) y = -y;
    316a:	bf18      	it	ne
    316c:	425b      	negne	r3, r3
    316e:	b21b      	sxth	r3, r3
    3170:	f8da e008 	ldr.w	lr, [sl, #8]

			  GenerateSinelons(leds, indexes, numLeds, GetModeNumber() + 2, index);
    3174:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
    3178:	b298      	uxth	r0, r3
    317a:	f10e 0202 	add.w	r2, lr, #2
    317e:	fb01 0000 	mla	r0, r1, r0, r0
			  }
		  }

		  void GenerateSinelons(CRGB leds[], uint16_t indexes[], int numLeds, int numSinelons, int pos)
		  {
			  for (int i = 0; i < numSinelons; i++)
    3182:	2a00      	cmp	r2, #0
				  beats = 4;
			  }

			  uint16_t index = beatsin16(beats, 0, numLeds - 1);

			  GenerateSinelons(leds, indexes, numLeds, GetModeNumber() + 2, index);
    3184:	ea4f 4010 	mov.w	r0, r0, lsr #16
			  }
		  }

		  void GenerateSinelons(CRGB leds[], uint16_t indexes[], int numLeds, int numSinelons, int pos)
		  {
			  for (int i = 0; i < numSinelons; i++)
    3188:	dd2c      	ble.n	31e4 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x150>
    318a:	fb99 f2f2 	sdiv	r2, r9, r2
    318e:	f10e 0e07 	add.w	lr, lr, #7
    3192:	4410      	add	r0, r2
    3194:	2305      	movs	r3, #5
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    3196:	4923      	ldr	r1, [pc, #140]	; (3224 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x190>)

		  void GenerateSinelons(CRGB leds[], uint16_t indexes[], int numLeds, int numSinelons, int pos)
		  {
			  for (int i = 0; i < numSinelons; i++)
			  {
				  uint16_t index = indexes[(pos + (int)(numLeds / numSinelons) * (i + 1)) % numLeds];
    3198:	fb90 faf9 	sdiv	sl, r0, r9
    319c:	fb09 0a1a 	mls	sl, r9, sl, r0
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    31a0:	fb81 b103 	smull	fp, r1, r1, r3
			  {
				  uint16_t index = indexes[(pos + (int)(numLeds / numSinelons) * (i + 1)) % numLeds];
				  // Let's get some contrast up in here!
				  int rainbowOffset = 5;

				  leds[index] = GetRainbowColor(i, rainbowOffset);
    31a4:	f838 a01a 	ldrh.w	sl, [r8, sl, lsl #1]
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    31a8:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
    31ac:	eb01 0141 	add.w	r1, r1, r1, lsl #1
			  {
				  uint16_t index = indexes[(pos + (int)(numLeds / numSinelons) * (i + 1)) % numLeds];
				  // Let's get some contrast up in here!
				  int rainbowOffset = 5;

				  leds[index] = GetRainbowColor(i, rainbowOffset);
    31b0:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    31b4:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
			  {
				  uint16_t index = indexes[(pos + (int)(numLeds / numSinelons) * (i + 1)) % numLeds];
				  // Let's get some contrast up in here!
				  int rainbowOffset = 5;

				  leds[index] = GetRainbowColor(i, rainbowOffset);
    31b8:	eb04 0b0a 	add.w	fp, r4, sl
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    31bc:	2905      	cmp	r1, #5
    31be:	d807      	bhi.n	31d0 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x13c>
    31c0:	e8df f001 	tbb	[pc, r1]
    31c4:	1b1f2303 	.word	0x1b1f2303
    31c8:	1317      	.short	0x1317
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    31ca:	27ae      	movs	r7, #174	; 0xae
    31cc:	2500      	movs	r5, #0
    31ce:	26be      	movs	r6, #190	; 0xbe
    31d0:	3301      	adds	r3, #1
			  }
		  }

		  void GenerateSinelons(CRGB leds[], uint16_t indexes[], int numLeds, int numSinelons, int pos)
		  {
			  for (int i = 0; i < numSinelons; i++)
    31d2:	459e      	cmp	lr, r3
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    31d4:	f804 600a 	strb.w	r6, [r4, sl]
    31d8:	4410      	add	r0, r2
        g = rhs.g;
    31da:	f88b 5001 	strb.w	r5, [fp, #1]
        b = rhs.b;
    31de:	f88b 7002 	strb.w	r7, [fp, #2]
    31e2:	d1d8      	bne.n	3196 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x102>
			  }

			  uint16_t index = beatsin16(beats, 0, numLeds - 1);

			  GenerateSinelons(leds, indexes, numLeds, GetModeNumber() + 2, index);
		  }
    31e4:	b003      	add	sp, #12
    31e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    31ea:	2700      	movs	r7, #0
    31ec:	2562      	movs	r5, #98	; 0x62
    31ee:	26ff      	movs	r6, #255	; 0xff
    31f0:	e7ee      	b.n	31d0 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x13c>
    31f2:	25ff      	movs	r5, #255	; 0xff
    31f4:	462e      	mov	r6, r5
    31f6:	2700      	movs	r7, #0
    31f8:	e7ea      	b.n	31d0 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x13c>
    31fa:	2700      	movs	r7, #0
    31fc:	25e6      	movs	r5, #230	; 0xe6
    31fe:	2637      	movs	r6, #55	; 0x37
    3200:	e7e6      	b.n	31d0 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x13c>
    3202:	27e2      	movs	r7, #226	; 0xe2
    3204:	25cf      	movs	r5, #207	; 0xcf
    3206:	2608      	movs	r6, #8
    3208:	e7e2      	b.n	31d0 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x13c>
    320a:	27c3      	movs	r7, #195	; 0xc3
    320c:	2500      	movs	r5, #0
    320e:	263e      	movs	r6, #62	; 0x3e
    3210:	e7de      	b.n	31d0 <Meltdown::CMeltdownLED::Sinelon(CRGB*, unsigned short*, int, int)+0x13c>
    3212:	bf00      	nop
    3214:	41e00000 	.word	0x41e00000
    3218:	447fc000 	.word	0x447fc000
    321c:	1fffb440 	.word	0x1fffb440
    3220:	00009444 	.word	0x00009444
    3224:	2aaaaaab 	.word	0x2aaaaaab
    3228:	00009468 	.word	0x00009468

0000322c <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)>:
			  {
				  leds[indexes[i]] = ColorGradientFromPalette(paletteData.palette, numLeds, i + GetFrameOffset(.15), beat - (i * 10), paletteData.blendType);
			  }
		  }

		  void Juggle(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    322c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3230:	4604      	mov	r4, r0
    3232:	b085      	sub	sp, #20
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    3234:	69c0      	ldr	r0, [r0, #28]
			  {
				  leds[indexes[i]] = ColorGradientFromPalette(paletteData.palette, numLeds, i + GetFrameOffset(.15), beat - (i * 10), paletteData.blendType);
			  }
		  }

		  void Juggle(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3236:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
    323a:	469b      	mov	fp, r3
    323c:	4691      	mov	r9, r2
    323e:	460d      	mov	r5, r1
			  gAnalogPattern = MeltdownSerial.GetAnalogValue(pin, gAnalogPattern);
			  return gAnalogPattern;
		  }
		  int GetAnalogPattern() { return gAnalogPattern; }

		  int GetAnalogPattern(int minVal, int maxVal) { return mapFloat(gAnalogPattern, 0, 1023, minVal, maxVal); }
    3240:	f004 fa40 	bl	76c4 <__aeabi_i2f>
    3244:	4965      	ldr	r1, [pc, #404]	; (33dc <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1b0>)
    3246:	f004 fa91 	bl	776c <__aeabi_fmul>
    324a:	4965      	ldr	r1, [pc, #404]	; (33e0 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1b4>)
    324c:	f004 fb42 	bl	78d4 <__aeabi_fdiv>
    3250:	4964      	ldr	r1, [pc, #400]	; (33e4 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1b8>)
    3252:	f004 f983 	bl	755c <__addsf3>
    3256:	f004 fc4f 	bl	7af8 <__aeabi_f2iz>
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    325a:	f1bb 0f00 	cmp.w	fp, #0
    325e:	dd1c      	ble.n	329a <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x6e>
    3260:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
    3264:	b2c0      	uxtb	r0, r0
    3266:	3001      	adds	r0, #1
    3268:	46ce      	mov	lr, r9
    326a:	eb09 0c4b 	add.w	ip, r9, fp, lsl #1
			  {
				  int scale = 255 - fade;
				  (leds[indexes[i]]).nscale8(scale);
    326e:	f83e 3b02 	ldrh.w	r3, [lr], #2
    3272:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3276:	18e9      	adds	r1, r5, r3
LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    3278:	5cea      	ldrb	r2, [r5, r3]
    327a:	fb00 f202 	mul.w	r2, r0, r2
    327e:	1212      	asrs	r2, r2, #8
    3280:	54ea      	strb	r2, [r5, r3]
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3282:	784a      	ldrb	r2, [r1, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3284:	788b      	ldrb	r3, [r1, #2]
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3286:	fb00 f202 	mul.w	r2, r0, r2
    b = (((uint16_t)b) * scale_fixed) >> 8;
    328a:	fb00 f303 	mul.w	r3, r0, r3
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    328e:	1212      	asrs	r2, r2, #8
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3290:	121b      	asrs	r3, r3, #8
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    3292:	45f4      	cmp	ip, lr
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3294:	704a      	strb	r2, [r1, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3296:	708b      	strb	r3, [r1, #2]
    3298:	d1e9      	bne.n	326e <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x42>
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    329a:	f1ba 0f00 	cmp.w	sl, #0
    329e:	f2c0 809a 	blt.w	33d6 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1aa>

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    32a2:	6821      	ldr	r1, [r4, #0]
    32a4:	4b50      	ldr	r3, [pc, #320]	; (33e8 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1bc>)
    32a6:	68a2      	ldr	r2, [r4, #8]
    32a8:	fba3 0301 	umull	r0, r3, r3, r1
    32ac:	08db      	lsrs	r3, r3, #3
    32ae:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    32b2:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
    32b6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    32ba:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    32be:	4452      	add	r2, sl
    32c0:	6d19      	ldr	r1, [r3, #80]	; 0x50
    32c2:	3101      	adds	r1, #1
    32c4:	fb92 f3f1 	sdiv	r3, r2, r1
    32c8:	fb01 2213 	mls	r2, r1, r3, r2
    32cc:	3a01      	subs	r2, #1
    32ce:	2a02      	cmp	r2, #2
    32d0:	f200 8081 	bhi.w	33d6 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1aa>
    32d4:	4b45      	ldr	r3, [pc, #276]	; (33ec <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1c0>)
    32d6:	f853 e022 	ldr.w	lr, [r3, r2, lsl #2]
			  case 3:
				  numBalls = 6;
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
    32da:	f1be 0f00 	cmp.w	lr, #0
    32de:	dd5a      	ble.n	3396 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x16a>
    32e0:	f10b 33ff 	add.w	r3, fp, #4294967295
    32e4:	b29b      	uxth	r3, r3
    32e6:	f8df b114 	ldr.w	fp, [pc, #276]	; 33fc <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1d0>
    32ea:	9701      	str	r7, [sp, #4]
    32ec:	f103 0a01 	add.w	sl, r3, #1
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    32f0:	2200      	movs	r2, #0
    32f2:	f44f 7c8c 	mov.w	ip, #280	; 0x118
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    32f6:	f8db 1000 	ldr.w	r1, [fp]
    32fa:	9103      	str	r1, [sp, #12]
    32fc:	1d53      	adds	r3, r2, #5
    32fe:	b29b      	uxth	r3, r3

/// beat16 generates a 16-bit 'sawtooth' wave at a given BPM
LIB8STATIC uint16_t beat16( accum88 beats_per_minute, uint32_t timebase = 0)
{
    // Convert simple 8-bit BPM's to full Q8.8 accum88's if needed
    if( beats_per_minute < 256) beats_per_minute <<= 8;
    3300:	2bff      	cmp	r3, #255	; 0xff
	return ret;
    3302:	9903      	ldr	r1, [sp, #12]
    3304:	bf9c      	itt	ls
    3306:	021b      	lslls	r3, r3, #8
    3308:	b29b      	uxthls	r3, r3
    // and then use a simple, fast bit-shift to divide by 65536.
    //
    // The ratio 65536:60000 is 279.620266667:256; we'll call it 280:256.
    // The conversion is accurate to about 0.05%, more or less,
    // e.g. if you ask for "120 BPM", you'll get about "119.93".
    return (((GET_MILLIS()) - timebase) * beats_per_minute_88 * 280) >> 16;
    330a:	fb0c f101 	mul.w	r1, ip, r1
    330e:	fb03 f301 	mul.w	r3, r3, r1
    3312:	0c18      	lsrs	r0, r3, #16
    { 0, 6393, 12539, 18204, 23170, 27245, 30273, 32137 };
    static const uint8_t slope[] =
    { 49, 48, 44, 38, 31, 23, 14, 4 };

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    if( theta & 0x4000 ) offset = 2047 - offset;
    3314:	0444      	lsls	r4, r0, #17
    static const uint16_t base[] =
    { 0, 6393, 12539, 18204, 23170, 27245, 30273, 32137 };
    static const uint8_t slope[] =
    { 49, 48, 44, 38, 31, 23, 14, 4 };

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    3316:	f3c0 01ca 	ubfx	r1, r0, #3, #11
    if( theta & 0x4000 ) offset = 2047 - offset;
    331a:	d503      	bpl.n	3324 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0xf8>
    331c:	f5c1 61ff 	rsb	r1, r1, #2040	; 0x7f8
    3320:	3107      	adds	r1, #7
    3322:	b289      	uxth	r1, r1

    uint8_t section = offset / 256; // 0..7
    uint16_t b   = base[section];
    3324:	0a0c      	lsrs	r4, r1, #8
    uint8_t  m   = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t  y  = mx + b;
    3326:	4b32      	ldr	r3, [pc, #200]	; (33f0 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1c4>)
    3328:	4f32      	ldr	r7, [pc, #200]	; (33f4 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1c8>)
    332a:	5d1b      	ldrb	r3, [r3, r4]
    332c:	f837 4014 	ldrh.w	r4, [r7, r4, lsl #1]
    3330:	f3c1 0146 	ubfx	r1, r1, #1, #7
    3334:	fb03 4301 	mla	r3, r3, r1, r4
    3338:	b29b      	uxth	r3, r3

    if( theta & 0x8000 ) y = -y;
    333a:	0401      	lsls	r1, r0, #16
    333c:	bf48      	it	mi
    333e:	425b      	negmi	r3, r3
    3340:	b21b      	sxth	r3, r3
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
    3342:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
    3346:	b29b      	uxth	r3, r3
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    3348:	482b      	ldr	r0, [pc, #172]	; (33f8 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x1cc>)
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
    334a:	fb0a f303 	mul.w	r3, sl, r3
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    334e:	1d11      	adds	r1, r2, #4
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
    3350:	0c1b      	lsrs	r3, r3, #16
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    3352:	fb80 0401 	smull	r0, r4, r0, r1
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
    3356:	f839 0013 	ldrh.w	r0, [r9, r3, lsl #1]
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    335a:	eba4 73e1 	sub.w	r3, r4, r1, asr #31
    335e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
    3362:	eb00 0040 	add.w	r0, r0, r0, lsl #1
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    3366:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
    336a:	182b      	adds	r3, r5, r0
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    336c:	2905      	cmp	r1, #5
    336e:	d809      	bhi.n	3384 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x158>
    3370:	e8df f001 	tbb	[pc, r1]
    3374:	1f252b03 	.word	0x1f252b03
    3378:	141a      	.short	0x141a
    337a:	21be      	movs	r1, #190	; 0xbe
    337c:	f04f 08ae 	mov.w	r8, #174	; 0xae
    3380:	2600      	movs	r6, #0
    3382:	9101      	str	r1, [sp, #4]
			  case 3:
				  numBalls = 6;
				  break;
			  }

			  for (int i = 0; i < numBalls; i++)
    3384:	3201      	adds	r2, #1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3386:	f89d 1004 	ldrb.w	r1, [sp, #4]
    338a:	5429      	strb	r1, [r5, r0]
    338c:	4572      	cmp	r2, lr
        g = rhs.g;
    338e:	705e      	strb	r6, [r3, #1]
        b = rhs.b;
    3390:	f883 8002 	strb.w	r8, [r3, #2]
    3394:	dbaf      	blt.n	32f6 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0xca>
			  {
				  leds[indexes[beatsin16(i + 5, 0, numLeds - 1)]] = GetRainbowColor(i + 4);
			  }
		  }
    3396:	b005      	add	sp, #20
    3398:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    339c:	21ff      	movs	r1, #255	; 0xff
    339e:	f04f 0800 	mov.w	r8, #0
    33a2:	2662      	movs	r6, #98	; 0x62
    33a4:	9101      	str	r1, [sp, #4]
    33a6:	e7ed      	b.n	3384 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x158>
    33a8:	26ff      	movs	r6, #255	; 0xff
    33aa:	9601      	str	r6, [sp, #4]
    33ac:	f04f 0800 	mov.w	r8, #0
    33b0:	e7e8      	b.n	3384 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x158>
    33b2:	2137      	movs	r1, #55	; 0x37
    33b4:	f04f 0800 	mov.w	r8, #0
    33b8:	26e6      	movs	r6, #230	; 0xe6
    33ba:	9101      	str	r1, [sp, #4]
    33bc:	e7e2      	b.n	3384 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x158>
    33be:	2108      	movs	r1, #8
    33c0:	f04f 08e2 	mov.w	r8, #226	; 0xe2
    33c4:	26cf      	movs	r6, #207	; 0xcf
    33c6:	9101      	str	r1, [sp, #4]
    33c8:	e7dc      	b.n	3384 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x158>
    33ca:	213e      	movs	r1, #62	; 0x3e
    33cc:	f04f 08c3 	mov.w	r8, #195	; 0xc3
    33d0:	2600      	movs	r6, #0
    33d2:	9101      	str	r1, [sp, #4]
    33d4:	e7d6      	b.n	3384 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0x158>
			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  int numBalls = 3;

			  // Modes
			  switch (GetModeNumber(modeOffset))
    33d6:	f04f 0e03 	mov.w	lr, #3
    33da:	e781      	b.n	32e0 <Meltdown::CMeltdownLED::Juggle(CRGB*, unsigned short*, int, int)+0xb4>
    33dc:	42c20000 	.word	0x42c20000
    33e0:	447fc000 	.word	0x447fc000
    33e4:	40400000 	.word	0x40400000
    33e8:	cccccccd 	.word	0xcccccccd
    33ec:	0000945c 	.word	0x0000945c
    33f0:	00009468 	.word	0x00009468
    33f4:	00009444 	.word	0x00009444
    33f8:	2aaaaaab 	.word	0x2aaaaaab
    33fc:	1fffb440 	.word	0x1fffb440

00003400 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)>:
			  MeltdownPattern pattern = gPatterns[GetPatternNumber(patternOffset)];

			  (this->*(pattern.patternFunc))(leds, indexes, numLeds, modeOffset);
		  }

		  void BlendColor(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3400:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3404:	4604      	mov	r4, r0
    3406:	b08b      	sub	sp, #44	; 0x2c
		  {
			  int speed = beatsin8(GetAnalogPattern(16, 48), 0, 255);
    3408:	69c0      	ldr	r0, [r0, #28]
			  MeltdownPattern pattern = gPatterns[GetPatternNumber(patternOffset)];

			  (this->*(pattern.patternFunc))(leds, indexes, numLeds, modeOffset);
		  }

		  void BlendColor(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    340a:	9e14      	ldr	r6, [sp, #80]	; 0x50
    340c:	4692      	mov	sl, r2
    340e:	461f      	mov	r7, r3
    3410:	460d      	mov	r5, r1
		  {
			  int speed = beatsin8(GetAnalogPattern(16, 48), 0, 255);
    3412:	f004 f957 	bl	76c4 <__aeabi_i2f>
    3416:	f04f 4184 	mov.w	r1, #1107296256	; 0x42000000
    341a:	f004 f9a7 	bl	776c <__aeabi_fmul>
    341e:	49cc      	ldr	r1, [pc, #816]	; (3750 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x350>)
    3420:	f004 fa58 	bl	78d4 <__aeabi_fdiv>
    3424:	f04f 4183 	mov.w	r1, #1098907648	; 0x41800000
    3428:	f004 f898 	bl	755c <__addsf3>
    342c:	f004 fb64 	bl	7af8 <__aeabi_f2iz>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3430:	4bc8      	ldr	r3, [pc, #800]	; (3754 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x354>)
    3432:	681b      	ldr	r3, [r3, #0]
    3434:	9309      	str	r3, [sp, #36]	; 0x24
    3436:	b280      	uxth	r0, r0

/// beat16 generates a 16-bit 'sawtooth' wave at a given BPM
LIB8STATIC uint16_t beat16( accum88 beats_per_minute, uint32_t timebase = 0)
{
    // Convert simple 8-bit BPM's to full Q8.8 accum88's if needed
    if( beats_per_minute < 256) beats_per_minute <<= 8;
    3438:	28ff      	cmp	r0, #255	; 0xff
	return ret;
    343a:	9909      	ldr	r1, [sp, #36]	; 0x24
    343c:	bf98      	it	ls
    343e:	0200      	lslls	r0, r0, #8
    3440:	f44f 738c 	mov.w	r3, #280	; 0x118
    3444:	bf98      	it	ls
    3446:	b280      	uxthls	r0, r0
    3448:	fb03 f101 	mul.w	r1, r3, r1
    344c:	fb00 f101 	mul.w	r1, r0, r1
    3450:	0e09      	lsrs	r1, r1, #24
}

/// beat8 generates an 8-bit 'sawtooth' wave at a given BPM
LIB8STATIC uint8_t beat8( accum88 beats_per_minute, uint32_t timebase = 0)
{
    return beat16( beats_per_minute, timebase) >> 8;
    3452:	b2ca      	uxtb	r2, r1
/// @param theta input angle from 0-255
/// @returns sin of theta, value between 0 and 255
LIB8STATIC uint8_t sin8_C( uint8_t theta)
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
    3454:	0650      	lsls	r0, r2, #25
    3456:	f140 81ca 	bpl.w	37ee <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x3ee>
        offset = (uint8_t)255 - offset;
    345a:	43d3      	mvns	r3, r2
    345c:	b2db      	uxtb	r3, r3
    }
    offset &= 0x3F; // 0..63

    uint8_t secoffset  = offset & 0x0F; // 0..15
    345e:	f003 020f 	and.w	r2, r3, #15
    if( theta & 0x40) secoffset++;
    3462:	3201      	adds	r2, #1
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    3464:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    if( theta & 0x40) secoffset++;

    uint8_t section = offset >> 4; // 0..3
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    3468:	48bb      	ldr	r0, [pc, #748]	; (3758 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x358>)
    346a:	111b      	asrs	r3, r3, #4
    346c:	005b      	lsls	r3, r3, #1
    346e:	eb00 0e03 	add.w	lr, r0, r3
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    3472:	5cc3      	ldrb	r3, [r0, r3]
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    uint8_t b   =  *p;
    p++;
    uint8_t m16 =  *p;
    3474:	f89e 0001 	ldrb.w	r0, [lr, #1]

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    3478:	fb10 f202 	smulbb	r2, r0, r2
    347c:	eb03 1222 	add.w	r2, r3, r2, asr #4
    3480:	b2d2      	uxtb	r2, r2
    if( theta & 0x80 ) y = -y;
    3482:	060b      	lsls	r3, r1, #24
    3484:	bf48      	it	mi
    3486:	4252      	negmi	r2, r2
    3488:	b252      	sxtb	r2, r2
///  4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC_ALWAYS_INLINE uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * (1+(uint16_t)(scale))) >> 8;
    348a:	3a80      	subs	r2, #128	; 0x80
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    348c:	2e00      	cmp	r6, #0
    348e:	b2d2      	uxtb	r2, r2
    3490:	f2c0 81b2 	blt.w	37f8 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x3f8>

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    3494:	6821      	ldr	r1, [r4, #0]
    3496:	4bb1      	ldr	r3, [pc, #708]	; (375c <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x35c>)
		  void BlendColor(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
		  {
			  int speed = beatsin8(GetAnalogPattern(16, 48), 0, 255);

			  // Modes
			  FillGradients(leds, indexes, numLeds, GetModeNumber(modeOffset) + 1, speed);
    3498:	68a0      	ldr	r0, [r4, #8]

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    349a:	fba3 e301 	umull	lr, r3, r3, r1
    349e:	08db      	lsrs	r3, r3, #3
    34a0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    34a4:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
    34a8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    34ac:	eb04 0483 	add.w	r4, r4, r3, lsl #2
		  void BlendColor(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
		  {
			  int speed = beatsin8(GetAnalogPattern(16, 48), 0, 255);

			  // Modes
			  FillGradients(leds, indexes, numLeds, GetModeNumber(modeOffset) + 1, speed);
    34b0:	4430      	add	r0, r6
    34b2:	6d23      	ldr	r3, [r4, #80]	; 0x50
    34b4:	3301      	adds	r3, #1
    34b6:	fb90 f1f3 	sdiv	r1, r0, r3
    34ba:	fb03 0011 	mls	r0, r3, r1, r0
    34be:	1c43      	adds	r3, r0, #1
		  }

		  void FillGradients(CRGB leds[], uint16_t indexes[], int numLeds, int numGradients, int speed)
		  {
			  if (numGradients < 1) numGradients = 1;
    34c0:	2b01      	cmp	r3, #1
    34c2:	bfb8      	it	lt
    34c4:	2301      	movlt	r3, #1
    34c6:	9300      	str	r3, [sp, #0]
    34c8:	9b00      	ldr	r3, [sp, #0]
    34ca:	fb97 f3f3 	sdiv	r3, r7, r3
    34ce:	9302      	str	r3, [sp, #8]
    34d0:	b2d3      	uxtb	r3, r2
    34d2:	9301      	str	r3, [sp, #4]

			  for (int i = 0; i < numGradients; i++)
    34d4:	f04f 0b00 	mov.w	fp, #0
			  }
		  }

		  CRGB GetRainbowColor(int index = 0, int offset = 0)
		  {
			  switch ((index + offset) % 6)
    34d8:	4aa1      	ldr	r2, [pc, #644]	; (3760 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x360>)
    34da:	f10b 0304 	add.w	r3, fp, #4
    34de:	fb82 1203 	smull	r1, r2, r2, r3
    34e2:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
    34e6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    34ea:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
    34ee:	3b01      	subs	r3, #1
    34f0:	2b04      	cmp	r3, #4
    34f2:	f200 814b 	bhi.w	378c <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x38c>
    34f6:	e8df f013 	tbh	[pc, r3, lsl #1]
    34fa:	013f      	.short	0x013f
    34fc:	01200135 	.word	0x01200135
    3500:	016e0005 	.word	0x016e0005
    3504:	f04f 32ff 	mov.w	r2, #4294967295
    3508:	2300      	movs	r3, #0
    350a:	f88d 2010 	strb.w	r2, [sp, #16]
    350e:	f88d 2011 	strb.w	r2, [sp, #17]
    3512:	f88d 3012 	strb.w	r3, [sp, #18]
    3516:	4a92      	ldr	r2, [pc, #584]	; (3760 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x360>)
    3518:	f10b 0305 	add.w	r3, fp, #5
    351c:	fb82 1203 	smull	r1, r2, r2, r3
    3520:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
    3524:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    3528:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
    352c:	3b01      	subs	r3, #1
    352e:	2b04      	cmp	r3, #4
    3530:	f200 80bd 	bhi.w	36ae <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x2ae>
    3534:	e8df f013 	tbh	[pc, r3, lsl #1]
    3538:	00cf00d9 	.word	0x00cf00d9
    353c:	000500c5 	.word	0x000500c5
    3540:	0143      	.short	0x0143
    3542:	f04f 32ff 	mov.w	r2, #4294967295
    3546:	2300      	movs	r3, #0
    3548:	f88d 2014 	strb.w	r2, [sp, #20]
    354c:	f88d 2015 	strb.w	r2, [sp, #21]
    3550:	f88d 3016 	strb.w	r3, [sp, #22]
    3554:	4a82      	ldr	r2, [pc, #520]	; (3760 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x360>)
    3556:	f10b 0306 	add.w	r3, fp, #6
    355a:	fb82 1203 	smull	r1, r2, r2, r3
    355e:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
    3562:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    3566:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
    356a:	3b01      	subs	r3, #1
    356c:	2b04      	cmp	r3, #4
    356e:	f200 80d0 	bhi.w	3712 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x312>
    3572:	e8df f013 	tbh	[pc, r3, lsl #1]
    3576:	00c4      	.short	0x00c4
    3578:	009200d8 	.word	0x009200d8
    357c:	01180005 	.word	0x01180005
    3580:	f04f 32ff 	mov.w	r2, #4294967295
    3584:	2300      	movs	r3, #0
    3586:	f88d 2018 	strb.w	r2, [sp, #24]
    358a:	f88d 2019 	strb.w	r2, [sp, #25]
    358e:	f88d 301a 	strb.w	r3, [sp, #26]
				  CRGB color1 = GetRainbowColor(i + offset);
				  CRGB color2 = GetRainbowColor(i + 1 + offset);
				  CRGB color3 = GetRainbowColor(i + 2 + offset);

				  // Blend between two different colors over time.
				  CRGB blend1 = blend(color1, color2, speed);
    3592:	9c01      	ldr	r4, [sp, #4]
    3594:	aa05      	add	r2, sp, #20
    3596:	4623      	mov	r3, r4
    3598:	a904      	add	r1, sp, #16
    359a:	a807      	add	r0, sp, #28
    359c:	f7fe fe72 	bl	2284 <blend(CRGB const&, CRGB const&, unsigned char)>
				  CRGB blend2 = blend(color2, color3, speed);
    35a0:	4623      	mov	r3, r4
    35a2:	aa06      	add	r2, sp, #24
    35a4:	a905      	add	r1, sp, #20
    35a6:	a808      	add	r0, sp, #32
    35a8:	f7fe fe6c 	bl	2284 <blend(CRGB const&, CRGB const&, unsigned char)>

				  int startPos = (numLeds / numGradients) * i;
    35ac:	9a02      	ldr	r2, [sp, #8]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    35ae:	f89d 001c 	ldrb.w	r0, [sp, #28]
        g = rhs.g;
    35b2:	f89d 101d 	ldrb.w	r1, [sp, #29]
        b = rhs.b;
    35b6:	f89d 801e 	ldrb.w	r8, [sp, #30]
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    35ba:	f89d 6020 	ldrb.w	r6, [sp, #32]
        g = rhs.g;
    35be:	f89d 4021 	ldrb.w	r4, [sp, #33]	; 0x21
    35c2:	fb0b f302 	mul.w	r3, fp, r2
				  if (startPos < 0) startPos = 0;
				  int endPos = ((numLeds / numGradients) * (i + 1)) - 1;
    35c6:	eb02 0903 	add.w	r9, r2, r3
    35ca:	f109 39ff 	add.w	r9, r9, #4294967295
				  if (endPos < 1) endPos = 1;
    35ce:	f1b9 0f00 	cmp.w	r9, #0
    35d2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    35d6:	bfcc      	ite	gt
    35d8:	fa1f f989 	uxthgt.w	r9, r9
    35dc:	f04f 0901 	movle.w	r9, #1

				  FillGradientRgb(leds, indexes, numLeds, startPos, blend1, endPos, blend2);
    35e0:	b29b      	uxth	r3, r3
		  void FillGradientRgb(CRGB leds[], uint16_t indexes[], int numLeds,
			  uint16_t startpos, CRGB startcolor,
			  uint16_t endpos, CRGB endcolor)
		  {
			  // if the points are in the wrong order, straighten them
			  if (endpos < startpos)
    35e2:	454b      	cmp	r3, r9
				  CRGB blend1 = blend(color1, color2, speed);
				  CRGB blend2 = blend(color2, color3, speed);

				  int startPos = (numLeds / numGradients) * i;
				  if (startPos < 0) startPos = 0;
				  int endPos = ((numLeds / numGradients) * (i + 1)) - 1;
    35e4:	f10b 0b01 	add.w	fp, fp, #1
        b = rhs.b;
    35e8:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
		  void FillGradientRgb(CRGB leds[], uint16_t indexes[], int numLeds,
			  uint16_t startpos, CRGB startcolor,
			  uint16_t endpos, CRGB endcolor)
		  {
			  // if the points are in the wrong order, straighten them
			  if (endpos < startpos)
    35ec:	d90c      	bls.n	3608 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x208>
    35ee:	9203      	str	r2, [sp, #12]
    35f0:	46a4      	mov	ip, r4
    35f2:	46b6      	mov	lr, r6
    35f4:	461f      	mov	r7, r3
    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
        b = rhs.b;
    35f6:	4642      	mov	r2, r8
    35f8:	f8dd 800c 	ldr.w	r8, [sp, #12]

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    35fc:	460c      	mov	r4, r1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    35fe:	4606      	mov	r6, r0
    3600:	464b      	mov	r3, r9
        g = rhs.g;
    3602:	4661      	mov	r1, ip
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3604:	4670      	mov	r0, lr
    3606:	46b9      	mov	r9, r7

			  rdistance87 = (endcolor.r - startcolor.r) << 7;
			  gdistance87 = (endcolor.g - startcolor.g) << 7;
			  bdistance87 = (endcolor.b - startcolor.b) << 7;

			  uint16_t pixeldistance = endpos - startpos;
    3608:	ebc3 0709 	rsb	r7, r3, r9

			  saccum87 rdistance87;
			  saccum87 gdistance87;
			  saccum87 bdistance87;

			  rdistance87 = (endcolor.r - startcolor.r) << 7;
    360c:	1a36      	subs	r6, r6, r0
			  gdistance87 = (endcolor.g - startcolor.g) << 7;
    360e:	1a64      	subs	r4, r4, r1
			  bdistance87 = (endcolor.b - startcolor.b) << 7;
    3610:	ebc8 0202 	rsb	r2, r8, r2

			  uint16_t pixeldistance = endpos - startpos;
    3614:	b2bf      	uxth	r7, r7

			  saccum87 rdistance87;
			  saccum87 gdistance87;
			  saccum87 bdistance87;

			  rdistance87 = (endcolor.r - startcolor.r) << 7;
    3616:	01f6      	lsls	r6, r6, #7
			  gdistance87 = (endcolor.g - startcolor.g) << 7;
    3618:	01e4      	lsls	r4, r4, #7
			  bdistance87 = (endcolor.b - startcolor.b) << 7;
    361a:	01d2      	lsls	r2, r2, #7

			  uint16_t pixeldistance = endpos - startpos;
			  int16_t divisor = pixeldistance ? pixeldistance : 1;
    361c:	2f00      	cmp	r7, #0
    361e:	f000 80bf 	beq.w	37a0 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x3a0>
    3622:	fa0f fc87 	sxth.w	ip, r7

			  saccum87 rdelta87 = rdistance87 / divisor;
			  saccum87 gdelta87 = gdistance87 / divisor;
			  saccum87 bdelta87 = bdistance87 / divisor;

			  rdelta87 *= 2;
    3626:	fb96 f6fc 	sdiv	r6, r6, ip
			  gdelta87 *= 2;
    362a:	fb94 f4fc 	sdiv	r4, r4, ip

			  saccum87 rdelta87 = rdistance87 / divisor;
			  saccum87 gdelta87 = gdistance87 / divisor;
			  saccum87 bdelta87 = bdistance87 / divisor;

			  rdelta87 *= 2;
    362e:	ea4f 0e46 	mov.w	lr, r6, lsl #1
			  gdelta87 *= 2;
    3632:	0067      	lsls	r7, r4, #1
			  bdelta87 *= 2;
    3634:	fb92 f6fc 	sdiv	r6, r2, ip

			  accum88 r88 = startcolor.r << 8;
			  accum88 g88 = startcolor.g << 8;
			  accum88 b88 = startcolor.b << 8;
			  for (uint16_t i = startpos; i <= endpos; i++)
    3638:	4599      	cmp	r9, r3
			  saccum87 gdelta87 = gdistance87 / divisor;
			  saccum87 bdelta87 = bdistance87 / divisor;

			  rdelta87 *= 2;
			  gdelta87 *= 2;
			  bdelta87 *= 2;
    363a:	ea4f 0646 	mov.w	r6, r6, lsl #1

			  saccum87 rdelta87 = rdistance87 / divisor;
			  saccum87 gdelta87 = gdistance87 / divisor;
			  saccum87 bdelta87 = bdistance87 / divisor;

			  rdelta87 *= 2;
    363e:	fa1f fe8e 	uxth.w	lr, lr
			  gdelta87 *= 2;
    3642:	b2bf      	uxth	r7, r7
			  bdelta87 *= 2;
    3644:	b2b6      	uxth	r6, r6

			  accum88 r88 = startcolor.r << 8;
    3646:	ea4f 2000 	mov.w	r0, r0, lsl #8
			  accum88 g88 = startcolor.g << 8;
    364a:	ea4f 2101 	mov.w	r1, r1, lsl #8
			  accum88 b88 = startcolor.b << 8;
    364e:	ea4f 2208 	mov.w	r2, r8, lsl #8
			  for (uint16_t i = startpos; i <= endpos; i++)
    3652:	d31b      	bcc.n	368c <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x28c>
			  {
				  leds[indexes[i]] = CRGB(r88 >> 8, g88 >> 8, b88 >> 8);
    3654:	f83a c013 	ldrh.w	ip, [sl, r3, lsl #1]
			  bdelta87 *= 2;

			  accum88 r88 = startcolor.r << 8;
			  accum88 g88 = startcolor.g << 8;
			  accum88 b88 = startcolor.b << 8;
			  for (uint16_t i = startpos; i <= endpos; i++)
    3658:	3301      	adds	r3, #1
			  {
				  leds[indexes[i]] = CRGB(r88 >> 8, g88 >> 8, b88 >> 8);
    365a:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
    365e:	eb05 040c 	add.w	r4, r5, ip
    3662:	ea4f 2820 	mov.w	r8, r0, asr #8
			  bdelta87 *= 2;

			  accum88 r88 = startcolor.r << 8;
			  accum88 g88 = startcolor.g << 8;
			  accum88 b88 = startcolor.b << 8;
			  for (uint16_t i = startpos; i <= endpos; i++)
    3666:	b29b      	uxth	r3, r3
    3668:	f805 800c 	strb.w	r8, [r5, ip]
			  {
				  leds[indexes[i]] = CRGB(r88 >> 8, g88 >> 8, b88 >> 8);
				  r88 += rdelta87;
    366c:	4470      	add	r0, lr
        g = rhs.g;
    366e:	ea4f 2821 	mov.w	r8, r1, asr #8
        b = rhs.b;
    3672:	ea4f 2c22 	mov.w	ip, r2, asr #8
				  g88 += gdelta87;
    3676:	4439      	add	r1, r7
				  b88 += bdelta87;
    3678:	4432      	add	r2, r6
			  bdelta87 *= 2;

			  accum88 r88 = startcolor.r << 8;
			  accum88 g88 = startcolor.g << 8;
			  accum88 b88 = startcolor.b << 8;
			  for (uint16_t i = startpos; i <= endpos; i++)
    367a:	4599      	cmp	r9, r3
			  {
				  leds[indexes[i]] = CRGB(r88 >> 8, g88 >> 8, b88 >> 8);
				  r88 += rdelta87;
    367c:	b280      	uxth	r0, r0

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    367e:	f884 8001 	strb.w	r8, [r4, #1]
				  g88 += gdelta87;
    3682:	b289      	uxth	r1, r1
        b = rhs.b;
    3684:	f884 c002 	strb.w	ip, [r4, #2]
				  b88 += bdelta87;
    3688:	b292      	uxth	r2, r2
			  bdelta87 *= 2;

			  accum88 r88 = startcolor.r << 8;
			  accum88 g88 = startcolor.g << 8;
			  accum88 b88 = startcolor.b << 8;
			  for (uint16_t i = startpos; i <= endpos; i++)
    368a:	d2e3      	bcs.n	3654 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x254>

		  void FillGradients(CRGB leds[], uint16_t indexes[], int numLeds, int numGradients, int speed)
		  {
			  if (numGradients < 1) numGradients = 1;

			  for (int i = 0; i < numGradients; i++)
    368c:	9b00      	ldr	r3, [sp, #0]
    368e:	455b      	cmp	r3, fp
    3690:	f47f af22 	bne.w	34d8 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0xd8>
		  {
			  int speed = beatsin8(GetAnalogPattern(16, 48), 0, 255);

			  // Modes
			  FillGradients(leds, indexes, numLeds, GetModeNumber(modeOffset) + 1, speed);
		  }
    3694:	b00b      	add	sp, #44	; 0x2c
    3696:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    369a:	2337      	movs	r3, #55	; 0x37
    369c:	22e6      	movs	r2, #230	; 0xe6
    369e:	f88d 3018 	strb.w	r3, [sp, #24]
    36a2:	2300      	movs	r3, #0
    36a4:	f88d 2019 	strb.w	r2, [sp, #25]
    36a8:	f88d 301a 	strb.w	r3, [sp, #26]
    36ac:	e771      	b.n	3592 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x192>
    36ae:	23be      	movs	r3, #190	; 0xbe
    36b0:	2200      	movs	r2, #0
    36b2:	f88d 3014 	strb.w	r3, [sp, #20]
    36b6:	23ae      	movs	r3, #174	; 0xae
    36b8:	f88d 2015 	strb.w	r2, [sp, #21]
    36bc:	f88d 3016 	strb.w	r3, [sp, #22]
    36c0:	e748      	b.n	3554 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x154>
    36c2:	2337      	movs	r3, #55	; 0x37
    36c4:	22e6      	movs	r2, #230	; 0xe6
    36c6:	f88d 3014 	strb.w	r3, [sp, #20]
    36ca:	2300      	movs	r3, #0
    36cc:	f88d 2015 	strb.w	r2, [sp, #21]
    36d0:	f88d 3016 	strb.w	r3, [sp, #22]
    36d4:	e73e      	b.n	3554 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x154>
    36d6:	2308      	movs	r3, #8
    36d8:	22cf      	movs	r2, #207	; 0xcf
    36da:	f88d 3014 	strb.w	r3, [sp, #20]
    36de:	23e2      	movs	r3, #226	; 0xe2
    36e0:	f88d 2015 	strb.w	r2, [sp, #21]
    36e4:	f88d 3016 	strb.w	r3, [sp, #22]
    36e8:	e734      	b.n	3554 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x154>
    36ea:	233e      	movs	r3, #62	; 0x3e
    36ec:	2200      	movs	r2, #0
    36ee:	f88d 3014 	strb.w	r3, [sp, #20]
    36f2:	23c3      	movs	r3, #195	; 0xc3
    36f4:	f88d 2015 	strb.w	r2, [sp, #21]
    36f8:	f88d 3016 	strb.w	r3, [sp, #22]
    36fc:	e72a      	b.n	3554 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x154>
    36fe:	233e      	movs	r3, #62	; 0x3e
    3700:	2200      	movs	r2, #0
    3702:	f88d 3018 	strb.w	r3, [sp, #24]
    3706:	23c3      	movs	r3, #195	; 0xc3
    3708:	f88d 2019 	strb.w	r2, [sp, #25]
    370c:	f88d 301a 	strb.w	r3, [sp, #26]
    3710:	e73f      	b.n	3592 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x192>
    3712:	23be      	movs	r3, #190	; 0xbe
    3714:	2200      	movs	r2, #0
    3716:	f88d 3018 	strb.w	r3, [sp, #24]
    371a:	23ae      	movs	r3, #174	; 0xae
    371c:	f88d 2019 	strb.w	r2, [sp, #25]
    3720:	f88d 301a 	strb.w	r3, [sp, #26]
    3724:	e735      	b.n	3592 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x192>
    3726:	2308      	movs	r3, #8
    3728:	22cf      	movs	r2, #207	; 0xcf
    372a:	f88d 3018 	strb.w	r3, [sp, #24]
    372e:	23e2      	movs	r3, #226	; 0xe2
    3730:	f88d 2019 	strb.w	r2, [sp, #25]
    3734:	f88d 301a 	strb.w	r3, [sp, #26]
    3738:	e72b      	b.n	3592 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x192>
    373a:	2337      	movs	r3, #55	; 0x37
    373c:	22e6      	movs	r2, #230	; 0xe6
    373e:	f88d 3010 	strb.w	r3, [sp, #16]
    3742:	2300      	movs	r3, #0
    3744:	f88d 2011 	strb.w	r2, [sp, #17]
    3748:	f88d 3012 	strb.w	r3, [sp, #18]
    374c:	e6e3      	b.n	3516 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x116>
    374e:	bf00      	nop
    3750:	447fc000 	.word	0x447fc000
    3754:	1fffb440 	.word	0x1fffb440
    3758:	00009454 	.word	0x00009454
    375c:	cccccccd 	.word	0xcccccccd
    3760:	2aaaaaab 	.word	0x2aaaaaab
    3764:	2308      	movs	r3, #8
    3766:	22cf      	movs	r2, #207	; 0xcf
    3768:	f88d 3010 	strb.w	r3, [sp, #16]
    376c:	23e2      	movs	r3, #226	; 0xe2
    376e:	f88d 2011 	strb.w	r2, [sp, #17]
    3772:	f88d 3012 	strb.w	r3, [sp, #18]
    3776:	e6ce      	b.n	3516 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x116>
    3778:	233e      	movs	r3, #62	; 0x3e
    377a:	2200      	movs	r2, #0
    377c:	f88d 3010 	strb.w	r3, [sp, #16]
    3780:	23c3      	movs	r3, #195	; 0xc3
    3782:	f88d 2011 	strb.w	r2, [sp, #17]
    3786:	f88d 3012 	strb.w	r3, [sp, #18]
    378a:	e6c4      	b.n	3516 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x116>
    378c:	23be      	movs	r3, #190	; 0xbe
    378e:	2200      	movs	r2, #0
    3790:	f88d 3010 	strb.w	r3, [sp, #16]
    3794:	23ae      	movs	r3, #174	; 0xae
    3796:	f88d 2011 	strb.w	r2, [sp, #17]
    379a:	f88d 3012 	strb.w	r3, [sp, #18]
    379e:	e6ba      	b.n	3516 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x116>
			  rdistance87 = (endcolor.r - startcolor.r) << 7;
			  gdistance87 = (endcolor.g - startcolor.g) << 7;
			  bdistance87 = (endcolor.b - startcolor.b) << 7;

			  uint16_t pixeldistance = endpos - startpos;
			  int16_t divisor = pixeldistance ? pixeldistance : 1;
    37a0:	f04f 0c01 	mov.w	ip, #1
    37a4:	e73f      	b.n	3626 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x226>
    37a6:	f04f 32ff 	mov.w	r2, #4294967295
    37aa:	2300      	movs	r3, #0
    37ac:	f88d 2018 	strb.w	r2, [sp, #24]
    37b0:	f04f 0262 	mov.w	r2, #98	; 0x62
    37b4:	f88d 2019 	strb.w	r2, [sp, #25]
    37b8:	f88d 301a 	strb.w	r3, [sp, #26]
    37bc:	e6e9      	b.n	3592 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x192>
    37be:	f04f 32ff 	mov.w	r2, #4294967295
    37c2:	2300      	movs	r3, #0
    37c4:	f88d 2014 	strb.w	r2, [sp, #20]
    37c8:	f04f 0262 	mov.w	r2, #98	; 0x62
    37cc:	f88d 2015 	strb.w	r2, [sp, #21]
    37d0:	f88d 3016 	strb.w	r3, [sp, #22]
    37d4:	e6be      	b.n	3554 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x154>
    37d6:	f04f 32ff 	mov.w	r2, #4294967295
    37da:	2300      	movs	r3, #0
    37dc:	f88d 2010 	strb.w	r2, [sp, #16]
    37e0:	f04f 0262 	mov.w	r2, #98	; 0x62
    37e4:	f88d 2011 	strb.w	r2, [sp, #17]
    37e8:	f88d 3012 	strb.w	r3, [sp, #18]
    37ec:	e693      	b.n	3516 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x116>
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    37ee:	f002 033f 	and.w	r3, r2, #63	; 0x3f

    uint8_t secoffset  = offset & 0x0F; // 0..15
    37f2:	f002 020f 	and.w	r2, r2, #15
    37f6:	e637      	b.n	3468 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0x68>
		  void BlendColor(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
		  {
			  int speed = beatsin8(GetAnalogPattern(16, 48), 0, 255);

			  // Modes
			  FillGradients(leds, indexes, numLeds, GetModeNumber(modeOffset) + 1, speed);
    37f8:	2301      	movs	r3, #1
    37fa:	9300      	str	r3, [sp, #0]
    37fc:	e664      	b.n	34c8 <Meltdown::CMeltdownLED::BlendColor(CRGB*, unsigned short*, int, int)+0xc8>
    37fe:	bf00      	nop

00003800 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)>:
			  {
				  SetRandomColor(leds, indexes, numLeds, ColorGradientFromPalette(paletteData.palette, numColors, i, random8(64, 195)), 1, .3);
			  }
		  }

		  void Orbital(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3800:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			  // The speed to shift the position.
			  float posMultiplier = .4;
			  // The pixel values.
			  int space = 40;
			  int width = 8;
			  if (!gMirror)
    3804:	f890 4038 	ldrb.w	r4, [r0, #56]	; 0x38
			  float gradientMultiplier = 1.5;
			  // The speed to shift the position.
			  float posMultiplier = .4;
			  // The pixel values.
			  int space = 40;
			  int width = 8;
    3808:	2c00      	cmp	r4, #0
    380a:	bf0c      	ite	eq
    380c:	f04f 0b28 	moveq.w	fp, #40	; 0x28
    3810:	f04f 0b08 	movne.w	fp, #8
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    3814:	1e1e      	subs	r6, r3, #0
			  {
				  SetRandomColor(leds, indexes, numLeds, ColorGradientFromPalette(paletteData.palette, numColors, i, random8(64, 195)), 1, .3);
			  }
		  }

		  void Orbital(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3816:	b0f7      	sub	sp, #476	; 0x1dc
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    3818:	f340 80da 	ble.w	39d0 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x1d0>
    381c:	4694      	mov	ip, r2
    381e:	eb02 0846 	add.w	r8, r2, r6, lsl #1
			  {
				  int scale = 255 - fade;
				  (leds[indexes[i]]).nscale8(scale);
    3822:	f83c 4b02 	ldrh.w	r4, [ip], #2
    3826:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    382a:	190d      	adds	r5, r1, r4
LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    382c:	5d0b      	ldrb	r3, [r1, r4]
    382e:	ebc3 07c3 	rsb	r7, r3, r3, lsl #3
    3832:	ebc3 03c7 	rsb	r3, r3, r7, lsl #3
    3836:	119b      	asrs	r3, r3, #6
    3838:	550b      	strb	r3, [r1, r4]
    g = (((uint16_t)g) * scale_fixed) >> 8;
    383a:	786c      	ldrb	r4, [r5, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    383c:	78ab      	ldrb	r3, [r5, #2]
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    383e:	ebc4 0ec4 	rsb	lr, r4, r4, lsl #3
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3842:	ebc3 07c3 	rsb	r7, r3, r3, lsl #3
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3846:	ebc4 04ce 	rsb	r4, r4, lr, lsl #3
    b = (((uint16_t)b) * scale_fixed) >> 8;
    384a:	ebc3 03c7 	rsb	r3, r3, r7, lsl #3
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    384e:	11a4      	asrs	r4, r4, #6
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3850:	119b      	asrs	r3, r3, #6
			  }
		  }

		  void FadeSetsToBlackBy(CRGB leds[], uint16_t indexes[], int numLeds, int fade)
		  {
			  for (int i = 0; i < numLeds; i++)
    3852:	45c4      	cmp	ip, r8
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3854:	706c      	strb	r4, [r5, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3856:	70ab      	strb	r3, [r5, #2]
    3858:	d1e3      	bne.n	3822 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x22>
	if (out_range >= 0) {
		num += in_range / 2;
    385a:	1073      	asrs	r3, r6, #1
    385c:	9205      	str	r2, [sp, #20]
    385e:	9102      	str	r1, [sp, #8]
    3860:	4605      	mov	r5, r0
    3862:	f10b 0828 	add.w	r8, fp, #40	; 0x28
    3866:	9304      	str	r3, [sp, #16]
    3868:	2400      	movs	r4, #0
    386a:	e003      	b.n	3874 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x74>
			  // Fade value.
			  int fade = 36;

			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  for (int i = 0; i < numLeds; i++)
    386c:	3401      	adds	r4, #1
    386e:	42a6      	cmp	r6, r4
    3870:	f000 80ae 	beq.w	39d0 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x1d0>

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    3874:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    3876:	2800      	cmp	r0, #0
    3878:	f340 80b1 	ble.w	39de <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x1de>
    387c:	f003 ff22 	bl	76c4 <__aeabi_i2f>
    3880:	495a      	ldr	r1, [pc, #360]	; (39ec <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x1ec>)
    3882:	4682      	mov	sl, r0
    3884:	f003 ff72 	bl	776c <__aeabi_fmul>
    3888:	f004 f936 	bl	7af8 <__aeabi_f2iz>
			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  for (int i = 0; i < numLeds; i++)
			  {
				  // Effectively, make a solid block that is 'width' pixels wide with a 'space' pixel wide gap in between.
				  if ((i + GetFrameOffset(posMultiplier)) % (space + width) < width)
    388c:	4420      	add	r0, r4
    388e:	fb90 f3f8 	sdiv	r3, r0, r8
    3892:	fb08 0013 	mls	r0, r8, r3, r0
    3896:	4583      	cmp	fp, r0
    3898:	dde8      	ble.n	386c <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x6c>
				  {
					  leds[indexes[i]] = ColorGradientFromPalette(GetRandomPalette().palette, numLeds, i + GetFrameOffset(gradientMultiplier));
    389a:	9b05      	ldr	r3, [sp, #20]
    389c:	2230      	movs	r2, #48	; 0x30
    389e:	f833 9014 	ldrh.w	r9, [r3, r4, lsl #1]
			  return palettes[index % ARRAY_SIZE(palettes)];
		  }

		  PaletteData GetRandomPalette()
		  {
			  return GetPalette(gRandomPaletteNumber);
    38a2:	692b      	ldr	r3, [r5, #16]
    38a4:	9303      	str	r3, [sp, #12]
    38a6:	f505 71cc 	add.w	r1, r5, #408	; 0x198
    38aa:	a814      	add	r0, sp, #80	; 0x50
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    38ac:	2701      	movs	r7, #1
    38ae:	f000 ff65 	bl	477c <memcpy>
    38b2:	2230      	movs	r2, #48	; 0x30
    38b4:	f505 7184 	add.w	r1, r5, #264	; 0x108
    38b8:	f10d 0081 	add.w	r0, sp, #129	; 0x81
    38bc:	f88d 7080 	strb.w	r7, [sp, #128]	; 0x80
    38c0:	f000 ff5c 	bl	477c <memcpy>
    38c4:	2230      	movs	r2, #48	; 0x30
    38c6:	f505 71e4 	add.w	r1, r5, #456	; 0x1c8
    38ca:	f10d 00b2 	add.w	r0, sp, #178	; 0xb2
    38ce:	f88d 70b1 	strb.w	r7, [sp, #177]	; 0xb1
    38d2:	f000 ff53 	bl	477c <memcpy>
    38d6:	2230      	movs	r2, #48	; 0x30
    38d8:	f505 719c 	add.w	r1, r5, #312	; 0x138
    38dc:	f10d 00e3 	add.w	r0, sp, #227	; 0xe3
    38e0:	f88d 70e2 	strb.w	r7, [sp, #226]	; 0xe2
    38e4:	f000 ff4a 	bl	477c <memcpy>
    38e8:	2230      	movs	r2, #48	; 0x30
    38ea:	f505 71b4 	add.w	r1, r5, #360	; 0x168
    38ee:	a845      	add	r0, sp, #276	; 0x114
    38f0:	f88d 7113 	strb.w	r7, [sp, #275]	; 0x113
    38f4:	f000 ff42 	bl	477c <memcpy>
    38f8:	2230      	movs	r2, #48	; 0x30
    38fa:	f105 01d8 	add.w	r1, r5, #216	; 0xd8
    38fe:	f20d 1045 	addw	r0, sp, #325	; 0x145
    3902:	f88d 7144 	strb.w	r7, [sp, #324]	; 0x144
    3906:	f000 ff39 	bl	477c <memcpy>
    390a:	2230      	movs	r2, #48	; 0x30
    390c:	f505 710a 	add.w	r1, r5, #552	; 0x228
    3910:	f50d 70bb 	add.w	r0, sp, #374	; 0x176
    3914:	f88d 7175 	strb.w	r7, [sp, #373]	; 0x175
    3918:	f000 ff30 	bl	477c <memcpy>
    391c:	2230      	movs	r2, #48	; 0x30
    391e:	f505 71fc 	add.w	r1, r5, #504	; 0x1f8
    3922:	f20d 10a7 	addw	r0, sp, #423	; 0x1a7
    3926:	f88d 71a6 	strb.w	r7, [sp, #422]	; 0x1a6
    392a:	f000 ff27 	bl	477c <memcpy>

			  return palettes[index % ARRAY_SIZE(palettes)];
    392e:	9b03      	ldr	r3, [sp, #12]
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3930:	f88d 71d7 	strb.w	r7, [sp, #471]	; 0x1d7

			  return palettes[index % ARRAY_SIZE(palettes)];
    3934:	f003 0107 	and.w	r1, r3, #7
    3938:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    393c:	ab14      	add	r3, sp, #80	; 0x50
    393e:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    3942:	4419      	add	r1, r3
    3944:	2230      	movs	r2, #48	; 0x30
    3946:	a807      	add	r0, sp, #28
    3948:	af07      	add	r7, sp, #28
    394a:	f000 ff17 	bl	477c <memcpy>
    394e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3950:	f10d 0e50 	add.w	lr, sp, #80	; 0x50
    3954:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3958:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    395a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    395e:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    3962:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    3966:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
    396a:	4650      	mov	r0, sl
    396c:	f003 fefe 	bl	776c <__aeabi_fmul>
    3970:	f004 f8c2 	bl	7af8 <__aeabi_f2iz>
    3974:	4420      	add	r0, r4
    3976:	fb90 f3f6 	sdiv	r3, r0, r6
    397a:	fb06 0213 	mls	r2, r6, r3, r0
	if (out_range >= 0) {
		num += in_range / 2;
    397e:	9b04      	ldr	r3, [sp, #16]
			  for (int i = 0; i < numLeds; i++)
			  {
				  // Effectively, make a solid block that is 'width' pixels wide with a 'space' pixel wide gap in between.
				  if ((i + GetFrameOffset(posMultiplier)) % (space + width) < width)
				  {
					  leds[indexes[i]] = ColorGradientFromPalette(GetRandomPalette().palette, numLeds, i + GetFrameOffset(gradientMultiplier));
    3980:	9902      	ldr	r1, [sp, #8]
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    3982:	ebc2 2202 	rsb	r2, r2, r2, lsl #8
	if (out_range >= 0) {
		num += in_range / 2;
    3986:	441a      	add	r2, r3
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
	if (out_range >= 0) {
		if (in_range * num < 0) return result - 1;
    3988:	fb02 f306 	mul.w	r3, r2, r6
    398c:	2b00      	cmp	r3, #0
    398e:	eb09 0949 	add.w	r9, r9, r9, lsl #1
	if (out_range >= 0) {
		num += in_range / 2;
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
    3992:	fb92 f2f6 	sdiv	r2, r2, r6
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
			  }
			  else
			  {
				  return ColorFromPalette(palette, mappedPos, brightness, blendType);
    3996:	f04f 0301 	mov.w	r3, #1
    399a:	bfb8      	it	lt
    399c:	f102 32ff 	addlt.w	r2, r2, #4294967295
			  for (int i = 0; i < numLeds; i++)
			  {
				  // Effectively, make a solid block that is 'width' pixels wide with a 'space' pixel wide gap in between.
				  if ((i + GetFrameOffset(posMultiplier)) % (space + width) < width)
				  {
					  leds[indexes[i]] = ColorGradientFromPalette(GetRandomPalette().palette, numLeds, i + GetFrameOffset(gradientMultiplier));
    39a0:	eb01 0709 	add.w	r7, r1, r9
    39a4:	b2d2      	uxtb	r2, r2
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
			  }
			  else
			  {
				  return ColorFromPalette(palette, mappedPos, brightness, blendType);
    39a6:	a914      	add	r1, sp, #80	; 0x50
    39a8:	a806      	add	r0, sp, #24
    39aa:	9300      	str	r3, [sp, #0]
    39ac:	23ff      	movs	r3, #255	; 0xff
    39ae:	f7fe fc77 	bl	22a0 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)>
			  // Fade value.
			  int fade = 36;

			  FadeSetsToBlackBy(leds, indexes, numLeds, fade);

			  for (int i = 0; i < numLeds; i++)
    39b2:	3401      	adds	r4, #1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    39b4:	9802      	ldr	r0, [sp, #8]
    39b6:	f89d 1018 	ldrb.w	r1, [sp, #24]
        g = rhs.g;
    39ba:	f89d 2019 	ldrb.w	r2, [sp, #25]
        b = rhs.b;
    39be:	f89d 301a 	ldrb.w	r3, [sp, #26]
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    39c2:	f800 1009 	strb.w	r1, [r0, r9]
    39c6:	42a6      	cmp	r6, r4
        g = rhs.g;
    39c8:	707a      	strb	r2, [r7, #1]
        b = rhs.b;
    39ca:	70bb      	strb	r3, [r7, #2]
    39cc:	f47f af52 	bne.w	3874 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x74>
				  {
					  leds[indexes[i]] = ColorGradientFromPalette(GetRandomPalette().palette, numLeds, i + GetFrameOffset(gradientMultiplier));
				  }
			  }

			  counter++;
    39d0:	4a07      	ldr	r2, [pc, #28]	; (39f0 <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x1f0>)
    39d2:	6813      	ldr	r3, [r2, #0]
    39d4:	3301      	adds	r3, #1
    39d6:	6013      	str	r3, [r2, #0]
		  }
    39d8:	b077      	add	sp, #476	; 0x1dc
    39da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

		  long GetFrame()
		  {
			  if (gFrame < 1)
			  {
				  gFrame = 1;
    39de:	2301      	movs	r3, #1
    39e0:	f04f 5a7e 	mov.w	sl, #1065353216	; 0x3f800000
    39e4:	62eb      	str	r3, [r5, #44]	; 0x2c
    39e6:	2000      	movs	r0, #0
    39e8:	e750      	b.n	388c <Meltdown::CMeltdownLED::Orbital(CRGB*, unsigned short*, int, int)+0x8c>
    39ea:	bf00      	nop
    39ec:	3ecccccd 	.word	0x3ecccccd
    39f0:	1fffb068 	.word	0x1fffb068

000039f4 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)>:
			  EVERY_N_SECONDS(interval) {
				  heatIndex++;
			  }
		  }

		  void MeteorRain(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    39f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39f8:	b0f7      	sub	sp, #476	; 0x1dc
    39fa:	4607      	mov	r7, r0
    39fc:	9880      	ldr	r0, [sp, #512]	; 0x200
    39fe:	9203      	str	r2, [sp, #12]
		  int SetFrameStep(int val)
		  {
			  if (val < -1) val = -1;
			  if (val == 0) val = 1;

			  gFrameStep = val;
    3a00:	f04f 35ff 	mov.w	r5, #4294967295
			  const boolean meteorRandomDecay = true;

			  // Medium meteor.
			  int meteorSize = 25;
			  int frameMultiplier = 1;
			  gDelay = 15;
    3a04:	240f      	movs	r4, #15
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    3a06:	2800      	cmp	r0, #0
			  EVERY_N_SECONDS(interval) {
				  heatIndex++;
			  }
		  }

		  void MeteorRain(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3a08:	468a      	mov	sl, r1
    3a0a:	469b      	mov	fp, r3
		  int SetFrameStep(int val)
		  {
			  if (val < -1) val = -1;
			  if (val == 0) val = 1;

			  gFrameStep = val;
    3a0c:	633d      	str	r5, [r7, #48]	; 0x30
			  const boolean meteorRandomDecay = true;

			  // Medium meteor.
			  int meteorSize = 25;
			  int frameMultiplier = 1;
			  gDelay = 15;
    3a0e:	61bc      	str	r4, [r7, #24]
		  int GetModeNumber() { return gCurrentModeNumber; }

		  int GetModeNumber(int offset)
		  {
			  // A value less than zero indicates we want the base mode.
			  if (offset < 0) return 0;
    3a10:	f2c0 810f 	blt.w	3c32 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x23e>

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    3a14:	683a      	ldr	r2, [r7, #0]
    3a16:	4b88      	ldr	r3, [pc, #544]	; (3c38 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x244>)
			  int meteorSize = 25;
			  int frameMultiplier = 1;
			  gDelay = 15;

			  // Modes
			  switch (GetModeNumber(modeOffset))
    3a18:	68b9      	ldr	r1, [r7, #8]

		  MeltdownPattern GetPattern(int offset = 0)
		  {
			  int patternNumber = GetPatternNumber(offset);

			  return gPatterns[patternNumber];
    3a1a:	fba3 4302 	umull	r4, r3, r3, r2
    3a1e:	08db      	lsrs	r3, r3, #3
    3a20:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    3a24:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    3a28:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3a2c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
			  int meteorSize = 25;
			  int frameMultiplier = 1;
			  gDelay = 15;

			  // Modes
			  switch (GetModeNumber(modeOffset))
    3a30:	4401      	add	r1, r0
    3a32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    3a34:	3301      	adds	r3, #1
    3a36:	fb91 f0f3 	sdiv	r0, r1, r3
    3a3a:	fb03 1110 	mls	r1, r3, r0, r1
    3a3e:	2901      	cmp	r1, #1
    3a40:	f000 80f2 	beq.w	3c28 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x234>
    3a44:	2902      	cmp	r1, #2
    3a46:	f040 80f4 	bne.w	3c32 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x23e>
				  // Large meteor.
				  case 2:
				  {
					  meteorSize = 50;
					  frameMultiplier = 1;
					  gDelay = 20;
    3a4a:	2314      	movs	r3, #20
    3a4c:	61bb      	str	r3, [r7, #24]
					  break;
				  }
				  // Large meteor.
				  case 2:
				  {
					  meteorSize = 50;
    3a4e:	f04f 0932 	mov.w	r9, #50	; 0x32
					  break;
				  }
			  }

			  // If not mirroring, make a longer and faster meteor
			  if (!gMirror)
    3a52:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
    3a56:	b90b      	cbnz	r3, 3a5c <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x68>
			  {
				  meteorSize *= 5;
    3a58:	eb09 0989 	add.w	r9, r9, r9, lsl #2
    3a5c:	45d9      	cmp	r9, fp
    3a5e:	bfa8      	it	ge
    3a60:	46d9      	movge	r9, fp
			  {
				  meteorSize = numLeds;
			  }

			  // Fade brightness all LEDs one step.
			  for (int i = 0; i < numLeds; i++)
    3a62:	f1bb 0f00 	cmp.w	fp, #0
    3a66:	dd34      	ble.n	3ad2 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0xde>
    3a68:	9b03      	ldr	r3, [sp, #12]
    3a6a:	461d      	mov	r5, r3
    3a6c:	eb03 044b 	add.w	r4, r3, fp, lsl #1
			  {
				  if (!meteorRandomDecay || random(10) > 5)
    3a70:	200a      	movs	r0, #10
    3a72:	f003 f85f 	bl	6b34 <random(unsigned long)>
    3a76:	2805      	cmp	r0, #5
    3a78:	d928      	bls.n	3acc <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0xd8>
				  {
					  int meteorTrailDecay = GetAnalogPattern(32, 96);

					  (leds[indexes[i]]).fadeToBlackBy(meteorTrailDecay);
    3a7a:	882b      	ldrh	r3, [r5, #0]
LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    3a7c:	69f8      	ldr	r0, [r7, #28]
    3a7e:	eb03 0643 	add.w	r6, r3, r3, lsl #1
    3a82:	f003 fe1f 	bl	76c4 <__aeabi_i2f>
    3a86:	f04f 4185 	mov.w	r1, #1115684864	; 0x42800000
    3a8a:	f003 fe6f 	bl	776c <__aeabi_fmul>
    3a8e:	496b      	ldr	r1, [pc, #428]	; (3c3c <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x248>)
    3a90:	f003 ff20 	bl	78d4 <__aeabi_fdiv>
    3a94:	f04f 4184 	mov.w	r1, #1107296256	; 0x42000000
    3a98:	f003 fd60 	bl	755c <__addsf3>
    3a9c:	f004 f82c 	bl	7af8 <__aeabi_f2iz>
    3aa0:	43c0      	mvns	r0, r0
    3aa2:	f81a 3006 	ldrb.w	r3, [sl, r6]
    3aa6:	b2c0      	uxtb	r0, r0
    3aa8:	3001      	adds	r0, #1
    3aaa:	fb00 f303 	mul.w	r3, r0, r3
    3aae:	121b      	asrs	r3, r3, #8
    3ab0:	f80a 3006 	strb.w	r3, [sl, r6]
    3ab4:	eb0a 0306 	add.w	r3, sl, r6
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3ab8:	785a      	ldrb	r2, [r3, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3aba:	7899      	ldrb	r1, [r3, #2]
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3abc:	fb00 f202 	mul.w	r2, r0, r2
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3ac0:	fb00 f001 	mul.w	r0, r0, r1
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3ac4:	1212      	asrs	r2, r2, #8
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3ac6:	1200      	asrs	r0, r0, #8
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    3ac8:	705a      	strb	r2, [r3, #1]
    b = (((uint16_t)b) * scale_fixed) >> 8;
    3aca:	7098      	strb	r0, [r3, #2]
    3acc:	3502      	adds	r5, #2
			  {
				  meteorSize = numLeds;
			  }

			  // Fade brightness all LEDs one step.
			  for (int i = 0; i < numLeds; i++)
    3ace:	42a5      	cmp	r5, r4
    3ad0:	d1ce      	bne.n	3a70 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x7c>
				  gFrame = 1;
			  }
			  return gFrame;
		  }

		  long GetFrame(long maxFrames) { return gFrame % maxFrames; }
    3ad2:	6afd      	ldr	r5, [r7, #44]	; 0x2c
    3ad4:	fb95 f3fb 	sdiv	r3, r5, fp
				  }
			  }

			  // Draw meteor.
			  long frame = GetFrame(numLeds * frameMultiplier);
			  for (int i = 0; i < meteorSize; i++)
    3ad8:	f1b9 0f00 	cmp.w	r9, #0
				  gFrame = 1;
			  }
			  return gFrame;
		  }

		  long GetFrame(long maxFrames) { return gFrame % maxFrames; }
    3adc:	fb0b 5513 	mls	r5, fp, r3, r5
				  }
			  }

			  // Draw meteor.
			  long frame = GetFrame(numLeds * frameMultiplier);
			  for (int i = 0; i < meteorSize; i++)
    3ae0:	f340 809f 	ble.w	3c22 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x22e>
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
	if (out_range >= 0) {
		num += in_range / 2;
    3ae4:	ea4f 0369 	mov.w	r3, r9, asr #1
    3ae8:	9304      	str	r3, [sp, #16]
    3aea:	f507 73cc 	add.w	r3, r7, #408	; 0x198
    3aee:	2600      	movs	r6, #0
    3af0:	9302      	str	r3, [sp, #8]
    3af2:	46b8      	mov	r8, r7
    3af4:	f8cd a014 	str.w	sl, [sp, #20]
			  {
				  if ((frame - i < numLeds) && (frame - i >= 0))
    3af8:	455d      	cmp	r5, fp
    3afa:	f280 808c 	bge.w	3c16 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x222>
    3afe:	2d00      	cmp	r5, #0
    3b00:	f04f 0230 	mov.w	r2, #48	; 0x30
    3b04:	9902      	ldr	r1, [sp, #8]
    3b06:	a814      	add	r0, sp, #80	; 0x50
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3b08:	f04f 0701 	mov.w	r7, #1

			  // Draw meteor.
			  long frame = GetFrame(numLeds * frameMultiplier);
			  for (int i = 0; i < meteorSize; i++)
			  {
				  if ((frame - i < numLeds) && (frame - i >= 0))
    3b0c:	f2c0 8083 	blt.w	3c16 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x222>
				  {
					  // Set the colors of the meteor using a reversed HeatColors gradient, so the meteor's tail is white hot trailing off to red.
					  uint16_t index = indexes[frame - i];
					  leds[index] = ColorGradientFromPalette(GetRandomPalette().palette, meteorSize, i, 255, LINEARBLEND, true);
    3b10:	9b03      	ldr	r3, [sp, #12]
			  return palettes[index % ARRAY_SIZE(palettes)];
		  }

		  PaletteData GetRandomPalette()
		  {
			  return GetPalette(gRandomPaletteNumber);
    3b12:	f8d8 4010 	ldr.w	r4, [r8, #16]
			  {
				  if ((frame - i < numLeds) && (frame - i >= 0))
				  {
					  // Set the colors of the meteor using a reversed HeatColors gradient, so the meteor's tail is white hot trailing off to red.
					  uint16_t index = indexes[frame - i];
					  leds[index] = ColorGradientFromPalette(GetRandomPalette().palette, meteorSize, i, 255, LINEARBLEND, true);
    3b16:	f833 a015 	ldrh.w	sl, [r3, r5, lsl #1]
    3b1a:	f000 fe2f 	bl	477c <memcpy>
    3b1e:	2230      	movs	r2, #48	; 0x30
    3b20:	f508 7184 	add.w	r1, r8, #264	; 0x108
    3b24:	f10d 0081 	add.w	r0, sp, #129	; 0x81
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3b28:	f88d 7080 	strb.w	r7, [sp, #128]	; 0x80
    3b2c:	f000 fe26 	bl	477c <memcpy>
    3b30:	2230      	movs	r2, #48	; 0x30
    3b32:	f508 71e4 	add.w	r1, r8, #456	; 0x1c8
    3b36:	f10d 00b2 	add.w	r0, sp, #178	; 0xb2
    3b3a:	f88d 70b1 	strb.w	r7, [sp, #177]	; 0xb1
    3b3e:	f000 fe1d 	bl	477c <memcpy>
    3b42:	2230      	movs	r2, #48	; 0x30
    3b44:	f508 719c 	add.w	r1, r8, #312	; 0x138
    3b48:	f10d 00e3 	add.w	r0, sp, #227	; 0xe3
    3b4c:	f88d 70e2 	strb.w	r7, [sp, #226]	; 0xe2
    3b50:	f000 fe14 	bl	477c <memcpy>
    3b54:	2230      	movs	r2, #48	; 0x30
    3b56:	f508 71b4 	add.w	r1, r8, #360	; 0x168
    3b5a:	a845      	add	r0, sp, #276	; 0x114
    3b5c:	f88d 7113 	strb.w	r7, [sp, #275]	; 0x113
    3b60:	f000 fe0c 	bl	477c <memcpy>
    3b64:	2230      	movs	r2, #48	; 0x30
    3b66:	f108 01d8 	add.w	r1, r8, #216	; 0xd8
    3b6a:	f20d 1045 	addw	r0, sp, #325	; 0x145
    3b6e:	f88d 7144 	strb.w	r7, [sp, #324]	; 0x144
    3b72:	f000 fe03 	bl	477c <memcpy>
    3b76:	2230      	movs	r2, #48	; 0x30
    3b78:	f508 710a 	add.w	r1, r8, #552	; 0x228
    3b7c:	f50d 70bb 	add.w	r0, sp, #374	; 0x176
    3b80:	f88d 7175 	strb.w	r7, [sp, #373]	; 0x175
    3b84:	f000 fdfa 	bl	477c <memcpy>
    3b88:	2230      	movs	r2, #48	; 0x30
    3b8a:	f508 71fc 	add.w	r1, r8, #504	; 0x1f8
    3b8e:	f20d 10a7 	addw	r0, sp, #423	; 0x1a7
    3b92:	f88d 71a6 	strb.w	r7, [sp, #422]	; 0x1a6
    3b96:	f000 fdf1 	bl	477c <memcpy>

			  return palettes[index % ARRAY_SIZE(palettes)];
    3b9a:	f004 0107 	and.w	r1, r4, #7
    3b9e:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    3ba2:	ab14      	add	r3, sp, #80	; 0x50
    3ba4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    3ba8:	4419      	add	r1, r3
    3baa:	2230      	movs	r2, #48	; 0x30
    3bac:	a807      	add	r0, sp, #28
    3bae:	ac07      	add	r4, sp, #28
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3bb0:	f88d 71d7 	strb.w	r7, [sp, #471]	; 0x1d7
    3bb4:	f000 fde2 	bl	477c <memcpy>
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    3bb8:	fb96 fcf9 	sdiv	ip, r6, r9
    3bbc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    3bbe:	f10d 0e50 	add.w	lr, sp, #80	; 0x50
    3bc2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3bc6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    3bc8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3bcc:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    3bd0:	fb09 6c1c 	mls	ip, r9, ip, r6

			  // Get the appropriate color from the palette, mapped to the number of LEDs.
			  int mappedPos = map(pos, 0, numLeds, 0, numPaletteColors);
			  if (isReverse)
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
    3bd4:	9c04      	ldr	r4, [sp, #16]
    3bd6:	9700      	str	r7, [sp, #0]
    3bd8:	ebcc 2c0c 	rsb	ip, ip, ip, lsl #8
			  {
				  if ((frame - i < numLeds) && (frame - i >= 0))
				  {
					  // Set the colors of the meteor using a reversed HeatColors gradient, so the meteor's tail is white hot trailing off to red.
					  uint16_t index = indexes[frame - i];
					  leds[index] = ColorGradientFromPalette(GetRandomPalette().palette, meteorSize, i, 255, LINEARBLEND, true);
    3bdc:	9f05      	ldr	r7, [sp, #20]
    3bde:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1

			  // Get the appropriate color from the palette, mapped to the number of LEDs.
			  int mappedPos = map(pos, 0, numLeds, 0, numPaletteColors);
			  if (isReverse)
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
    3be2:	44a4      	add	ip, r4
    3be4:	fb9c fcf9 	sdiv	ip, ip, r9
    3be8:	ea6f 0c0c 	mvn.w	ip, ip
    3bec:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
			  {
				  if ((frame - i < numLeds) && (frame - i >= 0))
				  {
					  // Set the colors of the meteor using a reversed HeatColors gradient, so the meteor's tail is white hot trailing off to red.
					  uint16_t index = indexes[frame - i];
					  leds[index] = ColorGradientFromPalette(GetRandomPalette().palette, meteorSize, i, 255, LINEARBLEND, true);
    3bf0:	eb07 040a 	add.w	r4, r7, sl

			  // Get the appropriate color from the palette, mapped to the number of LEDs.
			  int mappedPos = map(pos, 0, numLeds, 0, numPaletteColors);
			  if (isReverse)
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
    3bf4:	fa5f f28c 	uxtb.w	r2, ip
    3bf8:	23ff      	movs	r3, #255	; 0xff
    3bfa:	a914      	add	r1, sp, #80	; 0x50
    3bfc:	a806      	add	r0, sp, #24
    3bfe:	f7fe fb4f 	bl	22a0 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)>
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3c02:	f89d 1018 	ldrb.w	r1, [sp, #24]
        g = rhs.g;
    3c06:	f89d 2019 	ldrb.w	r2, [sp, #25]
        b = rhs.b;
    3c0a:	f89d 301a 	ldrb.w	r3, [sp, #26]
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3c0e:	f807 100a 	strb.w	r1, [r7, sl]
        g = rhs.g;
    3c12:	7062      	strb	r2, [r4, #1]
        b = rhs.b;
    3c14:	70a3      	strb	r3, [r4, #2]
				  }
			  }

			  // Draw meteor.
			  long frame = GetFrame(numLeds * frameMultiplier);
			  for (int i = 0; i < meteorSize; i++)
    3c16:	3601      	adds	r6, #1
    3c18:	454e      	cmp	r6, r9
    3c1a:	f105 35ff 	add.w	r5, r5, #4294967295
    3c1e:	f47f af6b 	bne.w	3af8 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x104>
					  // Set the colors of the meteor using a reversed HeatColors gradient, so the meteor's tail is white hot trailing off to red.
					  uint16_t index = indexes[frame - i];
					  leds[index] = ColorGradientFromPalette(GetRandomPalette().palette, meteorSize, i, 255, LINEARBLEND, true);
				  }
			  }
		  }
    3c22:	b077      	add	sp, #476	; 0x1dc
    3c24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				  // Small meteors.
				  case 1:
				  {
					  meteorSize = 5;
					  frameMultiplier = 1.5;
					  gDelay = 7;
    3c28:	2307      	movs	r3, #7
    3c2a:	61bb      	str	r3, [r7, #24]
			  switch (GetModeNumber(modeOffset))
			  {
				  // Small meteors.
				  case 1:
				  {
					  meteorSize = 5;
    3c2c:	f04f 0905 	mov.w	r9, #5
					  frameMultiplier = 1.5;
					  gDelay = 7;
					  break;
    3c30:	e70f      	b.n	3a52 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x5e>
			  SetFrameStep(-1);

			  const boolean meteorRandomDecay = true;

			  // Medium meteor.
			  int meteorSize = 25;
    3c32:	f04f 0919 	mov.w	r9, #25
    3c36:	e70c      	b.n	3a52 <Meltdown::CMeltdownLED::MeteorRain(CRGB*, unsigned short*, int, int)+0x5e>
    3c38:	cccccccd 	.word	0xcccccccd
    3c3c:	447fc000 	.word	0x447fc000

00003c40 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)>:
			  uint16_t index = beatsin16(beats, 0, numLeds - 1);

			  GenerateSinelons(leds, indexes, numLeds, GetModeNumber() + 2, index);
		  }

		  void Bpm(CRGB leds[], uint16_t indexes[], int numLeds, int modeOffset = 0)
    3c40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3c44:	4d73      	ldr	r5, [pc, #460]	; (3e14 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1d4>)
    3c46:	4c74      	ldr	r4, [pc, #464]	; (3e18 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1d8>)
    3c48:	682d      	ldr	r5, [r5, #0]
    3c4a:	b0f9      	sub	sp, #484	; 0x1e4
    3c4c:	4682      	mov	sl, r0
    3c4e:	9508      	str	r5, [sp, #32]
	return ret;
    3c50:	9d08      	ldr	r5, [sp, #32]
    3c52:	fb04 f505 	mul.w	r5, r4, r5
    3c56:	0e2d      	lsrs	r5, r5, #24
    3c58:	b2e8      	uxtb	r0, r5
    3c5a:	4691      	mov	r9, r2
/// @param theta input angle from 0-255
/// @returns sin of theta, value between 0 and 255
LIB8STATIC uint8_t sin8_C( uint8_t theta)
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
    3c5c:	0642      	lsls	r2, r0, #25
    3c5e:	468b      	mov	fp, r1
    3c60:	461e      	mov	r6, r3
    3c62:	f140 80d1 	bpl.w	3e08 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1c8>
        offset = (uint8_t)255 - offset;
    3c66:	43c0      	mvns	r0, r0
    3c68:	b2c3      	uxtb	r3, r0
    }
    offset &= 0x3F; // 0..63

    uint8_t secoffset  = offset & 0x0F; // 0..15
    3c6a:	f003 000f 	and.w	r0, r3, #15
    if( theta & 0x40) secoffset++;
    3c6e:	3001      	adds	r0, #1
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    3c70:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    if( theta & 0x40) secoffset++;

    uint8_t section = offset >> 4; // 0..3
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    3c74:	4a69      	ldr	r2, [pc, #420]	; (3e1c <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1dc>)
    3c76:	111b      	asrs	r3, r3, #4
    3c78:	005b      	lsls	r3, r3, #1
    3c7a:	18d1      	adds	r1, r2, r3
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    3c7c:	5cd3      	ldrb	r3, [r2, r3]
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
    uint8_t b   =  *p;
    p++;
    uint8_t m16 =  *p;
    3c7e:	784c      	ldrb	r4, [r1, #1]

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    3c80:	fb14 f400 	smulbb	r4, r4, r0
    3c84:	eb03 1424 	add.w	r4, r3, r4, asr #4
    3c88:	b2e4      	uxtb	r4, r4
    if( theta & 0x80 ) y = -y;
    3c8a:	062b      	lsls	r3, r5, #24
    3c8c:	f04f 0230 	mov.w	r2, #48	; 0x30
    3c90:	f50a 71cc 	add.w	r1, sl, #408	; 0x198
    3c94:	a816      	add	r0, sp, #88	; 0x58
    3c96:	bf48      	it	mi
    3c98:	4264      	negmi	r4, r4
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3c9a:	2701      	movs	r7, #1
			  return palettes[index % ARRAY_SIZE(palettes)];
		  }

		  PaletteData GetRandomPalette()
		  {
			  return GetPalette(gRandomPaletteNumber);
    3c9c:	f8da 5010 	ldr.w	r5, [sl, #16]
    3ca0:	f000 fd6c 	bl	477c <memcpy>
    3ca4:	2230      	movs	r2, #48	; 0x30
    3ca6:	f50a 7184 	add.w	r1, sl, #264	; 0x108
    3caa:	f10d 0089 	add.w	r0, sp, #137	; 0x89
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3cae:	f88d 7088 	strb.w	r7, [sp, #136]	; 0x88
    3cb2:	f000 fd63 	bl	477c <memcpy>
    3cb6:	2230      	movs	r2, #48	; 0x30
    3cb8:	f50a 71e4 	add.w	r1, sl, #456	; 0x1c8
    3cbc:	f10d 00ba 	add.w	r0, sp, #186	; 0xba
    3cc0:	f88d 70b9 	strb.w	r7, [sp, #185]	; 0xb9
    3cc4:	f000 fd5a 	bl	477c <memcpy>
    3cc8:	2230      	movs	r2, #48	; 0x30
    3cca:	f50a 719c 	add.w	r1, sl, #312	; 0x138
    3cce:	f10d 00eb 	add.w	r0, sp, #235	; 0xeb
    3cd2:	f88d 70ea 	strb.w	r7, [sp, #234]	; 0xea
    3cd6:	f000 fd51 	bl	477c <memcpy>
    3cda:	2230      	movs	r2, #48	; 0x30
    3cdc:	f50a 71b4 	add.w	r1, sl, #360	; 0x168
    3ce0:	a847      	add	r0, sp, #284	; 0x11c
    3ce2:	f88d 711b 	strb.w	r7, [sp, #283]	; 0x11b
    3ce6:	f000 fd49 	bl	477c <memcpy>
    3cea:	2230      	movs	r2, #48	; 0x30
    3cec:	f10a 01d8 	add.w	r1, sl, #216	; 0xd8
    3cf0:	f20d 104d 	addw	r0, sp, #333	; 0x14d
    3cf4:	f88d 714c 	strb.w	r7, [sp, #332]	; 0x14c

			  return palettes[index % ARRAY_SIZE(palettes)];
    3cf8:	f005 0507 	and.w	r5, r5, #7
    3cfc:	f000 fd3e 	bl	477c <memcpy>
    3d00:	2230      	movs	r2, #48	; 0x30
    3d02:	f50a 710a 	add.w	r1, sl, #552	; 0x228
    3d06:	f50d 70bf 	add.w	r0, sp, #382	; 0x17e
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3d0a:	f88d 717d 	strb.w	r7, [sp, #381]	; 0x17d

			  return palettes[index % ARRAY_SIZE(palettes)];
    3d0e:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
    3d12:	f000 fd33 	bl	477c <memcpy>
    3d16:	2230      	movs	r2, #48	; 0x30
    3d18:	f50a 71fc 	add.w	r1, sl, #504	; 0x1f8
    3d1c:	f20d 10af 	addw	r0, sp, #431	; 0x1af
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3d20:	f88d 71ae 	strb.w	r7, [sp, #430]	; 0x1ae

			  return palettes[index % ARRAY_SIZE(palettes)];
    3d24:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
    3d28:	f000 fd28 	bl	477c <memcpy>
    3d2c:	ab16      	add	r3, sp, #88	; 0x58
    3d2e:	441d      	add	r5, r3
    3d30:	b264      	sxtb	r4, r4
    3d32:	4629      	mov	r1, r5
    3d34:	a809      	add	r0, sp, #36	; 0x24
    3d36:	2230      	movs	r2, #48	; 0x30
///  4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC_ALWAYS_INLINE uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
#if (FASTLED_SCALE8_FIXED == 1)
    return (((uint16_t)i) * (1+(uint16_t)(scale))) >> 8;
    3d38:	3c80      	subs	r4, #128	; 0x80
				  { Warm_p, LINEARBLEND },
				  { Cyberpunk_p, LINEARBLEND },
				  { Rainbow_p, LINEARBLEND },
				  { PartyColors_p, LINEARBLEND },
				  { RainbowColors_p, LINEARBLEND }
			  };
    3d3a:	f88d 71df 	strb.w	r7, [sp, #479]	; 0x1df
    3d3e:	f000 fd1d 	bl	477c <memcpy>

		int numModes;
		PatternFunc patternFunc;
	};

	struct PaletteData
    3d42:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
    3d46:	9303      	str	r3, [sp, #12]
		  {
			  int bpm = 60;
			  int beat = beatsin8(bpm, 0, 255);
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numLeds; i++)
    3d48:	2e00      	cmp	r6, #0
    3d4a:	b2e4      	uxtb	r4, r4

		int numModes;
		PatternFunc patternFunc;
	};

	struct PaletteData
    3d4c:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
		  {
			  int bpm = 60;
			  int beat = beatsin8(bpm, 0, 255);
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numLeds; i++)
    3d50:	dd57      	ble.n	3e02 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1c2>
	if (out_range >= 0) {
		num += in_range / 2;
    3d52:	fa46 f307 	asr.w	r3, r6, r7

		  long GetFrame()
		  {
			  if (gFrame < 1)
			  {
				  gFrame = 1;
    3d56:	9705      	str	r7, [sp, #20]
    3d58:	f1a9 0902 	sub.w	r9, r9, #2
    3d5c:	b2e4      	uxtb	r4, r4
    3d5e:	9304      	str	r3, [sp, #16]
    3d60:	2700      	movs	r7, #0
    3d62:	e030      	b.n	3dc6 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x186>
    3d64:	f003 fcae 	bl	76c4 <__aeabi_i2f>
    3d68:	492d      	ldr	r1, [pc, #180]	; (3e20 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1e0>)
    3d6a:	f003 fcff 	bl	776c <__aeabi_fmul>
    3d6e:	f003 fec3 	bl	7af8 <__aeabi_f2iz>
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    3d72:	183a      	adds	r2, r7, r0
    3d74:	fb92 f3f6 	sdiv	r3, r2, r6
    3d78:	fb06 2213 	mls	r2, r6, r3, r2
	if (out_range >= 0) {
		num += in_range / 2;
    3d7c:	9b04      	ldr	r3, [sp, #16]
	}
#endif
	long in_range = in_max - in_min;
	long out_range = out_max - out_min;
	if (in_range == 0) return out_min + out_range / 2;
	long num = (x - in_min) * out_range;
    3d7e:	ebc2 2202 	rsb	r2, r2, r2, lsl #8
	if (out_range >= 0) {
		num += in_range / 2;
    3d82:	441a      	add	r2, r3
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
	if (out_range >= 0) {
		if (in_range * num < 0) return result - 1;
    3d84:	fb02 f306 	mul.w	r3, r2, r6
    3d88:	2b00      	cmp	r3, #0
	if (out_range >= 0) {
		num += in_range / 2;
	} else {
		num -= in_range / 2;
	}
	long result = num / in_range + out_min;
    3d8a:	fb92 f2f6 	sdiv	r2, r2, r6
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
			  }
			  else
			  {
				  return ColorFromPalette(palette, mappedPos, brightness, blendType);
    3d8e:	9b03      	ldr	r3, [sp, #12]
    3d90:	9300      	str	r3, [sp, #0]
    3d92:	bfb8      	it	lt
    3d94:	f102 32ff 	addlt.w	r2, r2, #4294967295
    3d98:	4623      	mov	r3, r4
    3d9a:	b2d2      	uxtb	r2, r2
    3d9c:	a916      	add	r1, sp, #88	; 0x58
    3d9e:	a807      	add	r0, sp, #28
		  {
			  int bpm = 60;
			  int beat = beatsin8(bpm, 0, 255);
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numLeds; i++)
    3da0:	3701      	adds	r7, #1
			  {
				  return ColorFromPalette(palette, (numPaletteColors - mappedPos), brightness, blendType);
			  }
			  else
			  {
				  return ColorFromPalette(palette, mappedPos, brightness, blendType);
    3da2:	f7fe fa7d 	bl	22a0 <ColorFromPalette(CRGBPalette16 const&, unsigned char, unsigned char, TBlendType)>
    3da6:	3c0a      	subs	r4, #10
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3da8:	f89d 101c 	ldrb.w	r1, [sp, #28]
        g = rhs.g;
    3dac:	f89d 201d 	ldrb.w	r2, [sp, #29]
        b = rhs.b;
    3db0:	f89d 301e 	ldrb.w	r3, [sp, #30]
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3db4:	f80b 1005 	strb.w	r1, [fp, r5]
		  {
			  int bpm = 60;
			  int beat = beatsin8(bpm, 0, 255);
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numLeds; i++)
    3db8:	42be      	cmp	r6, r7
    3dba:	b2e4      	uxtb	r4, r4
        g = rhs.g;
    3dbc:	f888 2001 	strb.w	r2, [r8, #1]
        b = rhs.b;
    3dc0:	f888 3002 	strb.w	r3, [r8, #2]
    3dc4:	d01d      	beq.n	3e02 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x1c2>
    3dc6:	ad09      	add	r5, sp, #36	; 0x24
    3dc8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3dca:	f10d 0e58 	add.w	lr, sp, #88	; 0x58
    3dce:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3dd2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3dd4:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3dd8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    3ddc:	f8da c02c 	ldr.w	ip, [sl, #44]	; 0x2c
			  int beat = beatsin8(bpm, 0, 255);
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numLeds; i++)
			  {
				  leds[indexes[i]] = ColorGradientFromPalette(paletteData.palette, numLeds, i + GetFrameOffset(.15), beat - (i * 10), paletteData.blendType);
    3de0:	f839 5f02 	ldrh.w	r5, [r9, #2]!

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    3de4:	f1bc 0f00 	cmp.w	ip, #0
			  int beat = beatsin8(bpm, 0, 255);
			  PaletteData paletteData = GetRandomPalette();

			  for (int i = 0; i < numLeds; i++)
			  {
				  leds[indexes[i]] = ColorGradientFromPalette(paletteData.palette, numLeds, i + GetFrameOffset(.15), beat - (i * 10), paletteData.blendType);
    3de8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    3dec:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
    3df0:	eb0b 0805 	add.w	r8, fp, r5
    3df4:	4660      	mov	r0, ip

		  void SetFrame() { gFrame = MeltdownSerial.GetValue(); }

		  long GetFrame()
		  {
			  if (gFrame < 1)
    3df6:	dcb5      	bgt.n	3d64 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x124>
			  {
				  gFrame = 1;
    3df8:	9b05      	ldr	r3, [sp, #20]
    3dfa:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
    3dfe:	2000      	movs	r0, #0
    3e00:	e7b7      	b.n	3d72 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x132>

			  for (int i = 0; i < numLeds; i++)
			  {
				  leds[indexes[i]] = ColorGradientFromPalette(paletteData.palette, numLeds, i + GetFrameOffset(.15), beat - (i * 10), paletteData.blendType);
			  }
		  }
    3e02:	b079      	add	sp, #484	; 0x1e4
    3e04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
    uint8_t offset = theta;
    if( theta & 0x40 ) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F; // 0..63
    3e08:	f000 033f 	and.w	r3, r0, #63	; 0x3f

    uint8_t secoffset  = offset & 0x0F; // 0..15
    3e0c:	f000 000f 	and.w	r0, r0, #15
    3e10:	e730      	b.n	3c74 <Meltdown::CMeltdownLED::Bpm(CRGB*, unsigned short*, int, int)+0x34>
    3e12:	bf00      	nop
    3e14:	1fffb440 	.word	0x1fffb440
    3e18:	0041a000 	.word	0x0041a000
    3e1c:	00009454 	.word	0x00009454
    3e20:	3e19999a 	.word	0x3e19999a

00003e24 <Meltdown::CMeltdownLED::CMeltdownLED()>:

namespace Meltdown
{
	CMeltdownLED MeltdownLED;

	CMeltdownLED::CMeltdownLED()
    3e24:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3e28:	4ef5      	ldr	r6, [pc, #980]	; (4200 <Meltdown::CMeltdownLED::CMeltdownLED()+0x3dc>)
    3e2a:	4bf6      	ldr	r3, [pc, #984]	; (4204 <Meltdown::CMeltdownLED::CMeltdownLED()+0x3e0>)
    3e2c:	64c3      	str	r3, [r0, #76]	; 0x4c
    3e2e:	2500      	movs	r5, #0
    3e30:	2301      	movs	r3, #1
    3e32:	2130      	movs	r1, #48	; 0x30
    3e34:	2214      	movs	r2, #20
    3e36:	4604      	mov	r4, r0
    3e38:	6141      	str	r1, [r0, #20]
    3e3a:	6282      	str	r2, [r0, #40]	; 0x28
    3e3c:	6005      	str	r5, [r0, #0]
    3e3e:	6045      	str	r5, [r0, #4]
    3e40:	6085      	str	r5, [r0, #8]
    3e42:	60c5      	str	r5, [r0, #12]
    3e44:	6105      	str	r5, [r0, #16]
    3e46:	6185      	str	r5, [r0, #24]
    3e48:	61c5      	str	r5, [r0, #28]
    3e4a:	6205      	str	r5, [r0, #32]
    3e4c:	6245      	str	r5, [r0, #36]	; 0x24
    3e4e:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
    3e52:	f880 5035 	strb.w	r5, [r0, #53]	; 0x35
    3e56:	f880 5036 	strb.w	r5, [r0, #54]	; 0x36
    3e5a:	f880 5037 	strb.w	r5, [r0, #55]	; 0x37
    3e5e:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
    3e62:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
    3e66:	f880 503a 	strb.w	r5, [r0, #58]	; 0x3a
    3e6a:	f880 503b 	strb.w	r5, [r0, #59]	; 0x3b
    3e6e:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c
    3e72:	f880 503d 	strb.w	r5, [r0, #61]	; 0x3d
    3e76:	f880 503e 	strb.w	r5, [r0, #62]	; 0x3e
    3e7a:	f880 503f 	strb.w	r5, [r0, #63]	; 0x3f
    3e7e:	f880 5040 	strb.w	r5, [r0, #64]	; 0x40
    3e82:	62c3      	str	r3, [r0, #44]	; 0x2c
    3e84:	6303      	str	r3, [r0, #48]	; 0x30
    3e86:	4631      	mov	r1, r6
    3e88:	2278      	movs	r2, #120	; 0x78
    3e8a:	3050      	adds	r0, #80	; 0x50
    3e8c:	f000 fc76 	bl	477c <memcpy>
    3e90:	f106 0178 	add.w	r1, r6, #120	; 0x78
    3e94:	c90f      	ldmia	r1, {r0, r1, r2, r3}
    3e96:	f104 0bc8 	add.w	fp, r4, #200	; 0xc8
    3e9a:	e88b 000f 	stmia.w	fp, {r0, r1, r2, r3}
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3e9e:	27be      	movs	r7, #190	; 0xbe
    3ea0:	23ff      	movs	r3, #255	; 0xff
        g = rhs.g;
        b = rhs.b;
    3ea2:	26ae      	movs	r6, #174	; 0xae
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3ea4:	f04f 0808 	mov.w	r8, #8
        g = rhs.g;
    3ea8:	f04f 0ccf 	mov.w	ip, #207	; 0xcf
        b = rhs.b;
    3eac:	f04f 0ee2 	mov.w	lr, #226	; 0xe2
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3eb0:	f04f 093e 	mov.w	r9, #62	; 0x3e
        g = rhs.g;
        b = rhs.b;
    3eb4:	f04f 0ac3 	mov.w	sl, #195	; 0xc3
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3eb8:	2137      	movs	r1, #55	; 0x37
        g = rhs.g;
    3eba:	22e6      	movs	r2, #230	; 0xe6
    3ebc:	2062      	movs	r0, #98	; 0x62
    3ebe:	f884 50d9 	strb.w	r5, [r4, #217]	; 0xd9
    3ec2:	f884 50dc 	strb.w	r5, [r4, #220]	; 0xdc
    3ec6:	f884 50df 	strb.w	r5, [r4, #223]	; 0xdf
    3eca:	f884 50e2 	strb.w	r5, [r4, #226]	; 0xe2
    3ece:	f884 50e5 	strb.w	r5, [r4, #229]	; 0xe5
    3ed2:	f884 50e8 	strb.w	r5, [r4, #232]	; 0xe8
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3ed6:	f884 70d8 	strb.w	r7, [r4, #216]	; 0xd8
    3eda:	f884 70db 	strb.w	r7, [r4, #219]	; 0xdb
    3ede:	f884 70de 	strb.w	r7, [r4, #222]	; 0xde
        g = rhs.g;
        b = rhs.b;
    3ee2:	f884 60da 	strb.w	r6, [r4, #218]	; 0xda
    3ee6:	f884 60dd 	strb.w	r6, [r4, #221]	; 0xdd
    3eea:	f884 60e0 	strb.w	r6, [r4, #224]	; 0xe0
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3eee:	f884 90e1 	strb.w	r9, [r4, #225]	; 0xe1
    3ef2:	f884 90e4 	strb.w	r9, [r4, #228]	; 0xe4
    3ef6:	f884 90e7 	strb.w	r9, [r4, #231]	; 0xe7
        g = rhs.g;
        b = rhs.b;
    3efa:	f884 a0e3 	strb.w	sl, [r4, #227]	; 0xe3
    3efe:	f884 a0e6 	strb.w	sl, [r4, #230]	; 0xe6
    3f02:	f884 a0e9 	strb.w	sl, [r4, #233]	; 0xe9
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f06:	f884 80ea 	strb.w	r8, [r4, #234]	; 0xea
    3f0a:	f884 80ed 	strb.w	r8, [r4, #237]	; 0xed
        g = rhs.g;
    3f0e:	f884 c0eb 	strb.w	ip, [r4, #235]	; 0xeb
    3f12:	f884 c0ee 	strb.w	ip, [r4, #238]	; 0xee
        b = rhs.b;
    3f16:	f884 e0ec 	strb.w	lr, [r4, #236]	; 0xec
    3f1a:	f884 e0ef 	strb.w	lr, [r4, #239]	; 0xef
    3f1e:	f04f 0baa 	mov.w	fp, #170	; 0xaa
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f22:	f884 80f0 	strb.w	r8, [r4, #240]	; 0xf0
        g = rhs.g;
    3f26:	f884 c0f1 	strb.w	ip, [r4, #241]	; 0xf1
        b = rhs.b;
    3f2a:	f884 e0f2 	strb.w	lr, [r4, #242]	; 0xf2
    3f2e:	f884 50f5 	strb.w	r5, [r4, #245]	; 0xf5
    3f32:	f884 50f8 	strb.w	r5, [r4, #248]	; 0xf8
    3f36:	f884 50fb 	strb.w	r5, [r4, #251]	; 0xfb
    3f3a:	f884 50fe 	strb.w	r5, [r4, #254]	; 0xfe
    3f3e:	f884 5101 	strb.w	r5, [r4, #257]	; 0x101
    3f42:	f884 5104 	strb.w	r5, [r4, #260]	; 0x104
    3f46:	f884 5107 	strb.w	r5, [r4, #263]	; 0x107
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f4a:	f884 7108 	strb.w	r7, [r4, #264]	; 0x108
        g = rhs.g;
    3f4e:	f884 5109 	strb.w	r5, [r4, #265]	; 0x109
        b = rhs.b;
    3f52:	f884 610a 	strb.w	r6, [r4, #266]	; 0x10a
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f56:	f884 710b 	strb.w	r7, [r4, #267]	; 0x10b
        g = rhs.g;
    3f5a:	f884 510c 	strb.w	r5, [r4, #268]	; 0x10c
        b = rhs.b;
    3f5e:	f884 610d 	strb.w	r6, [r4, #269]	; 0x10d
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f62:	f884 710e 	strb.w	r7, [r4, #270]	; 0x10e
        g = rhs.g;
    3f66:	f884 510f 	strb.w	r5, [r4, #271]	; 0x10f
        b = rhs.b;
    3f6a:	f884 6110 	strb.w	r6, [r4, #272]	; 0x110
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f6e:	f884 10f3 	strb.w	r1, [r4, #243]	; 0xf3
    3f72:	f884 10f6 	strb.w	r1, [r4, #246]	; 0xf6
        g = rhs.g;
    3f76:	f884 20f4 	strb.w	r2, [r4, #244]	; 0xf4
    3f7a:	f884 20f7 	strb.w	r2, [r4, #247]	; 0xf7
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f7e:	f884 30f9 	strb.w	r3, [r4, #249]	; 0xf9
        g = rhs.g;
    3f82:	f884 30fa 	strb.w	r3, [r4, #250]	; 0xfa
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f86:	f884 30fc 	strb.w	r3, [r4, #252]	; 0xfc
        g = rhs.g;
    3f8a:	f884 30fd 	strb.w	r3, [r4, #253]	; 0xfd
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3f8e:	f884 30ff 	strb.w	r3, [r4, #255]	; 0xff
    3f92:	f884 3102 	strb.w	r3, [r4, #258]	; 0x102
    3f96:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
        g = rhs.g;
    3f9a:	f884 0100 	strb.w	r0, [r4, #256]	; 0x100
    3f9e:	f884 0103 	strb.w	r0, [r4, #259]	; 0x103
    3fa2:	f884 0106 	strb.w	r0, [r4, #262]	; 0x106
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fa6:	f884 7111 	strb.w	r7, [r4, #273]	; 0x111
        g = rhs.g;
    3faa:	f884 5112 	strb.w	r5, [r4, #274]	; 0x112
        b = rhs.b;
    3fae:	f884 6113 	strb.w	r6, [r4, #275]	; 0x113
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fb2:	f884 7114 	strb.w	r7, [r4, #276]	; 0x114
        g = rhs.g;
    3fb6:	f884 5115 	strb.w	r5, [r4, #277]	; 0x115
        b = rhs.b;
    3fba:	f884 6116 	strb.w	r6, [r4, #278]	; 0x116
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fbe:	f884 9117 	strb.w	r9, [r4, #279]	; 0x117
        g = rhs.g;
    3fc2:	f884 5118 	strb.w	r5, [r4, #280]	; 0x118
        b = rhs.b;
    3fc6:	f884 a119 	strb.w	sl, [r4, #281]	; 0x119
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fca:	f884 911a 	strb.w	r9, [r4, #282]	; 0x11a
        g = rhs.g;
    3fce:	f884 511b 	strb.w	r5, [r4, #283]	; 0x11b
        b = rhs.b;
    3fd2:	f884 a11c 	strb.w	sl, [r4, #284]	; 0x11c
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fd6:	f884 911d 	strb.w	r9, [r4, #285]	; 0x11d
        g = rhs.g;
    3fda:	f884 511e 	strb.w	r5, [r4, #286]	; 0x11e
        b = rhs.b;
    3fde:	f884 a11f 	strb.w	sl, [r4, #287]	; 0x11f
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fe2:	f884 9120 	strb.w	r9, [r4, #288]	; 0x120
        g = rhs.g;
    3fe6:	f884 5121 	strb.w	r5, [r4, #289]	; 0x121
        b = rhs.b;
    3fea:	f884 a122 	strb.w	sl, [r4, #290]	; 0x122
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3fee:	f884 9123 	strb.w	r9, [r4, #291]	; 0x123
        g = rhs.g;
    3ff2:	f884 5124 	strb.w	r5, [r4, #292]	; 0x124
        b = rhs.b;
    3ff6:	f884 a125 	strb.w	sl, [r4, #293]	; 0x125
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    3ffa:	f884 8126 	strb.w	r8, [r4, #294]	; 0x126
        g = rhs.g;
    3ffe:	f884 c127 	strb.w	ip, [r4, #295]	; 0x127
        b = rhs.b;
    4002:	f884 e128 	strb.w	lr, [r4, #296]	; 0x128
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4006:	f884 8129 	strb.w	r8, [r4, #297]	; 0x129
        g = rhs.g;
    400a:	f884 c12a 	strb.w	ip, [r4, #298]	; 0x12a
        b = rhs.b;
    400e:	f884 e12b 	strb.w	lr, [r4, #299]	; 0x12b
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4012:	f884 812c 	strb.w	r8, [r4, #300]	; 0x12c
        g = rhs.g;
    4016:	f884 c12d 	strb.w	ip, [r4, #301]	; 0x12d
        b = rhs.b;
    401a:	f884 e12e 	strb.w	lr, [r4, #302]	; 0x12e
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    401e:	f884 812f 	strb.w	r8, [r4, #303]	; 0x12f
        g = rhs.g;
    4022:	f884 c130 	strb.w	ip, [r4, #304]	; 0x130
        b = rhs.b;
    4026:	f884 e131 	strb.w	lr, [r4, #305]	; 0x131
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    402a:	f884 8132 	strb.w	r8, [r4, #306]	; 0x132
        g = rhs.g;
    402e:	f884 c133 	strb.w	ip, [r4, #307]	; 0x133
        b = rhs.b;
    4032:	f884 e134 	strb.w	lr, [r4, #308]	; 0x134
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4036:	f884 8135 	strb.w	r8, [r4, #309]	; 0x135
        g = rhs.g;
    403a:	f884 c136 	strb.w	ip, [r4, #310]	; 0x136
        b = rhs.b;
    403e:	f884 e137 	strb.w	lr, [r4, #311]	; 0x137
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4042:	f884 1138 	strb.w	r1, [r4, #312]	; 0x138
        g = rhs.g;
    4046:	f884 2139 	strb.w	r2, [r4, #313]	; 0x139
        b = rhs.b;
    404a:	f884 513a 	strb.w	r5, [r4, #314]	; 0x13a
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    404e:	f884 113b 	strb.w	r1, [r4, #315]	; 0x13b
        g = rhs.g;
    4052:	f884 213c 	strb.w	r2, [r4, #316]	; 0x13c
        b = rhs.b;
    4056:	f884 513d 	strb.w	r5, [r4, #317]	; 0x13d
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    405a:	f884 113e 	strb.w	r1, [r4, #318]	; 0x13e
        g = rhs.g;
    405e:	f884 213f 	strb.w	r2, [r4, #319]	; 0x13f
        b = rhs.b;
    4062:	f884 5140 	strb.w	r5, [r4, #320]	; 0x140
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4066:	f884 1141 	strb.w	r1, [r4, #321]	; 0x141
        g = rhs.g;
    406a:	f884 2142 	strb.w	r2, [r4, #322]	; 0x142
        b = rhs.b;
    406e:	f884 5143 	strb.w	r5, [r4, #323]	; 0x143
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4072:	f884 3144 	strb.w	r3, [r4, #324]	; 0x144
        g = rhs.g;
    4076:	f884 3145 	strb.w	r3, [r4, #325]	; 0x145
        b = rhs.b;
    407a:	f884 5146 	strb.w	r5, [r4, #326]	; 0x146
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    407e:	f884 3147 	strb.w	r3, [r4, #327]	; 0x147
        g = rhs.g;
    4082:	f884 3148 	strb.w	r3, [r4, #328]	; 0x148
        b = rhs.b;
    4086:	f884 5149 	strb.w	r5, [r4, #329]	; 0x149
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    408a:	f884 314a 	strb.w	r3, [r4, #330]	; 0x14a
        g = rhs.g;
    408e:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
        b = rhs.b;
    4092:	f884 514c 	strb.w	r5, [r4, #332]	; 0x14c
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4096:	f884 314d 	strb.w	r3, [r4, #333]	; 0x14d
        g = rhs.g;
    409a:	f884 014e 	strb.w	r0, [r4, #334]	; 0x14e
        b = rhs.b;
    409e:	f884 514f 	strb.w	r5, [r4, #335]	; 0x14f
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40a2:	f884 3150 	strb.w	r3, [r4, #336]	; 0x150
        g = rhs.g;
    40a6:	f884 0151 	strb.w	r0, [r4, #337]	; 0x151
        b = rhs.b;
    40aa:	f884 5152 	strb.w	r5, [r4, #338]	; 0x152
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40ae:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
        g = rhs.g;
    40b2:	f884 0154 	strb.w	r0, [r4, #340]	; 0x154
        b = rhs.b;
    40b6:	f884 5155 	strb.w	r5, [r4, #341]	; 0x155
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40ba:	f884 3156 	strb.w	r3, [r4, #342]	; 0x156
        g = rhs.g;
    40be:	f884 0157 	strb.w	r0, [r4, #343]	; 0x157
        b = rhs.b;
    40c2:	f884 5158 	strb.w	r5, [r4, #344]	; 0x158
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40c6:	f884 3159 	strb.w	r3, [r4, #345]	; 0x159
        g = rhs.g;
    40ca:	f884 315a 	strb.w	r3, [r4, #346]	; 0x15a
        b = rhs.b;
    40ce:	f884 515b 	strb.w	r5, [r4, #347]	; 0x15b
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40d2:	f884 315c 	strb.w	r3, [r4, #348]	; 0x15c
        g = rhs.g;
    40d6:	f884 315d 	strb.w	r3, [r4, #349]	; 0x15d
        b = rhs.b;
    40da:	f884 515e 	strb.w	r5, [r4, #350]	; 0x15e
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40de:	f884 315f 	strb.w	r3, [r4, #351]	; 0x15f
        g = rhs.g;
    40e2:	f884 3160 	strb.w	r3, [r4, #352]	; 0x160
        b = rhs.b;
    40e6:	f884 5161 	strb.w	r5, [r4, #353]	; 0x161
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40ea:	f884 1162 	strb.w	r1, [r4, #354]	; 0x162
        g = rhs.g;
    40ee:	f884 2163 	strb.w	r2, [r4, #355]	; 0x163
        b = rhs.b;
    40f2:	f884 5164 	strb.w	r5, [r4, #356]	; 0x164
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    40f6:	f884 1165 	strb.w	r1, [r4, #357]	; 0x165
        g = rhs.g;
    40fa:	f884 2166 	strb.w	r2, [r4, #358]	; 0x166
        b = rhs.b;
    40fe:	f884 5167 	strb.w	r5, [r4, #359]	; 0x167
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4102:	f884 7168 	strb.w	r7, [r4, #360]	; 0x168
        g = rhs.g;
    4106:	f884 5169 	strb.w	r5, [r4, #361]	; 0x169
        b = rhs.b;
    410a:	f884 616a 	strb.w	r6, [r4, #362]	; 0x16a
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    410e:	f884 716b 	strb.w	r7, [r4, #363]	; 0x16b
        g = rhs.g;
    4112:	f884 516c 	strb.w	r5, [r4, #364]	; 0x16c
        b = rhs.b;
    4116:	f884 616d 	strb.w	r6, [r4, #365]	; 0x16d
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    411a:	f884 716e 	strb.w	r7, [r4, #366]	; 0x16e
        g = rhs.g;
    411e:	f884 516f 	strb.w	r5, [r4, #367]	; 0x16f
        b = rhs.b;
    4122:	f884 6170 	strb.w	r6, [r4, #368]	; 0x170
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4126:	f884 7171 	strb.w	r7, [r4, #369]	; 0x171
        g = rhs.g;
    412a:	f884 5172 	strb.w	r5, [r4, #370]	; 0x172
        b = rhs.b;
    412e:	f884 6173 	strb.w	r6, [r4, #371]	; 0x173
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4132:	f884 7174 	strb.w	r7, [r4, #372]	; 0x174
        g = rhs.g;
    4136:	f884 5175 	strb.w	r5, [r4, #373]	; 0x175
        b = rhs.b;
    413a:	f884 6176 	strb.w	r6, [r4, #374]	; 0x176
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    413e:	f884 8177 	strb.w	r8, [r4, #375]	; 0x177
        g = rhs.g;
    4142:	f884 c178 	strb.w	ip, [r4, #376]	; 0x178
        b = rhs.b;
    4146:	f884 e179 	strb.w	lr, [r4, #377]	; 0x179
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    414a:	f884 817a 	strb.w	r8, [r4, #378]	; 0x17a
        g = rhs.g;
    414e:	f884 c17b 	strb.w	ip, [r4, #379]	; 0x17b
        b = rhs.b;
    4152:	f884 e17c 	strb.w	lr, [r4, #380]	; 0x17c
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4156:	f884 817d 	strb.w	r8, [r4, #381]	; 0x17d
        g = rhs.g;
    415a:	f884 c17e 	strb.w	ip, [r4, #382]	; 0x17e
        b = rhs.b;
    415e:	f884 e17f 	strb.w	lr, [r4, #383]	; 0x17f
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4162:	f884 8180 	strb.w	r8, [r4, #384]	; 0x180
        g = rhs.g;
    4166:	f884 c181 	strb.w	ip, [r4, #385]	; 0x181
        b = rhs.b;
    416a:	f884 e182 	strb.w	lr, [r4, #386]	; 0x182
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    416e:	f884 8183 	strb.w	r8, [r4, #387]	; 0x183
        g = rhs.g;
    4172:	f884 c184 	strb.w	ip, [r4, #388]	; 0x184
        b = rhs.b;
    4176:	f884 e185 	strb.w	lr, [r4, #389]	; 0x185
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    417a:	f884 3186 	strb.w	r3, [r4, #390]	; 0x186
        g = rhs.g;
    417e:	f884 3187 	strb.w	r3, [r4, #391]	; 0x187
        b = rhs.b;
    4182:	f884 5188 	strb.w	r5, [r4, #392]	; 0x188
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4186:	f884 3189 	strb.w	r3, [r4, #393]	; 0x189
        g = rhs.g;
    418a:	f884 318a 	strb.w	r3, [r4, #394]	; 0x18a
        b = rhs.b;
    418e:	f884 518b 	strb.w	r5, [r4, #395]	; 0x18b
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4192:	f884 318c 	strb.w	r3, [r4, #396]	; 0x18c
        g = rhs.g;
    4196:	f884 318d 	strb.w	r3, [r4, #397]	; 0x18d
        b = rhs.b;
    419a:	f884 518e 	strb.w	r5, [r4, #398]	; 0x18e
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    419e:	f884 318f 	strb.w	r3, [r4, #399]	; 0x18f
        g = rhs.g;
    41a2:	f884 3190 	strb.w	r3, [r4, #400]	; 0x190
        b = rhs.b;
    41a6:	f884 5191 	strb.w	r5, [r4, #401]	; 0x191
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41aa:	f884 3192 	strb.w	r3, [r4, #402]	; 0x192
        g = rhs.g;
    41ae:	f884 3193 	strb.w	r3, [r4, #403]	; 0x193
        b = rhs.b;
    41b2:	f884 5194 	strb.w	r5, [r4, #404]	; 0x194
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41b6:	f884 3195 	strb.w	r3, [r4, #405]	; 0x195
        g = rhs.g;
    41ba:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
        b = rhs.b;
    41be:	f884 5197 	strb.w	r5, [r4, #407]	; 0x197
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41c2:	f884 3198 	strb.w	r3, [r4, #408]	; 0x198
        g = rhs.g;
    41c6:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
        b = rhs.b;
    41ca:	f884 519a 	strb.w	r5, [r4, #410]	; 0x19a
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41ce:	f884 319b 	strb.w	r3, [r4, #411]	; 0x19b
        g = rhs.g;
    41d2:	f884 019c 	strb.w	r0, [r4, #412]	; 0x19c
        b = rhs.b;
    41d6:	f884 519d 	strb.w	r5, [r4, #413]	; 0x19d
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41da:	f884 319e 	strb.w	r3, [r4, #414]	; 0x19e
        g = rhs.g;
    41de:	f884 019f 	strb.w	r0, [r4, #415]	; 0x19f
        b = rhs.b;
    41e2:	f884 51a0 	strb.w	r5, [r4, #416]	; 0x1a0
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41e6:	f884 31a1 	strb.w	r3, [r4, #417]	; 0x1a1
        g = rhs.g;
    41ea:	f884 01a2 	strb.w	r0, [r4, #418]	; 0x1a2
        b = rhs.b;
    41ee:	f884 51a3 	strb.w	r5, [r4, #419]	; 0x1a3
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    41f2:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
        g = rhs.g;
    41f6:	f884 01a5 	strb.w	r0, [r4, #421]	; 0x1a5
        b = rhs.b;
    41fa:	f884 51a6 	strb.w	r5, [r4, #422]	; 0x1a6
    41fe:	e003      	b.n	4208 <Meltdown::CMeltdownLED::CMeltdownLED()+0x3e4>
    4200:	000093bc 	.word	0x000093bc
    4204:	001b7740 	.word	0x001b7740
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4208:	20d5      	movs	r0, #213	; 0xd5
    420a:	f884 81a7 	strb.w	r8, [r4, #423]	; 0x1a7
        g = rhs.g;
    420e:	f884 c1a8 	strb.w	ip, [r4, #424]	; 0x1a8
        b = rhs.b;
    4212:	f884 e1a9 	strb.w	lr, [r4, #425]	; 0x1a9
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4216:	f884 81aa 	strb.w	r8, [r4, #426]	; 0x1aa
        g = rhs.g;
    421a:	f884 c1ab 	strb.w	ip, [r4, #427]	; 0x1ab
        b = rhs.b;
    421e:	f884 e1ac 	strb.w	lr, [r4, #428]	; 0x1ac
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4222:	f884 81ad 	strb.w	r8, [r4, #429]	; 0x1ad
        g = rhs.g;
    4226:	f884 c1ae 	strb.w	ip, [r4, #430]	; 0x1ae
        b = rhs.b;
    422a:	f884 e1af 	strb.w	lr, [r4, #431]	; 0x1af
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    422e:	f884 71b0 	strb.w	r7, [r4, #432]	; 0x1b0
        g = rhs.g;
    4232:	f884 51b1 	strb.w	r5, [r4, #433]	; 0x1b1
        b = rhs.b;
    4236:	f884 61b2 	strb.w	r6, [r4, #434]	; 0x1b2
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    423a:	f884 71b3 	strb.w	r7, [r4, #435]	; 0x1b3
        g = rhs.g;
    423e:	f884 51b4 	strb.w	r5, [r4, #436]	; 0x1b4
        b = rhs.b;
    4242:	f884 61b5 	strb.w	r6, [r4, #437]	; 0x1b5
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4246:	f884 71b6 	strb.w	r7, [r4, #438]	; 0x1b6
        g = rhs.g;
    424a:	f884 51b7 	strb.w	r5, [r4, #439]	; 0x1b7
        b = rhs.b;
    424e:	f884 61b8 	strb.w	r6, [r4, #440]	; 0x1b8
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4252:	f884 71b9 	strb.w	r7, [r4, #441]	; 0x1b9
        g = rhs.g;
    4256:	f884 51ba 	strb.w	r5, [r4, #442]	; 0x1ba
        b = rhs.b;
    425a:	f884 61bb 	strb.w	r6, [r4, #443]	; 0x1bb
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    425e:	f884 71bc 	strb.w	r7, [r4, #444]	; 0x1bc
        g = rhs.g;
    4262:	f884 51bd 	strb.w	r5, [r4, #445]	; 0x1bd
        b = rhs.b;
    4266:	f884 61be 	strb.w	r6, [r4, #446]	; 0x1be
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    426a:	f884 81bf 	strb.w	r8, [r4, #447]	; 0x1bf
        g = rhs.g;
    426e:	f884 c1c0 	strb.w	ip, [r4, #448]	; 0x1c0
        b = rhs.b;
    4272:	f884 e1c1 	strb.w	lr, [r4, #449]	; 0x1c1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4276:	f884 81c2 	strb.w	r8, [r4, #450]	; 0x1c2
        g = rhs.g;
    427a:	f884 c1c3 	strb.w	ip, [r4, #451]	; 0x1c3
        b = rhs.b;
    427e:	f884 e1c4 	strb.w	lr, [r4, #452]	; 0x1c4
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4282:	f884 81c5 	strb.w	r8, [r4, #453]	; 0x1c5
        g = rhs.g;
    4286:	f884 c1c6 	strb.w	ip, [r4, #454]	; 0x1c6
    428a:	f04f 082a 	mov.w	r8, #42	; 0x2a
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    428e:	f04f 0cab 	mov.w	ip, #171	; 0xab
        g = rhs.g;
        b = rhs.b;
    4292:	f884 e1c7 	strb.w	lr, [r4, #455]	; 0x1c7
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4296:	f884 91c8 	strb.w	r9, [r4, #456]	; 0x1c8
        g = rhs.g;
    429a:	f04f 0e55 	mov.w	lr, #85	; 0x55
    429e:	f884 51c9 	strb.w	r5, [r4, #457]	; 0x1c9
        b = rhs.b;
    42a2:	f884 a1ca 	strb.w	sl, [r4, #458]	; 0x1ca
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42a6:	f884 91cb 	strb.w	r9, [r4, #459]	; 0x1cb
        g = rhs.g;
    42aa:	f884 51cc 	strb.w	r5, [r4, #460]	; 0x1cc
        b = rhs.b;
    42ae:	f884 a1cd 	strb.w	sl, [r4, #461]	; 0x1cd
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42b2:	f884 91ce 	strb.w	r9, [r4, #462]	; 0x1ce
        g = rhs.g;
    42b6:	f884 51cf 	strb.w	r5, [r4, #463]	; 0x1cf
        b = rhs.b;
    42ba:	f884 a1d0 	strb.w	sl, [r4, #464]	; 0x1d0
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42be:	f884 11d1 	strb.w	r1, [r4, #465]	; 0x1d1
        g = rhs.g;
    42c2:	f884 21d2 	strb.w	r2, [r4, #466]	; 0x1d2
        b = rhs.b;
    42c6:	f884 51d3 	strb.w	r5, [r4, #467]	; 0x1d3
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42ca:	f884 11d4 	strb.w	r1, [r4, #468]	; 0x1d4
        g = rhs.g;
    42ce:	f884 21d5 	strb.w	r2, [r4, #469]	; 0x1d5
        b = rhs.b;
    42d2:	f884 51d6 	strb.w	r5, [r4, #470]	; 0x1d6
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42d6:	f884 11d7 	strb.w	r1, [r4, #471]	; 0x1d7
        g = rhs.g;
    42da:	f884 21d8 	strb.w	r2, [r4, #472]	; 0x1d8
        b = rhs.b;
    42de:	f884 51d9 	strb.w	r5, [r4, #473]	; 0x1d9
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42e2:	f884 31da 	strb.w	r3, [r4, #474]	; 0x1da
        g = rhs.g;
    42e6:	f884 31db 	strb.w	r3, [r4, #475]	; 0x1db
        b = rhs.b;
    42ea:	f884 51dc 	strb.w	r5, [r4, #476]	; 0x1dc
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42ee:	f884 31dd 	strb.w	r3, [r4, #477]	; 0x1dd
        g = rhs.g;
    42f2:	f884 31de 	strb.w	r3, [r4, #478]	; 0x1de
        b = rhs.b;
    42f6:	f884 51df 	strb.w	r5, [r4, #479]	; 0x1df
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    42fa:	f884 31e0 	strb.w	r3, [r4, #480]	; 0x1e0
        g = rhs.g;
    42fe:	f884 31e1 	strb.w	r3, [r4, #481]	; 0x1e1
        b = rhs.b;
    4302:	f884 51e2 	strb.w	r5, [r4, #482]	; 0x1e2
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4306:	f884 91e3 	strb.w	r9, [r4, #483]	; 0x1e3
        g = rhs.g;
    430a:	f884 51e4 	strb.w	r5, [r4, #484]	; 0x1e4
        b = rhs.b;
    430e:	f884 a1e5 	strb.w	sl, [r4, #485]	; 0x1e5
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4312:	f884 91e6 	strb.w	r9, [r4, #486]	; 0x1e6
        g = rhs.g;
    4316:	f884 51e7 	strb.w	r5, [r4, #487]	; 0x1e7
        b = rhs.b;
    431a:	f884 a1e8 	strb.w	sl, [r4, #488]	; 0x1e8
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    431e:	f884 91e9 	strb.w	r9, [r4, #489]	; 0x1e9
        g = rhs.g;
    4322:	f884 51ea 	strb.w	r5, [r4, #490]	; 0x1ea
        b = rhs.b;
    4326:	f884 a1eb 	strb.w	sl, [r4, #491]	; 0x1eb
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    432a:	f884 71ec 	strb.w	r7, [r4, #492]	; 0x1ec
        g = rhs.g;
    432e:	f04f 0a7f 	mov.w	sl, #127	; 0x7f
    4332:	f884 51ed 	strb.w	r5, [r4, #493]	; 0x1ed
        b = rhs.b;
    4336:	f884 61ee 	strb.w	r6, [r4, #494]	; 0x1ee
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    433a:	f884 71ef 	strb.w	r7, [r4, #495]	; 0x1ef
        g = rhs.g;
    433e:	f884 51f0 	strb.w	r5, [r4, #496]	; 0x1f0
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4342:	2756      	movs	r7, #86	; 0x56
        g = rhs.g;
        b = rhs.b;
    4344:	f884 61f1 	strb.w	r6, [r4, #497]	; 0x1f1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4348:	f884 11f2 	strb.w	r1, [r4, #498]	; 0x1f2
        g = rhs.g;
    434c:	f884 21f3 	strb.w	r2, [r4, #499]	; 0x1f3
        b = rhs.b;
    4350:	f884 51f4 	strb.w	r5, [r4, #500]	; 0x1f4
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4354:	f884 11f5 	strb.w	r1, [r4, #501]	; 0x1f5
        g = rhs.g;
    4358:	f884 21f6 	strb.w	r2, [r4, #502]	; 0x1f6
        b = rhs.b;
    435c:	f884 51f7 	strb.w	r5, [r4, #503]	; 0x1f7
    4360:	2681      	movs	r6, #129	; 0x81
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4362:	f884 31f8 	strb.w	r3, [r4, #504]	; 0x1f8
        g = rhs.g;
        b = rhs.b;
    4366:	212b      	movs	r1, #43	; 0x2b

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    4368:	f884 320b 	strb.w	r3, [r4, #523]	; 0x20b
        b = rhs.b;
    436c:	f884 3218 	strb.w	r3, [r4, #536]	; 0x218
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4370:	2284      	movs	r2, #132	; 0x84
        g = rhs.g;
        b = rhs.b;
    4372:	237c      	movs	r3, #124	; 0x7c

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    4374:	f884 51f9 	strb.w	r5, [r4, #505]	; 0x1f9
        b = rhs.b;
    4378:	f884 51fa 	strb.w	r5, [r4, #506]	; 0x1fa
    437c:	f884 51fd 	strb.w	r5, [r4, #509]	; 0x1fd
    4380:	f884 5200 	strb.w	r5, [r4, #512]	; 0x200
    4384:	f884 5203 	strb.w	r5, [r4, #515]	; 0x203
    4388:	f884 5206 	strb.w	r5, [r4, #518]	; 0x206
    438c:	f884 5209 	strb.w	r5, [r4, #521]	; 0x209
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4390:	f884 520a 	strb.w	r5, [r4, #522]	; 0x20a
        g = rhs.g;
        b = rhs.b;
    4394:	f884 520c 	strb.w	r5, [r4, #524]	; 0x20c
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4398:	f884 520d 	strb.w	r5, [r4, #525]	; 0x20d
    439c:	f884 5210 	strb.w	r5, [r4, #528]	; 0x210
    43a0:	f884 5213 	strb.w	r5, [r4, #531]	; 0x213
    43a4:	f884 5216 	strb.w	r5, [r4, #534]	; 0x216
        g = rhs.g;
    43a8:	f884 5217 	strb.w	r5, [r4, #535]	; 0x217
        b = rhs.b;
    43ac:	f884 b215 	strb.w	fp, [r4, #533]	; 0x215
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    43b0:	f884 01fb 	strb.w	r0, [r4, #507]	; 0x1fb
        g = rhs.g;
    43b4:	f884 0208 	strb.w	r0, [r4, #520]	; 0x208
    43b8:	f884 020e 	strb.w	r0, [r4, #526]	; 0x20e
    43bc:	f884 81fc 	strb.w	r8, [r4, #508]	; 0x1fc
        b = rhs.b;
    43c0:	f884 820f 	strb.w	r8, [r4, #527]	; 0x20f
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    43c4:	f884 c1fe 	strb.w	ip, [r4, #510]	; 0x1fe
    43c8:	f884 c201 	strb.w	ip, [r4, #513]	; 0x201
    43cc:	f884 c204 	strb.w	ip, [r4, #516]	; 0x204
        g = rhs.g;
    43d0:	f884 c205 	strb.w	ip, [r4, #517]	; 0x205
    43d4:	f884 c211 	strb.w	ip, [r4, #529]	; 0x211
    43d8:	f884 e1ff 	strb.w	lr, [r4, #511]	; 0x1ff
        b = rhs.b;
    43dc:	f884 e212 	strb.w	lr, [r4, #530]	; 0x212

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    43e0:	f884 a202 	strb.w	sl, [r4, #514]	; 0x202
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    43e4:	f884 7207 	strb.w	r7, [r4, #519]	; 0x207
        g = rhs.g;
    43e8:	f884 7214 	strb.w	r7, [r4, #532]	; 0x214
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    43ec:	f04f 0bb5 	mov.w	fp, #181	; 0xb5
    43f0:	f884 8219 	strb.w	r8, [r4, #537]	; 0x219
        g = rhs.g;
        b = rhs.b;
    43f4:	274b      	movs	r7, #75	; 0x4b
    43f6:	f884 021b 	strb.w	r0, [r4, #539]	; 0x21b
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    43fa:	f884 a21f 	strb.w	sl, [r4, #543]	; 0x21f
    43fe:	f884 0225 	strb.w	r0, [r4, #549]	; 0x225
        g = rhs.g;
        b = rhs.b;
    4402:	f884 6221 	strb.w	r6, [r4, #545]	; 0x221
    4406:	f884 1227 	strb.w	r1, [r4, #551]	; 0x227
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    440a:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
        g = rhs.g;
        b = rhs.b;
    440e:	f884 322d 	strb.w	r3, [r4, #557]	; 0x22d
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4412:	f04f 08e5 	mov.w	r8, #229	; 0xe5
        g = rhs.g;
        b = rhs.b;
    4416:	f04f 0a1b 	mov.w	sl, #27
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    441a:	20e8      	movs	r0, #232	; 0xe8
        g = rhs.g;
    441c:	2617      	movs	r6, #23
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    441e:	21b8      	movs	r1, #184	; 0xb8
        g = rhs.g;
    4420:	2247      	movs	r2, #71	; 0x47
    4422:	2377      	movs	r3, #119	; 0x77
    4424:	f884 521a 	strb.w	r5, [r4, #538]	; 0x21a
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4428:	f884 e21c 	strb.w	lr, [r4, #540]	; 0x21c
        g = rhs.g;
    442c:	f884 521d 	strb.w	r5, [r4, #541]	; 0x21d
        b = rhs.b;
    4430:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    4434:	f884 5220 	strb.w	r5, [r4, #544]	; 0x220
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4438:	f884 c222 	strb.w	ip, [r4, #546]	; 0x222
        g = rhs.g;
    443c:	f884 5223 	strb.w	r5, [r4, #547]	; 0x223
        b = rhs.b;
    4440:	f884 e224 	strb.w	lr, [r4, #548]	; 0x224

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    4444:	f884 5226 	strb.w	r5, [r4, #550]	; 0x226
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4448:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
        g = rhs.g;
    444c:	f884 5229 	strb.w	r5, [r4, #553]	; 0x229
        b = rhs.b;
    4450:	f884 c22a 	strb.w	ip, [r4, #554]	; 0x22a

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    4454:	f884 522c 	strb.w	r5, [r4, #556]	; 0x22c
    4458:	f884 522f 	strb.w	r5, [r4, #559]	; 0x22f
    445c:	f884 5232 	strb.w	r5, [r4, #562]	; 0x232
        b = rhs.b;
    4460:	f884 5236 	strb.w	r5, [r4, #566]	; 0x236
    4464:	f884 5239 	strb.w	r5, [r4, #569]	; 0x239
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4468:	f884 b22e 	strb.w	fp, [r4, #558]	; 0x22e
        g = rhs.g;
        b = rhs.b;
    446c:	f884 7230 	strb.w	r7, [r4, #560]	; 0x230
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4470:	f884 8231 	strb.w	r8, [r4, #561]	; 0x231
        g = rhs.g;
        b = rhs.b;
    4474:	f884 a233 	strb.w	sl, [r4, #563]	; 0x233
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4478:	f884 0234 	strb.w	r0, [r4, #564]	; 0x234
        g = rhs.g;
    447c:	f884 6235 	strb.w	r6, [r4, #565]	; 0x235
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4480:	f884 1237 	strb.w	r1, [r4, #567]	; 0x237
        g = rhs.g;
    4484:	f884 2238 	strb.w	r2, [r4, #568]	; 0x238
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4488:	f04f 0bdd 	mov.w	fp, #221	; 0xdd
    448c:	f884 c23a 	strb.w	ip, [r4, #570]	; 0x23a
        g = rhs.g;
    4490:	2722      	movs	r7, #34	; 0x22
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4492:	f04f 08f2 	mov.w	r8, #242	; 0xf2
        g = rhs.g;
        b = rhs.b;
    4496:	f04f 0a0e 	mov.w	sl, #14
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    449a:	20c2      	movs	r0, #194	; 0xc2
    449c:	268f      	movs	r6, #143	; 0x8f
        g = rhs.g;
        b = rhs.b;
    449e:	2171      	movs	r1, #113	; 0x71
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44a0:	225f      	movs	r2, #95	; 0x5f
        g = rhs.g;
        b = rhs.b;
    44a2:	f884 523c 	strb.w	r5, [r4, #572]	; 0x23c
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44a6:	f884 c23d 	strb.w	ip, [r4, #573]	; 0x23d
        g = rhs.g;
    44aa:	f884 c23e 	strb.w	ip, [r4, #574]	; 0x23e
        b = rhs.b;
    44ae:	f884 523f 	strb.w	r5, [r4, #575]	; 0x23f
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44b2:	f884 c240 	strb.w	ip, [r4, #576]	; 0x240
        g = rhs.g;
    44b6:	f884 e241 	strb.w	lr, [r4, #577]	; 0x241
        b = rhs.b;
    44ba:	f04f 0ca1 	mov.w	ip, #161	; 0xa1
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44be:	f04f 0e2f 	mov.w	lr, #47	; 0x2f
        g = rhs.g;
        b = rhs.b;
    44c2:	f884 5242 	strb.w	r5, [r4, #578]	; 0x242
    44c6:	f884 5245 	strb.w	r5, [r4, #581]	; 0x245

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    44ca:	f884 5247 	strb.w	r5, [r4, #583]	; 0x247
    44ce:	f884 524a 	strb.w	r5, [r4, #586]	; 0x24a
        b = rhs.b;
    44d2:	f884 924b 	strb.w	r9, [r4, #587]	; 0x24b

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    44d6:	f884 524d 	strb.w	r5, [r4, #589]	; 0x24d
        b = rhs.b;
    44da:	f04f 09d0 	mov.w	r9, #208	; 0xd0

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    44de:	f884 5250 	strb.w	r5, [r4, #592]	; 0x250
    44e2:	f884 5253 	strb.w	r5, [r4, #595]	; 0x253
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44e6:	f884 5255 	strb.w	r5, [r4, #597]	; 0x255
        g = rhs.g;
    44ea:	f884 323b 	strb.w	r3, [r4, #571]	; 0x23b
    44ee:	2507      	movs	r5, #7
        b = rhs.b;
    44f0:	23f9      	movs	r3, #249	; 0xf9
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44f2:	f884 0249 	strb.w	r0, [r4, #585]	; 0x249
    44f6:	f884 b243 	strb.w	fp, [r4, #579]	; 0x243
        g = rhs.g;
    44fa:	f884 7244 	strb.w	r7, [r4, #580]	; 0x244
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    44fe:	f884 8246 	strb.w	r8, [r4, #582]	; 0x246
        g = rhs.g;
        b = rhs.b;
    4502:	f884 a248 	strb.w	sl, [r4, #584]	; 0x248
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4506:	f884 624c 	strb.w	r6, [r4, #588]	; 0x24c
        g = rhs.g;
        b = rhs.b;
    450a:	f884 124e 	strb.w	r1, [r4, #590]	; 0x24e
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    450e:	f884 224f 	strb.w	r2, [r4, #591]	; 0x24f
        g = rhs.g;
        b = rhs.b;
    4512:	f884 c251 	strb.w	ip, [r4, #593]	; 0x251
    }

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    4516:	f884 e252 	strb.w	lr, [r4, #594]	; 0x252
        g = rhs.g;
        b = rhs.b;
    451a:	f884 9254 	strb.w	r9, [r4, #596]	; 0x254

    /// allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
    451e:	f884 5256 	strb.w	r5, [r4, #598]	; 0x256
        b = rhs.b;
    4522:	f884 3257 	strb.w	r3, [r4, #599]	; 0x257
	{
	}
    4526:	4620      	mov	r0, r4
    4528:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000452c <_GLOBAL__sub_I__ZN8Meltdown11MeltdownLEDE>:
#include "MeltdownLED.h"

namespace Meltdown
{
	CMeltdownLED MeltdownLED;
    452c:	4801      	ldr	r0, [pc, #4]	; (4534 <_GLOBAL__sub_I__ZN8Meltdown11MeltdownLEDE+0x8>)
    452e:	f7ff bc79 	b.w	3e24 <Meltdown::CMeltdownLED::CMeltdownLED()>
    4532:	bf00      	nop
    4534:	1fffb06c 	.word	0x1fffb06c

00004538 <_GLOBAL__sub_I__ZN8Meltdown14MeltdownLoggerE>:

namespace Meltdown
{
	CMeltdownLogger MeltdownLogger;

	CMeltdownLogger::CMeltdownLogger() {}
    4538:	4b01      	ldr	r3, [pc, #4]	; (4540 <_GLOBAL__sub_I__ZN8Meltdown14MeltdownLoggerE+0x8>)
    453a:	2200      	movs	r2, #0
    453c:	701a      	strb	r2, [r3, #0]
    453e:	4770      	bx	lr
    4540:	1fffb2c4 	.word	0x1fffb2c4

00004544 <Meltdown::CMeltdownSerial::~CMeltdownSerial()>:
{

#ifndef MELTDOWN_SERIAL
#define MELTDOWN_SERIAL

	class CMeltdownSerial
    4544:	b510      	push	{r4, lr}
    4546:	4604      	mov	r4, r0
    4548:	f500 70b4 	add.w	r0, r0, #360	; 0x168
    454c:	f002 faf6 	bl	6b3c <String::~String()>
    4550:	f504 70ac 	add.w	r0, r4, #344	; 0x158
    4554:	f002 faf2 	bl	6b3c <String::~String()>
    4558:	f504 70a4 	add.w	r0, r4, #328	; 0x148
    455c:	f002 faee 	bl	6b3c <String::~String()>
    4560:	f504 709c 	add.w	r0, r4, #312	; 0x138
    4564:	f002 faea 	bl	6b3c <String::~String()>
    4568:	f504 7094 	add.w	r0, r4, #296	; 0x128
    456c:	f002 fae6 	bl	6b3c <String::~String()>
    4570:	f504 708c 	add.w	r0, r4, #280	; 0x118
    4574:	f002 fae2 	bl	6b3c <String::~String()>
    4578:	f504 7084 	add.w	r0, r4, #264	; 0x108
    457c:	f002 fade 	bl	6b3c <String::~String()>
    4580:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
    4584:	f002 fada 	bl	6b3c <String::~String()>
    4588:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
    458c:	f002 fad6 	bl	6b3c <String::~String()>
    4590:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
    4594:	f002 fad2 	bl	6b3c <String::~String()>
    4598:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
    459c:	f002 face 	bl	6b3c <String::~String()>
    45a0:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
    45a4:	f002 faca 	bl	6b3c <String::~String()>
    45a8:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
    45ac:	f002 fac6 	bl	6b3c <String::~String()>
    45b0:	f104 0098 	add.w	r0, r4, #152	; 0x98
    45b4:	f002 fac2 	bl	6b3c <String::~String()>
    45b8:	f104 0088 	add.w	r0, r4, #136	; 0x88
    45bc:	f002 fabe 	bl	6b3c <String::~String()>
    45c0:	f104 0078 	add.w	r0, r4, #120	; 0x78
    45c4:	f002 faba 	bl	6b3c <String::~String()>
    45c8:	f104 0068 	add.w	r0, r4, #104	; 0x68
    45cc:	f002 fab6 	bl	6b3c <String::~String()>
    45d0:	f104 0058 	add.w	r0, r4, #88	; 0x58
    45d4:	f002 fab2 	bl	6b3c <String::~String()>
    45d8:	f104 0048 	add.w	r0, r4, #72	; 0x48
    45dc:	f002 faae 	bl	6b3c <String::~String()>
    45e0:	f104 0038 	add.w	r0, r4, #56	; 0x38
    45e4:	f002 faaa 	bl	6b3c <String::~String()>
    45e8:	f104 0028 	add.w	r0, r4, #40	; 0x28
    45ec:	f002 faa6 	bl	6b3c <String::~String()>
    45f0:	f104 0018 	add.w	r0, r4, #24
    45f4:	f002 faa2 	bl	6b3c <String::~String()>
    45f8:	1d20      	adds	r0, r4, #4
    45fa:	f002 fa9f 	bl	6b3c <String::~String()>
    45fe:	4620      	mov	r0, r4
    4600:	bd10      	pop	{r4, pc}
    4602:	bf00      	nop

00004604 <Meltdown::CMeltdownSerial::CMeltdownSerial()>:

namespace Meltdown
{
	CMeltdownSerial MeltdownSerial;

	CMeltdownSerial::CMeltdownSerial()
    4604:	b538      	push	{r3, r4, r5, lr}
    4606:	1d05      	adds	r5, r0, #4
    4608:	4604      	mov	r4, r0
    460a:	2100      	movs	r1, #0
    460c:	4628      	mov	r0, r5
    460e:	f002 fad5 	bl	6bbc <String::String(char const*)>
    4612:	f104 0018 	add.w	r0, r4, #24
    4616:	493a      	ldr	r1, [pc, #232]	; (4700 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0xfc>)
    4618:	f002 fad0 	bl	6bbc <String::String(char const*)>
    461c:	f104 0028 	add.w	r0, r4, #40	; 0x28
    4620:	4938      	ldr	r1, [pc, #224]	; (4704 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x100>)
    4622:	f002 facb 	bl	6bbc <String::String(char const*)>
    4626:	f104 0038 	add.w	r0, r4, #56	; 0x38
    462a:	4937      	ldr	r1, [pc, #220]	; (4708 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x104>)
    462c:	f002 fac6 	bl	6bbc <String::String(char const*)>
    4630:	f104 0048 	add.w	r0, r4, #72	; 0x48
    4634:	4935      	ldr	r1, [pc, #212]	; (470c <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x108>)
    4636:	f002 fac1 	bl	6bbc <String::String(char const*)>
    463a:	f104 0058 	add.w	r0, r4, #88	; 0x58
    463e:	4934      	ldr	r1, [pc, #208]	; (4710 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x10c>)
    4640:	f002 fabc 	bl	6bbc <String::String(char const*)>
    4644:	f104 0068 	add.w	r0, r4, #104	; 0x68
    4648:	4932      	ldr	r1, [pc, #200]	; (4714 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x110>)
    464a:	f002 fab7 	bl	6bbc <String::String(char const*)>
    464e:	f104 0078 	add.w	r0, r4, #120	; 0x78
    4652:	4931      	ldr	r1, [pc, #196]	; (4718 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x114>)
    4654:	f002 fab2 	bl	6bbc <String::String(char const*)>
    4658:	f104 0088 	add.w	r0, r4, #136	; 0x88
    465c:	492f      	ldr	r1, [pc, #188]	; (471c <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x118>)
    465e:	f002 faad 	bl	6bbc <String::String(char const*)>
    4662:	f104 0098 	add.w	r0, r4, #152	; 0x98
    4666:	492e      	ldr	r1, [pc, #184]	; (4720 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x11c>)
    4668:	f002 faa8 	bl	6bbc <String::String(char const*)>
    466c:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
    4670:	492c      	ldr	r1, [pc, #176]	; (4724 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x120>)
    4672:	f002 faa3 	bl	6bbc <String::String(char const*)>
    4676:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
    467a:	492b      	ldr	r1, [pc, #172]	; (4728 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x124>)
    467c:	f002 fa9e 	bl	6bbc <String::String(char const*)>
    4680:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
    4684:	4929      	ldr	r1, [pc, #164]	; (472c <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x128>)
    4686:	f002 fa99 	bl	6bbc <String::String(char const*)>
    468a:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
    468e:	4928      	ldr	r1, [pc, #160]	; (4730 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x12c>)
    4690:	f002 fa94 	bl	6bbc <String::String(char const*)>
    4694:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
    4698:	4926      	ldr	r1, [pc, #152]	; (4734 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x130>)
    469a:	f002 fa8f 	bl	6bbc <String::String(char const*)>
    469e:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
    46a2:	4925      	ldr	r1, [pc, #148]	; (4738 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x134>)
    46a4:	f002 fa8a 	bl	6bbc <String::String(char const*)>
    46a8:	f504 7084 	add.w	r0, r4, #264	; 0x108
    46ac:	4923      	ldr	r1, [pc, #140]	; (473c <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x138>)
    46ae:	f002 fa85 	bl	6bbc <String::String(char const*)>
    46b2:	f504 708c 	add.w	r0, r4, #280	; 0x118
    46b6:	4922      	ldr	r1, [pc, #136]	; (4740 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x13c>)
    46b8:	f002 fa80 	bl	6bbc <String::String(char const*)>
    46bc:	f504 7094 	add.w	r0, r4, #296	; 0x128
    46c0:	4920      	ldr	r1, [pc, #128]	; (4744 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x140>)
    46c2:	f002 fa7b 	bl	6bbc <String::String(char const*)>
    46c6:	f504 709c 	add.w	r0, r4, #312	; 0x138
    46ca:	491f      	ldr	r1, [pc, #124]	; (4748 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x144>)
    46cc:	f002 fa76 	bl	6bbc <String::String(char const*)>
    46d0:	f504 70a4 	add.w	r0, r4, #328	; 0x148
    46d4:	491d      	ldr	r1, [pc, #116]	; (474c <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x148>)
    46d6:	f002 fa71 	bl	6bbc <String::String(char const*)>
    46da:	f504 70ac 	add.w	r0, r4, #344	; 0x158
    46de:	491c      	ldr	r1, [pc, #112]	; (4750 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x14c>)
    46e0:	f002 fa6c 	bl	6bbc <String::String(char const*)>
    46e4:	f504 70b4 	add.w	r0, r4, #360	; 0x168
    46e8:	491a      	ldr	r1, [pc, #104]	; (4754 <Meltdown::CMeltdownSerial::CMeltdownSerial()+0x150>)
    46ea:	f002 fa67 	bl	6bbc <String::String(char const*)>
	{
		m_analogTolerance = 15;
    46ee:	230f      	movs	r3, #15
		m_inputString.reserve(100);
    46f0:	4628      	mov	r0, r5
{
	CMeltdownSerial MeltdownSerial;

	CMeltdownSerial::CMeltdownSerial()
	{
		m_analogTolerance = 15;
    46f2:	6023      	str	r3, [r4, #0]
		m_inputString.reserve(100);
    46f4:	2164      	movs	r1, #100	; 0x64
    46f6:	f002 fa29 	bl	6b4c <String::reserve(unsigned int)>
	}
    46fa:	4620      	mov	r0, r4
    46fc:	bd38      	pop	{r3, r4, r5, pc}
    46fe:	bf00      	nop
    4700:	00009470 	.word	0x00009470
    4704:	00009478 	.word	0x00009478
    4708:	00009480 	.word	0x00009480
    470c:	00009488 	.word	0x00009488
    4710:	00009490 	.word	0x00009490
    4714:	00009498 	.word	0x00009498
    4718:	000094a0 	.word	0x000094a0
    471c:	000094a8 	.word	0x000094a8
    4720:	000094b0 	.word	0x000094b0
    4724:	000094b8 	.word	0x000094b8
    4728:	000094c0 	.word	0x000094c0
    472c:	000094c8 	.word	0x000094c8
    4730:	000094d0 	.word	0x000094d0
    4734:	000094d8 	.word	0x000094d8
    4738:	000094e0 	.word	0x000094e0
    473c:	000094e8 	.word	0x000094e8
    4740:	000094f0 	.word	0x000094f0
    4744:	000094f8 	.word	0x000094f8
    4748:	00009500 	.word	0x00009500
    474c:	00009508 	.word	0x00009508
    4750:	00009510 	.word	0x00009510
    4754:	00009518 	.word	0x00009518

00004758 <_GLOBAL__sub_I__ZN8Meltdown14MeltdownSerialE>:
    4758:	b510      	push	{r4, lr}
#include "MeltdownSerial.h"

namespace Meltdown
{
	CMeltdownSerial MeltdownSerial;
    475a:	4c05      	ldr	r4, [pc, #20]	; (4770 <_GLOBAL__sub_I__ZN8Meltdown14MeltdownSerialE+0x18>)
    475c:	4620      	mov	r0, r4
    475e:	f7ff ff51 	bl	4604 <Meltdown::CMeltdownSerial::CMeltdownSerial()>
    4762:	4620      	mov	r0, r4
    4764:	4a03      	ldr	r2, [pc, #12]	; (4774 <_GLOBAL__sub_I__ZN8Meltdown14MeltdownSerialE+0x1c>)
    4766:	4904      	ldr	r1, [pc, #16]	; (4778 <_GLOBAL__sub_I__ZN8Meltdown14MeltdownSerialE+0x20>)
	CMeltdownSerial::CMeltdownSerial()
	{
		m_analogTolerance = 15;
		m_inputString.reserve(100);
	}
    4768:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#include "MeltdownSerial.h"

namespace Meltdown
{
	CMeltdownSerial MeltdownSerial;
    476c:	f002 bd12 	b.w	7194 <__aeabi_atexit>
    4770:	1fffb2c8 	.word	0x1fffb2c8
    4774:	1fff8720 	.word	0x1fff8720
    4778:	00004545 	.word	0x00004545

0000477c <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    477c:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
    477e:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    4782:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    4786:	d16f      	bne.n	4868 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    4788:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    478a:	d341      	bcc.n	4810 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    478c:	f851 3b04 	ldr.w	r3, [r1], #4
    4790:	f840 3b04 	str.w	r3, [r0], #4
    4794:	f851 3b04 	ldr.w	r3, [r1], #4
    4798:	f840 3b04 	str.w	r3, [r0], #4
    479c:	f851 3b04 	ldr.w	r3, [r1], #4
    47a0:	f840 3b04 	str.w	r3, [r0], #4
    47a4:	f851 3b04 	ldr.w	r3, [r1], #4
    47a8:	f840 3b04 	str.w	r3, [r0], #4
    47ac:	f851 3b04 	ldr.w	r3, [r1], #4
    47b0:	f840 3b04 	str.w	r3, [r0], #4
    47b4:	f851 3b04 	ldr.w	r3, [r1], #4
    47b8:	f840 3b04 	str.w	r3, [r0], #4
    47bc:	f851 3b04 	ldr.w	r3, [r1], #4
    47c0:	f840 3b04 	str.w	r3, [r0], #4
    47c4:	f851 3b04 	ldr.w	r3, [r1], #4
    47c8:	f840 3b04 	str.w	r3, [r0], #4
    47cc:	f851 3b04 	ldr.w	r3, [r1], #4
    47d0:	f840 3b04 	str.w	r3, [r0], #4
    47d4:	f851 3b04 	ldr.w	r3, [r1], #4
    47d8:	f840 3b04 	str.w	r3, [r0], #4
    47dc:	f851 3b04 	ldr.w	r3, [r1], #4
    47e0:	f840 3b04 	str.w	r3, [r0], #4
    47e4:	f851 3b04 	ldr.w	r3, [r1], #4
    47e8:	f840 3b04 	str.w	r3, [r0], #4
    47ec:	f851 3b04 	ldr.w	r3, [r1], #4
    47f0:	f840 3b04 	str.w	r3, [r0], #4
    47f4:	f851 3b04 	ldr.w	r3, [r1], #4
    47f8:	f840 3b04 	str.w	r3, [r0], #4
    47fc:	f851 3b04 	ldr.w	r3, [r1], #4
    4800:	f840 3b04 	str.w	r3, [r0], #4
    4804:	f851 3b04 	ldr.w	r3, [r1], #4
    4808:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    480c:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    480e:	d2bd      	bcs.n	478c <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    4810:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    4812:	d311      	bcc.n	4838 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    4814:	f851 3b04 	ldr.w	r3, [r1], #4
    4818:	f840 3b04 	str.w	r3, [r0], #4
    481c:	f851 3b04 	ldr.w	r3, [r1], #4
    4820:	f840 3b04 	str.w	r3, [r0], #4
    4824:	f851 3b04 	ldr.w	r3, [r1], #4
    4828:	f840 3b04 	str.w	r3, [r0], #4
    482c:	f851 3b04 	ldr.w	r3, [r1], #4
    4830:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    4834:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    4836:	d2ed      	bcs.n	4814 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    4838:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    483a:	d305      	bcc.n	4848 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    483c:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    4840:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    4844:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    4846:	d2f9      	bcs.n	483c <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    4848:	3204      	adds	r2, #4
	beq	.Ldone
    484a:	d00a      	beq.n	4862 <memcpy+0xe6>

	lsls	r2, r2, #31
    484c:	07d2      	lsls	r2, r2, #31
	itt ne
    484e:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    4850:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    4854:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    4858:	d303      	bcc.n	4862 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    485a:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    485c:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    485e:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    4860:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    4862:	bc01      	pop	{r0}
#endif
	bx	lr
    4864:	4770      	bx	lr
    4866:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    4868:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
    486a:	d34a      	bcc.n	4902 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    486c:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    4870:	d011      	beq.n	4896 <memcpy+0x11a>

	rsb	r3, #4
    4872:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    4876:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    4878:	07db      	lsls	r3, r3, #31
	itt ne
    487a:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    487c:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    4880:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    4884:	d307      	bcc.n	4896 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    4886:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    488a:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    488e:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    4892:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    4896:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
    489a:	f43f af75 	beq.w	4788 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    489e:	b430      	push	{r4, r5}
	subs	r2, #4
    48a0:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    48a2:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
    48a4:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    48a8:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
    48ac:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    48ae:	d019      	beq.n	48e4 <memcpy+0x168>
	cmp	r3, #3
    48b0:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    48b2:	d00b      	beq.n	48cc <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    48b4:	0a24      	lsrs	r4, r4, #8
    48b6:	f851 3b04 	ldr.w	r3, [r1], #4
    48ba:	061d      	lsls	r5, r3, #24
    48bc:	ea44 0405 	orr.w	r4, r4, r5
    48c0:	f840 4b04 	str.w	r4, [r0], #4
    48c4:	461c      	mov	r4, r3
    48c6:	3a04      	subs	r2, #4
    48c8:	d2f4      	bcs.n	48b4 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    48ca:	e016      	b.n	48fa <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    48cc:	0e24      	lsrs	r4, r4, #24
    48ce:	f851 3b04 	ldr.w	r3, [r1], #4
    48d2:	021d      	lsls	r5, r3, #8
    48d4:	ea44 0405 	orr.w	r4, r4, r5
    48d8:	f840 4b04 	str.w	r4, [r0], #4
    48dc:	461c      	mov	r4, r3
    48de:	3a04      	subs	r2, #4
    48e0:	d2f4      	bcs.n	48cc <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    48e2:	e00a      	b.n	48fa <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    48e4:	0c24      	lsrs	r4, r4, #16
    48e6:	f851 3b04 	ldr.w	r3, [r1], #4
    48ea:	041d      	lsls	r5, r3, #16
    48ec:	ea44 0405 	orr.w	r4, r4, r5
    48f0:	f840 4b04 	str.w	r4, [r0], #4
    48f4:	461c      	mov	r4, r3
    48f6:	3a04      	subs	r2, #4
    48f8:	d2f4      	bcs.n	48e4 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    48fa:	3204      	adds	r2, #4
	subs	r1, ip
    48fc:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    4900:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    4902:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    4904:	d3a0      	bcc.n	4848 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    4906:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    4908:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    490c:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    4910:	d2f9      	bcs.n	4906 <memcpy+0x18a>

	ldrb	r3, [r1]
    4912:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    4914:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    4916:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    4918:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    491a:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    491c:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    491e:	bc01      	pop	{r0}
#endif
	bx	lr
    4920:	4770      	bx	lr
    4922:	bf00      	nop

00004924 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    4924:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    4926:	4c10      	ldr	r4, [pc, #64]	; (4968 <fault_isr+0x44>)
    4928:	e008      	b.n	493c <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    492a:	6823      	ldr	r3, [r4, #0]
    492c:	0559      	lsls	r1, r3, #21
    492e:	d40d      	bmi.n	494c <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    4930:	6823      	ldr	r3, [r4, #0]
    4932:	051a      	lsls	r2, r3, #20
    4934:	d40f      	bmi.n	4956 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    4936:	6823      	ldr	r3, [r4, #0]
    4938:	04db      	lsls	r3, r3, #19
    493a:	d411      	bmi.n	4960 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    493c:	6823      	ldr	r3, [r4, #0]
    493e:	0358      	lsls	r0, r3, #13
    4940:	d5f3      	bpl.n	492a <fault_isr+0x6>
    4942:	f001 f8a9 	bl	5a98 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    4946:	6823      	ldr	r3, [r4, #0]
    4948:	0559      	lsls	r1, r3, #21
    494a:	d5f1      	bpl.n	4930 <fault_isr+0xc>
    494c:	f000 ff02 	bl	5754 <uart0_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    4950:	6823      	ldr	r3, [r4, #0]
    4952:	051a      	lsls	r2, r3, #20
    4954:	d5ef      	bpl.n	4936 <fault_isr+0x12>
    4956:	f000 f809 	bl	496c <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    495a:	6823      	ldr	r3, [r4, #0]
    495c:	04db      	lsls	r3, r3, #19
    495e:	d5ed      	bpl.n	493c <fault_isr+0x18>
    4960:	f000 f804 	bl	496c <unused_isr>
    4964:	e7ea      	b.n	493c <fault_isr+0x18>
    4966:	bf00      	nop
    4968:	40048034 	.word	0x40048034

0000496c <unused_isr>:
	}
}

void unused_isr(void)
{
    496c:	b508      	push	{r3, lr}
	fault_isr();
    496e:	f7ff ffd9 	bl	4924 <fault_isr>
    4972:	bf00      	nop

00004974 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    4974:	4b01      	ldr	r3, [pc, #4]	; (497c <startup_early_hook+0x8>)
    4976:	2210      	movs	r2, #16
    4978:	801a      	strh	r2, [r3, #0]
    497a:	4770      	bx	lr
    497c:	40052000 	.word	0x40052000

00004980 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    4980:	4770      	bx	lr
    4982:	bf00      	nop

00004984 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    4984:	4909      	ldr	r1, [pc, #36]	; (49ac <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    4986:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    4988:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    498a:	b130      	cbz	r0, 499a <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    498c:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    498e:	4418      	add	r0, r3
    4990:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
    4994:	4290      	cmp	r0, r2
    4996:	d202      	bcs.n	499e <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    4998:	6008      	str	r0, [r1, #0]
	}
	return prev;
    499a:	4618      	mov	r0, r3
}
    499c:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    499e:	f003 f8ff 	bl	7ba0 <__errno>
    49a2:	230c      	movs	r3, #12
    49a4:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    49a6:	f04f 30ff 	mov.w	r0, #4294967295
    49aa:	bd08      	pop	{r3, pc}
    49ac:	1fff872c 	.word	0x1fff872c

000049b0 <__cxa_guard_acquire>:
}

__attribute__((weak)) 
int __cxa_guard_acquire (char *g) 
{
	return !(*g);
    49b0:	7800      	ldrb	r0, [r0, #0]
}
    49b2:	fab0 f080 	clz	r0, r0
    49b6:	0940      	lsrs	r0, r0, #5
    49b8:	4770      	bx	lr
    49ba:	bf00      	nop

000049bc <__cxa_guard_release>:

__attribute__((weak)) 
void __cxa_guard_release(char *g)
{
	*g = 1;
    49bc:	2301      	movs	r3, #1
    49be:	7003      	strb	r3, [r0, #0]
    49c0:	4770      	bx	lr
    49c2:	bf00      	nop

000049c4 <nvic_execution_priority>:
	uint32_t priority=256;
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
    49c4:	f3ef 8013 	mrs	r0, FAULTMASK
	if (faultmask) return -1;
    49c8:	b970      	cbnz	r0, 49e8 <nvic_execution_priority+0x24>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    49ca:	f3ef 8310 	mrs	r3, PRIMASK
	if (primask) return 0;
    49ce:	b96b      	cbnz	r3, 49ec <nvic_execution_priority+0x28>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    49d0:	f3ef 8205 	mrs	r2, IPSR
	if (ipsr) {
    49d4:	b95a      	cbnz	r2, 49ee <nvic_execution_priority+0x2a>

#pragma GCC diagnostic pop

int nvic_execution_priority(void)
{
	uint32_t priority=256;
    49d6:	f44f 7080 	mov.w	r0, #256	; 0x100
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    49da:	f3ef 8311 	mrs	r3, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    49de:	b12b      	cbz	r3, 49ec <nvic_execution_priority+0x28>
    49e0:	4298      	cmp	r0, r3
    49e2:	bf28      	it	cs
    49e4:	4618      	movcs	r0, r3
	return priority;
    49e6:	4770      	bx	lr
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
	if (faultmask) return -1;
    49e8:	f04f 30ff 	mov.w	r0, #4294967295
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
	if (basepri > 0 && basepri < priority) priority = basepri;
	return priority;
}
    49ec:	4770      	bx	lr
	if (faultmask) return -1;
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
	if (primask) return 0;
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
    49ee:	2a0f      	cmp	r2, #15
    49f0:	d801      	bhi.n	49f6 <nvic_execution_priority+0x32>
    49f2:	4618      	mov	r0, r3
    49f4:	e7f1      	b.n	49da <nvic_execution_priority+0x16>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
    49f6:	4b01      	ldr	r3, [pc, #4]	; (49fc <nvic_execution_priority+0x38>)
    49f8:	5cd0      	ldrb	r0, [r2, r3]
    49fa:	e7ee      	b.n	49da <nvic_execution_priority+0x16>
    49fc:	e000e3f0 	.word	0xe000e3f0

00004a00 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    4a00:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    4a02:	4b0f      	ldr	r3, [pc, #60]	; (4a40 <digitalWrite.part.1+0x40>)
    4a04:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    4a08:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    4a0c:	b12c      	cbz	r4, 4a1a <digitalWrite.part.1+0x1a>
		if (val) {
			*portSetRegister(pin) = 1;
    4a0e:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    4a10:	b169      	cbz	r1, 4a2e <digitalWrite.part.1+0x2e>
			*portSetRegister(pin) = 1;
    4a12:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4a16:	bc10      	pop	{r4}
    4a18:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    4a1a:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    4a1e:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    4a20:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    4a22:	b941      	cbnz	r1, 4a36 <digitalWrite.part.1+0x36>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    4a24:	f022 0202 	bic.w	r2, r2, #2
    4a28:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4a2a:	bc10      	pop	{r4}
    4a2c:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    4a2e:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4a32:	bc10      	pop	{r4}
    4a34:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    4a36:	f042 0203 	orr.w	r2, r2, #3
    4a3a:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4a3c:	bc10      	pop	{r4}
    4a3e:	4770      	bx	lr
    4a40:	00009520 	.word	0x00009520

00004a44 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    4a44:	4a1c      	ldr	r2, [pc, #112]	; (4ab8 <pinMode.part.2+0x74>)
    4a46:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    4a4a:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    4a4c:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    4a4e:	d011      	beq.n	4a74 <pinMode.part.2+0x30>
    4a50:	2904      	cmp	r1, #4
    4a52:	d01b      	beq.n	4a8c <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    4a54:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    4a58:	2200      	movs	r2, #0
    4a5a:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    4a5e:	b129      	cbz	r1, 4a6c <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    4a60:	2902      	cmp	r1, #2
    4a62:	d020      	beq.n	4aa6 <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    4a64:	2903      	cmp	r1, #3
    4a66:	d022      	beq.n	4aae <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    4a68:	601a      	str	r2, [r3, #0]
    4a6a:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    4a6c:	f44f 7280 	mov.w	r2, #256	; 0x100
    4a70:	601a      	str	r2, [r3, #0]
    4a72:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4a74:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4a78:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4a7c:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4a80:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    4a82:	681a      	ldr	r2, [r3, #0]
    4a84:	f022 0220 	bic.w	r2, r2, #32
    4a88:	601a      	str	r2, [r3, #0]
    4a8a:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4a8c:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4a90:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4a94:	2001      	movs	r0, #1
    4a96:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4a9a:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    4a9c:	681a      	ldr	r2, [r3, #0]
    4a9e:	f042 0220 	orr.w	r2, r2, #32
    4aa2:	601a      	str	r2, [r3, #0]
    4aa4:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    4aa6:	f240 1203 	movw	r2, #259	; 0x103
    4aaa:	601a      	str	r2, [r3, #0]
    4aac:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    4aae:	f44f 7281 	mov.w	r2, #258	; 0x102
    4ab2:	601a      	str	r2, [r3, #0]
    4ab4:	4770      	bx	lr
    4ab6:	bf00      	nop
    4ab8:	00009520 	.word	0x00009520

00004abc <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    4abc:	b430      	push	{r4, r5}
	RTC_SR = 0;
    4abe:	4b05      	ldr	r3, [pc, #20]	; (4ad4 <rtc_set+0x18>)
	RTC_TPR = 0;
    4ac0:	4d05      	ldr	r5, [pc, #20]	; (4ad8 <rtc_set+0x1c>)
	RTC_TSR = t;
    4ac2:	4c06      	ldr	r4, [pc, #24]	; (4adc <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    4ac4:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    4ac6:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    4ac8:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    4aca:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    4acc:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    4ace:	6019      	str	r1, [r3, #0]
}
    4ad0:	bc30      	pop	{r4, r5}
    4ad2:	4770      	bx	lr
    4ad4:	4003d014 	.word	0x4003d014
    4ad8:	4003d004 	.word	0x4003d004
    4adc:	4003d000 	.word	0x4003d000

00004ae0 <analogWrite>:
void analogWrite(uint8_t pin, int val)
{
	uint32_t cval, max;

#if defined(__MK20DX256__)
	if (pin == A14) {
    4ae0:	2828      	cmp	r0, #40	; 0x28
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    4ae2:	b538      	push	{r3, r4, r5, lr}
	uint32_t cval, max;

#if defined(__MK20DX256__)
	if (pin == A14) {
    4ae4:	d02e      	beq.n	4b44 <analogWrite+0x64>
		return;
	}
#endif

	max = 1 << analog_write_res;
	if (val <= 0) {
    4ae6:	2900      	cmp	r1, #0
    4ae8:	4604      	mov	r4, r0
    4aea:	dd4f      	ble.n	4b8c <analogWrite+0xac>
		else analogWriteDAC1(val);
		return;
	}
#endif

	max = 1 << analog_write_res;
    4aec:	4b5f      	ldr	r3, [pc, #380]	; (4c6c <analogWrite+0x18c>)
    4aee:	781b      	ldrb	r3, [r3, #0]
	if (val <= 0) {
		digitalWrite(pin, LOW);
		pinMode(pin, OUTPUT);	// TODO: implement OUTPUT_LOW
		return;
	} else if (val >= max) {
    4af0:	2501      	movs	r5, #1
    4af2:	fa05 f203 	lsl.w	r2, r5, r3
    4af6:	428a      	cmp	r2, r1
    4af8:	d802      	bhi.n	4b00 <analogWrite+0x20>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    4afa:	2821      	cmp	r0, #33	; 0x21
    4afc:	d937      	bls.n	4b6e <analogWrite+0x8e>
    4afe:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(val);
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    4b00:	3803      	subs	r0, #3
    4b02:	b2c2      	uxtb	r2, r0
    4b04:	2a01      	cmp	r2, #1
    4b06:	d93a      	bls.n	4b7e <analogWrite+0x9e>
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    4b08:	2c20      	cmp	r4, #32
    4b0a:	d04a      	beq.n	4ba2 <analogWrite+0xc2>
    4b0c:	2c19      	cmp	r4, #25
    4b0e:	d048      	beq.n	4ba2 <analogWrite+0xc2>
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
    4b10:	4a57      	ldr	r2, [pc, #348]	; (4c70 <analogWrite+0x190>)
    4b12:	6812      	ldr	r2, [r2, #0]
    4b14:	fb02 1201 	mla	r2, r2, r1, r1
    4b18:	fa22 f303 	lsr.w	r3, r2, r3
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
    4b1c:	281d      	cmp	r0, #29
    4b1e:	f200 809b 	bhi.w	4c58 <analogWrite+0x178>
    4b22:	e8df f000 	tbb	[pc, r0]
    4b26:	8b92      	.short	0x8b92
    4b28:	99997d84 	.word	0x99997d84
    4b2c:	99996f76 	.word	0x99996f76
    4b30:	99999999 	.word	0x99999999
    4b34:	68999999 	.word	0x68999999
    4b38:	99535a61 	.word	0x99535a61
    4b3c:	9999994c 	.word	0x9999994c
    4b40:	45999999 	.word	0x45999999
{
	uint32_t cval, max;

#if defined(__MK20DX256__)
	if (pin == A14) {
		uint8_t res = analog_write_res;
    4b44:	4b49      	ldr	r3, [pc, #292]	; (4c6c <analogWrite+0x18c>)
    4b46:	781b      	ldrb	r3, [r3, #0]
		if (res < 12) {
    4b48:	2b0b      	cmp	r3, #11
    4b4a:	d908      	bls.n	4b5e <analogWrite+0x7e>
			val <<= 12 - res;
		} else if (res > 12) {
    4b4c:	2b0c      	cmp	r3, #12
			val >>= res - 12;
    4b4e:	bf1c      	itt	ne
    4b50:	3b0c      	subne	r3, #12
    4b52:	4119      	asrne	r1, r3
		}
		analogWriteDAC0(val);
    4b54:	4608      	mov	r0, r1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    4b56:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		analogWriteDAC0(val);
    4b5a:	f002 ba59 	b.w	7010 <analogWriteDAC0>

#if defined(__MK20DX256__)
	if (pin == A14) {
		uint8_t res = analog_write_res;
		if (res < 12) {
			val <<= 12 - res;
    4b5e:	f1c3 030c 	rsb	r3, r3, #12
    4b62:	4099      	lsls	r1, r3
		} else if (res > 12) {
			val >>= res - 12;
		}
		analogWriteDAC0(val);
    4b64:	4608      	mov	r0, r1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    4b66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		analogWriteDAC0(val);
    4b6a:	f002 ba51 	b.w	7010 <analogWriteDAC0>
    4b6e:	4629      	mov	r1, r5
    4b70:	f7ff ff46 	bl	4a00 <digitalWrite.part.1>
    4b74:	4629      	mov	r1, r5
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    4b76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    4b7a:	f7ff bf63 	b.w	4a44 <pinMode.part.2>
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
    4b7e:	4a3d      	ldr	r2, [pc, #244]	; (4c74 <analogWrite+0x194>)
    4b80:	6812      	ldr	r2, [r2, #0]
    4b82:	fb02 1201 	mla	r2, r2, r1, r1
    4b86:	fa22 f303 	lsr.w	r3, r2, r3
    4b8a:	e7c7      	b.n	4b1c <analogWrite+0x3c>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    4b8c:	2821      	cmp	r0, #33	; 0x21
    4b8e:	d8b6      	bhi.n	4afe <analogWrite+0x1e>
    4b90:	2100      	movs	r1, #0
    4b92:	f7ff ff35 	bl	4a00 <digitalWrite.part.1>
    4b96:	4620      	mov	r0, r4
    4b98:	2101      	movs	r1, #1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    4b9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    4b9e:	f7ff bf51 	b.w	4a44 <pinMode.part.2>
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
    4ba2:	4a35      	ldr	r2, [pc, #212]	; (4c78 <analogWrite+0x198>)
    4ba4:	6812      	ldr	r2, [r2, #0]
    4ba6:	fb02 1201 	mla	r2, r2, r1, r1
    4baa:	fa22 f303 	lsr.w	r3, r2, r3
    4bae:	e7b5      	b.n	4b1c <analogWrite+0x3c>
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    4bb0:	4932      	ldr	r1, [pc, #200]	; (4c7c <analogWrite+0x19c>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bb2:	4a33      	ldr	r2, [pc, #204]	; (4c80 <analogWrite+0x1a0>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    4bb4:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bb6:	f44f 7351 	mov.w	r3, #836	; 0x344
    4bba:	6013      	str	r3, [r2, #0]
		break;
    4bbc:	bd38      	pop	{r3, r4, r5, pc}
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    4bbe:	4931      	ldr	r1, [pc, #196]	; (4c84 <analogWrite+0x1a4>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bc0:	4a31      	ldr	r2, [pc, #196]	; (4c88 <analogWrite+0x1a8>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    4bc2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bc4:	f44f 7351 	mov.w	r3, #836	; 0x344
    4bc8:	6013      	str	r3, [r2, #0]
		break;
    4bca:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    4bcc:	492f      	ldr	r1, [pc, #188]	; (4c8c <analogWrite+0x1ac>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bce:	4a30      	ldr	r2, [pc, #192]	; (4c90 <analogWrite+0x1b0>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    4bd0:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bd2:	f240 4344 	movw	r3, #1092	; 0x444
    4bd6:	6013      	str	r3, [r2, #0]
		break;
    4bd8:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    4bda:	492e      	ldr	r1, [pc, #184]	; (4c94 <analogWrite+0x1b4>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bdc:	4a2e      	ldr	r2, [pc, #184]	; (4c98 <analogWrite+0x1b8>)
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    4bde:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4be0:	f240 4344 	movw	r3, #1092	; 0x444
    4be4:	6013      	str	r3, [r2, #0]
		break;
    4be6:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    4be8:	492c      	ldr	r1, [pc, #176]	; (4c9c <analogWrite+0x1bc>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bea:	4a2d      	ldr	r2, [pc, #180]	; (4ca0 <analogWrite+0x1c0>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    4bec:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bee:	f240 4344 	movw	r3, #1092	; 0x444
    4bf2:	6013      	str	r3, [r2, #0]
		break;
    4bf4:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    4bf6:	492b      	ldr	r1, [pc, #172]	; (4ca4 <analogWrite+0x1c4>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bf8:	4a2b      	ldr	r2, [pc, #172]	; (4ca8 <analogWrite+0x1c8>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    4bfa:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4bfc:	f240 4344 	movw	r3, #1092	; 0x444
    4c00:	6013      	str	r3, [r2, #0]
		break;
    4c02:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    4c04:	4929      	ldr	r1, [pc, #164]	; (4cac <analogWrite+0x1cc>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c06:	4a2a      	ldr	r2, [pc, #168]	; (4cb0 <analogWrite+0x1d0>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    4c08:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c0a:	f240 4344 	movw	r3, #1092	; 0x444
    4c0e:	6013      	str	r3, [r2, #0]
		break;
    4c10:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    4c12:	4928      	ldr	r1, [pc, #160]	; (4cb4 <analogWrite+0x1d4>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c14:	4a28      	ldr	r2, [pc, #160]	; (4cb8 <analogWrite+0x1d8>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    4c16:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c18:	f240 4344 	movw	r3, #1092	; 0x444
    4c1c:	6013      	str	r3, [r2, #0]
		break;
    4c1e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    4c20:	4926      	ldr	r1, [pc, #152]	; (4cbc <analogWrite+0x1dc>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c22:	4a27      	ldr	r2, [pc, #156]	; (4cc0 <analogWrite+0x1e0>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    4c24:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c26:	f240 4344 	movw	r3, #1092	; 0x444
    4c2a:	6013      	str	r3, [r2, #0]
		break;
    4c2c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    4c2e:	4925      	ldr	r1, [pc, #148]	; (4cc4 <analogWrite+0x1e4>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c30:	4a25      	ldr	r2, [pc, #148]	; (4cc8 <analogWrite+0x1e8>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    4c32:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c34:	f240 4344 	movw	r3, #1092	; 0x444
    4c38:	6013      	str	r3, [r2, #0]
		break;
    4c3a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    4c3c:	4923      	ldr	r1, [pc, #140]	; (4ccc <analogWrite+0x1ec>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c3e:	4a24      	ldr	r2, [pc, #144]	; (4cd0 <analogWrite+0x1f0>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    4c40:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c42:	f44f 7351 	mov.w	r3, #836	; 0x344
    4c46:	6013      	str	r3, [r2, #0]
		break;
    4c48:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    4c4a:	4922      	ldr	r1, [pc, #136]	; (4cd4 <analogWrite+0x1f4>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c4c:	4a22      	ldr	r2, [pc, #136]	; (4cd8 <analogWrite+0x1f8>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    4c4e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    4c50:	f44f 7351 	mov.w	r3, #836	; 0x344
    4c54:	6013      	str	r3, [r2, #0]
		break;
    4c56:	bd38      	pop	{r3, r4, r5, pc}

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    4c58:	2c21      	cmp	r4, #33	; 0x21
    4c5a:	f63f af50 	bhi.w	4afe <analogWrite+0x1e>
    4c5e:	297f      	cmp	r1, #127	; 0x7f
    4c60:	bfd4      	ite	le
    4c62:	2100      	movle	r1, #0
    4c64:	2101      	movgt	r1, #1
    4c66:	4620      	mov	r0, r4
    4c68:	e793      	b.n	4b92 <analogWrite+0xb2>
    4c6a:	bf00      	nop
    4c6c:	1fff8730 	.word	0x1fff8730
    4c70:	40038008 	.word	0x40038008
    4c74:	40039008 	.word	0x40039008
    4c78:	400b8008 	.word	0x400b8008
    4c7c:	400b8010 	.word	0x400b8010
    4c80:	4004a048 	.word	0x4004a048
    4c84:	400b8018 	.word	0x400b8018
    4c88:	4004a04c 	.word	0x4004a04c
    4c8c:	40038018 	.word	0x40038018
    4c90:	4004b008 	.word	0x4004b008
    4c94:	40038010 	.word	0x40038010
    4c98:	4004b004 	.word	0x4004b004
    4c9c:	40038040 	.word	0x40038040
    4ca0:	4004c018 	.word	0x4004c018
    4ca4:	40038038 	.word	0x40038038
    4ca8:	4004c014 	.word	0x4004c014
    4cac:	40038028 	.word	0x40038028
    4cb0:	4004b010 	.word	0x4004b010
    4cb4:	40038020 	.word	0x40038020
    4cb8:	4004b00c 	.word	0x4004b00c
    4cbc:	40038030 	.word	0x40038030
    4cc0:	4004c010 	.word	0x4004c010
    4cc4:	40038048 	.word	0x40038048
    4cc8:	4004c01c 	.word	0x4004c01c
    4ccc:	40039018 	.word	0x40039018
    4cd0:	40049034 	.word	0x40049034
    4cd4:	40039010 	.word	0x40039010
    4cd8:	40049030 	.word	0x40049030

00004cdc <analogWriteRes>:


uint32_t analogWriteRes(uint32_t bits)
{
	uint32_t prior_res;
	if (bits < 1) {
    4cdc:	b138      	cbz	r0, 4cee <analogWriteRes+0x12>
    4cde:	2810      	cmp	r0, #16
    4ce0:	bf28      	it	cs
    4ce2:	2010      	movcs	r0, #16
		bits = 1;
	} else if (bits > 16) {
		bits = 16;
	}
	prior_res = analog_write_res;
    4ce4:	4a04      	ldr	r2, [pc, #16]	; (4cf8 <analogWriteRes+0x1c>)
    4ce6:	b2c3      	uxtb	r3, r0
    4ce8:	7810      	ldrb	r0, [r2, #0]
	analog_write_res = bits;
    4cea:	7013      	strb	r3, [r2, #0]
	return prior_res;
}
    4cec:	4770      	bx	lr
	if (bits < 1) {
		bits = 1;
	} else if (bits > 16) {
		bits = 16;
	}
	prior_res = analog_write_res;
    4cee:	4a02      	ldr	r2, [pc, #8]	; (4cf8 <analogWriteRes+0x1c>)
    4cf0:	2301      	movs	r3, #1
    4cf2:	7810      	ldrb	r0, [r2, #0]
	analog_write_res = bits;
    4cf4:	7013      	strb	r3, [r2, #0]
	return prior_res;
}
    4cf6:	4770      	bx	lr
    4cf8:	1fff8730 	.word	0x1fff8730

00004cfc <analogWriteFrequency>:


void analogWriteFrequency(uint8_t pin, float frequency)
{
    4cfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4d00:	460e      	mov	r6, r1
    4d02:	4680      	mov	r8, r0
#if defined(__MKL26Z64__)
	// Teensy LC does not support slow clock source (ftmClockSource = 2)
	ftmClockSource = 1; 	// Use default F_TIMER clock source
	ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
#else
	if (frequency < (float)(F_TIMER >> 7) / 65536.0f) {
    4d04:	4932      	ldr	r1, [pc, #200]	; (4dd0 <analogWriteFrequency+0xd4>)
		// frequency is too low for working with F_TIMER:
		ftmClockSource = 2; 	// Use alternative 31250Hz clock source
		ftmClock = 31250;   	// Set variable for the actual timer clock frequency
	} else {
		ftmClockSource = 1; 	// Use default F_TIMER clock source
    4d06:	4d33      	ldr	r5, [pc, #204]	; (4dd4 <analogWriteFrequency+0xd8>)
#if defined(__MKL26Z64__)
	// Teensy LC does not support slow clock source (ftmClockSource = 2)
	ftmClockSource = 1; 	// Use default F_TIMER clock source
	ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
#else
	if (frequency < (float)(F_TIMER >> 7) / 65536.0f) {
    4d08:	4630      	mov	r0, r6
    4d0a:	f002 fecd 	bl	7aa8 <__aeabi_fcmplt>
		// frequency is too low for working with F_TIMER:
		ftmClockSource = 2; 	// Use alternative 31250Hz clock source
		ftmClock = 31250;   	// Set variable for the actual timer clock frequency
	} else {
		ftmClockSource = 1; 	// Use default F_TIMER clock source
    4d0e:	f647 2312 	movw	r3, #31250	; 0x7a12
    4d12:	2800      	cmp	r0, #0
    4d14:	bf1a      	itte	ne
    4d16:	461d      	movne	r5, r3
    4d18:	f04f 0902 	movne.w	r9, #2
    4d1c:	f04f 0901 	moveq.w	r9, #1
		ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
	}
#endif

	
	for (prescale = 0; prescale < 7; prescale++) {
    4d20:	2400      	movs	r4, #0
		minfreq = (float)(ftmClock >> prescale) / 65536.0f;	//Use ftmClock instead of F_TIMER
    4d22:	fa25 f004 	lsr.w	r0, r5, r4
    4d26:	f002 fcc9 	bl	76bc <__aeabi_ui2f>
		if (frequency >= minfreq) break;
    4d2a:	f04f 515e 	mov.w	r1, #931135488	; 0x37800000
	}
#endif

	
	for (prescale = 0; prescale < 7; prescale++) {
		minfreq = (float)(ftmClock >> prescale) / 65536.0f;	//Use ftmClock instead of F_TIMER
    4d2e:	4607      	mov	r7, r0
		if (frequency >= minfreq) break;
    4d30:	f002 fd1c 	bl	776c <__aeabi_fmul>
    4d34:	4601      	mov	r1, r0
    4d36:	4630      	mov	r0, r6
    4d38:	f002 feca 	bl	7ad0 <__aeabi_fcmpge>
    4d3c:	b930      	cbnz	r0, 4d4c <analogWriteFrequency+0x50>
		ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
	}
#endif

	
	for (prescale = 0; prescale < 7; prescale++) {
    4d3e:	3401      	adds	r4, #1
    4d40:	2c07      	cmp	r4, #7
    4d42:	d1ee      	bne.n	4d22 <analogWriteFrequency+0x26>
    4d44:	09e8      	lsrs	r0, r5, #7
    4d46:	f002 fcb9 	bl	76bc <__aeabi_ui2f>
    4d4a:	4607      	mov	r7, r0
	//serial_phex32(ftmClock >> prescale);
	//serial_print("\n");
	//serial_print("prescale = ");
	//serial_phex(prescale);
	//serial_print("\n");
	mod = (float)(ftmClock >> prescale) / frequency - 0.5f;	//Use ftmClock instead of F_TIMER
    4d4c:	4631      	mov	r1, r6
    4d4e:	4638      	mov	r0, r7
    4d50:	f002 fdc0 	bl	78d4 <__aeabi_fdiv>
    4d54:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
    4d58:	f002 fbfe 	bl	7558 <__aeabi_fsub>
    4d5c:	f002 fef2 	bl	7b44 <__aeabi_f2uiz>
    4d60:	f64f 72ff 	movw	r2, #65535	; 0xffff
    4d64:	4290      	cmp	r0, r2
	if (mod > 65535) mod = 65535;
	//serial_print("mod = ");
	//serial_phex32(mod);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    4d66:	f1a8 0303 	sub.w	r3, r8, #3
    4d6a:	bf28      	it	cs
    4d6c:	4610      	movcs	r0, r2
    4d6e:	2b01      	cmp	r3, #1
    4d70:	d929      	bls.n	4dc6 <analogWriteFrequency+0xca>
		FTM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	} else if (pin == FTM0_CH0_PIN || pin == FTM0_CH1_PIN
	  || pin == FTM0_CH2_PIN || pin == FTM0_CH3_PIN
	  || pin == FTM0_CH4_PIN || pin == FTM0_CH5_PIN
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
    4d72:	f1b8 0f17 	cmp.w	r8, #23
    4d76:	d817      	bhi.n	4da8 <analogWriteFrequency+0xac>
    4d78:	4b17      	ldr	r3, [pc, #92]	; (4dd8 <analogWriteFrequency+0xdc>)
    4d7a:	fa23 f308 	lsr.w	r3, r3, r8
    4d7e:	f003 0301 	and.w	r3, r3, #1
    4d82:	f083 0201 	eor.w	r2, r3, #1
    4d86:	b923      	cbnz	r3, 4d92 <analogWriteFrequency+0x96>
		FTM0_CNT = 0;
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#ifdef FTM2_CH0_PIN
	  else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    4d88:	f1b8 0f19 	cmp.w	r8, #25
    4d8c:	d00f      	beq.n	4dae <analogWriteFrequency+0xb2>
    4d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	  || pin == FTM0_CH4_PIN || pin == FTM0_CH5_PIN
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
#endif
	  ) {
		FTM0_SC = 0;
    4d92:	4b12      	ldr	r3, [pc, #72]	; (4ddc <analogWriteFrequency+0xe0>)
		FTM0_CNT = 0;
    4d94:	4d12      	ldr	r5, [pc, #72]	; (4de0 <analogWriteFrequency+0xe4>)
		FTM0_MOD = mod;
    4d96:	4913      	ldr	r1, [pc, #76]	; (4de4 <analogWriteFrequency+0xe8>)
	  || pin == FTM0_CH4_PIN || pin == FTM0_CH5_PIN
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
#endif
	  ) {
		FTM0_SC = 0;
    4d98:	601a      	str	r2, [r3, #0]
		FTM0_CNT = 0;
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
    4d9a:	ea44 04c9 	orr.w	r4, r4, r9, lsl #3
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
#endif
	  ) {
		FTM0_SC = 0;
		FTM0_CNT = 0;
    4d9e:	602a      	str	r2, [r5, #0]
		FTM0_MOD = mod;
    4da0:	6008      	str	r0, [r1, #0]
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
    4da2:	601c      	str	r4, [r3, #0]
    4da4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	}
#ifdef FTM2_CH0_PIN
	  else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    4da8:	f1b8 0f20 	cmp.w	r8, #32
    4dac:	d1ec      	bne.n	4d88 <analogWriteFrequency+0x8c>
		FTM2_SC = 0;
    4dae:	4b0e      	ldr	r3, [pc, #56]	; (4de8 <analogWriteFrequency+0xec>)
		FTM2_CNT = 0;
    4db0:	4d0e      	ldr	r5, [pc, #56]	; (4dec <analogWriteFrequency+0xf0>)
		FTM2_MOD = mod;
    4db2:	490f      	ldr	r1, [pc, #60]	; (4df0 <analogWriteFrequency+0xf4>)
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#ifdef FTM2_CH0_PIN
	  else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		FTM2_SC = 0;
    4db4:	2200      	movs	r2, #0
		FTM2_CNT = 0;
		FTM2_MOD = mod;
		FTM2_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
    4db6:	ea44 04c9 	orr.w	r4, r4, r9, lsl #3
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#ifdef FTM2_CH0_PIN
	  else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		FTM2_SC = 0;
    4dba:	601a      	str	r2, [r3, #0]
		FTM2_CNT = 0;
    4dbc:	602a      	str	r2, [r5, #0]
		FTM2_MOD = mod;
    4dbe:	6008      	str	r0, [r1, #0]
		FTM2_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
    4dc0:	601c      	str	r4, [r3, #0]
		TPM1_CNT = 0;
		TPM1_MOD = mod;
		TPM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);
	}
#endif
}
    4dc2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (mod > 65535) mod = 65535;
	//serial_print("mod = ");
	//serial_phex32(mod);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		FTM1_SC = 0;
    4dc6:	4b0b      	ldr	r3, [pc, #44]	; (4df4 <analogWriteFrequency+0xf8>)
		FTM1_CNT = 0;
    4dc8:	4d0b      	ldr	r5, [pc, #44]	; (4df8 <analogWriteFrequency+0xfc>)
		FTM1_MOD = mod;
    4dca:	490c      	ldr	r1, [pc, #48]	; (4dfc <analogWriteFrequency+0x100>)
    4dcc:	e7f2      	b.n	4db4 <analogWriteFrequency+0xb8>
    4dce:	bf00      	nop
    4dd0:	40b71b00 	.word	0x40b71b00
    4dd4:	02dc6c00 	.word	0x02dc6c00
    4dd8:	00f00660 	.word	0x00f00660
    4ddc:	40038000 	.word	0x40038000
    4de0:	40038004 	.word	0x40038004
    4de4:	40038008 	.word	0x40038008
    4de8:	400b8000 	.word	0x400b8000
    4dec:	400b8004 	.word	0x400b8004
    4df0:	400b8008 	.word	0x400b8008
    4df4:	40039000 	.word	0x40039000
    4df8:	40039004 	.word	0x40039004
    4dfc:	40039008 	.word	0x40039008

00004e00 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    4e00:	2821      	cmp	r0, #33	; 0x21
    4e02:	d801      	bhi.n	4e08 <digitalWrite+0x8>
    4e04:	f7ff bdfc 	b.w	4a00 <digitalWrite.part.1>
    4e08:	4770      	bx	lr
    4e0a:	bf00      	nop

00004e0c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    4e0c:	2821      	cmp	r0, #33	; 0x21
    4e0e:	d801      	bhi.n	4e14 <pinMode+0x8>
    4e10:	f7ff be18 	b.w	4a44 <pinMode.part.2>
    4e14:	4770      	bx	lr
    4e16:	bf00      	nop

00004e18 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    4e18:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    4e1a:	490c      	ldr	r1, [pc, #48]	; (4e4c <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    4e1c:	4b0c      	ldr	r3, [pc, #48]	; (4e50 <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4e1e:	4a0d      	ldr	r2, [pc, #52]	; (4e54 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    4e20:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    4e22:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4e24:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    4e26:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    4e28:	0152      	lsls	r2, r2, #5
    4e2a:	d502      	bpl.n	4e32 <micros+0x1a>
    4e2c:	2b32      	cmp	r3, #50	; 0x32
    4e2e:	bf88      	it	hi
    4e30:	3001      	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    4e32:	4909      	ldr	r1, [pc, #36]	; (4e58 <micros+0x40>)
    4e34:	f5c3 33bb 	rsb	r3, r3, #95744	; 0x17600
    4e38:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    4e3c:	33ff      	adds	r3, #255	; 0xff
    4e3e:	fba1 1303 	umull	r1, r3, r1, r3
    4e42:	fb02 f000 	mul.w	r0, r2, r0
}
    4e46:	eb00 1093 	add.w	r0, r0, r3, lsr #6
    4e4a:	4770      	bx	lr
    4e4c:	1fffb440 	.word	0x1fffb440
    4e50:	e000e018 	.word	0xe000e018
    4e54:	e000ed04 	.word	0xe000ed04
    4e58:	aaaaaaab 	.word	0xaaaaaaab

00004e5c <delay>:

void delay(uint32_t ms)
{
    4e5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4e60:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    4e62:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    4e64:	4f20      	ldr	r7, [pc, #128]	; (4ee8 <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    4e66:	4b21      	ldr	r3, [pc, #132]	; (4eec <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4e68:	4a21      	ldr	r2, [pc, #132]	; (4ef0 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    4e6a:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    4e6c:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4e6e:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    4e70:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    4e72:	0152      	lsls	r2, r2, #5
    4e74:	d502      	bpl.n	4e7c <delay+0x20>
    4e76:	2b32      	cmp	r3, #50	; 0x32
    4e78:	bf88      	it	hi
    4e7a:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    4e7c:	b395      	cbz	r5, 4ee4 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    4e7e:	f5c3 33bb 	rsb	r3, r3, #95744	; 0x17600
    4e82:	4e1c      	ldr	r6, [pc, #112]	; (4ef4 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    4e84:	f8df 9064 	ldr.w	r9, [pc, #100]	; 4eec <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4e88:	f8df 8064 	ldr.w	r8, [pc, #100]	; 4ef0 <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    4e8c:	33ff      	adds	r3, #255	; 0xff
    4e8e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    4e92:	fba6 1303 	umull	r1, r3, r6, r3
    4e96:	fb02 f404 	mul.w	r4, r2, r4
    4e9a:	eb04 1493 	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    4e9e:	b672      	cpsid	i
	current = SYST_CVR;
    4ea0:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    4ea4:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4ea6:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    4eaa:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    4eac:	f5c1 33bb 	rsb	r3, r1, #95744	; 0x17600
    4eb0:	33ff      	adds	r3, #255	; 0xff
    4eb2:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    4eb6:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    4eba:	ebc4 1393 	rsb	r3, r4, r3, lsr #6
    4ebe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    4ec2:	d002      	beq.n	4eca <delay+0x6e>
    4ec4:	2932      	cmp	r1, #50	; 0x32
    4ec6:	bf88      	it	hi
    4ec8:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    4eca:	fb00 3302 	mla	r3, r0, r2, r3
    4ece:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4ed2:	d304      	bcc.n	4ede <delay+0x82>
				ms--;
				if (ms == 0) return;
    4ed4:	3d01      	subs	r5, #1
    4ed6:	d005      	beq.n	4ee4 <delay+0x88>
				start += 1000;
    4ed8:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    4edc:	e7df      	b.n	4e9e <delay+0x42>
			}
			yield();
    4ede:	f001 ffb1 	bl	6e44 <yield>
		}
    4ee2:	e7dc      	b.n	4e9e <delay+0x42>
    4ee4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4ee8:	1fffb440 	.word	0x1fffb440
    4eec:	e000e018 	.word	0xe000e018
    4ef0:	e000ed04 	.word	0xe000ed04
    4ef4:	aaaaaaab 	.word	0xaaaaaaab

00004ef8 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    4ef8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    4efa:	4b2d      	ldr	r3, [pc, #180]	; (4fb0 <_init_Teensyduino_internal_+0xb8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    4efc:	492d      	ldr	r1, [pc, #180]	; (4fb4 <_init_Teensyduino_internal_+0xbc>)
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    4efe:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 4fd0 <_init_Teensyduino_internal_+0xd8>
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    4f02:	f8df c0d0 	ldr.w	ip, [pc, #208]	; 4fd4 <_init_Teensyduino_internal_+0xdc>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    4f06:	4e2c      	ldr	r6, [pc, #176]	; (4fb8 <_init_Teensyduino_internal_+0xc0>)
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    4f08:	4d2c      	ldr	r5, [pc, #176]	; (4fbc <_init_Teensyduino_internal_+0xc4>)
	FTM0_C4SC = 0x28;
    4f0a:	4c2d      	ldr	r4, [pc, #180]	; (4fc0 <_init_Teensyduino_internal_+0xc8>)
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    4f0c:	4a2d      	ldr	r2, [pc, #180]	; (4fc4 <_init_Teensyduino_internal_+0xcc>)
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    4f0e:	4f2e      	ldr	r7, [pc, #184]	; (4fc8 <_init_Teensyduino_internal_+0xd0>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    4f10:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    4f14:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    4f16:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
    4f1a:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    4f1c:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
    4f20:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    4f22:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
    4f26:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    4f28:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    4f2c:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    4f2e:	2000      	movs	r0, #0
    4f30:	6008      	str	r0, [r1, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    4f32:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    4f34:	f64b 71ff 	movw	r1, #49151	; 0xbfff
    4f38:	f8cc 1000 	str.w	r1, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    4f3c:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    4f40:	6033      	str	r3, [r6, #0]
	FTM0_C2SC = 0x28;
    4f42:	6013      	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
    4f44:	602b      	str	r3, [r5, #0]
	FTM0_C4SC = 0x28;
    4f46:	6023      	str	r3, [r4, #0]
	FTM0_C5SC = 0x28;
    4f48:	603b      	str	r3, [r7, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    4f4a:	62b3      	str	r3, [r6, #40]	; 0x28
	FTM0_C7SC = 0x28;
    4f4c:	6293      	str	r3, [r2, #40]	; 0x28
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4f4e:	2209      	movs	r2, #9
    4f50:	f845 2c24 	str.w	r2, [r5, #-36]
	FTM1_CNT = 0;
    4f54:	f8c4 0fd8 	str.w	r0, [r4, #4056]	; 0xfd8
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
    4f58:	f505 657f 	add.w	r5, r5, #4080	; 0xff0
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
    4f5c:	f8c7 1fd4 	str.w	r1, [r7, #4052]	; 0xfd4
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    4f60:	f507 27ff 	add.w	r7, r7, #522240	; 0x7f800
    4f64:	f507 67fa 	add.w	r7, r7, #2000	; 0x7d0
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
    4f68:	f8c6 3ff8 	str.w	r3, [r6, #4088]	; 0xff8
	FTM1_C1SC = 0x28;
    4f6c:	602b      	str	r3, [r5, #0]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
    4f6e:	f506 26ff 	add.w	r6, r6, #522240	; 0x7f800
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4f72:	f8c4 2fd4 	str.w	r2, [r4, #4052]	; 0xfd4
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    4f76:	f505 25fd 	add.w	r5, r5, #518144	; 0x7e800
	FTM2_C1SC = 0x28;
    4f7a:	f504 24ff 	add.w	r4, r4, #522240	; 0x7f800
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    4f7e:	6038      	str	r0, [r7, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    4f80:	f206 76f4 	addw	r6, r6, #2036	; 0x7f4
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4f84:	4811      	ldr	r0, [pc, #68]	; (4fcc <_init_Teensyduino_internal_+0xd4>)
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
    4f86:	6031      	str	r1, [r6, #0]
	FTM2_C0SC = 0x28;
    4f88:	f505 65ff 	add.w	r5, r5, #2040	; 0x7f8
	FTM2_C1SC = 0x28;
    4f8c:	f504 64fd 	add.w	r4, r4, #2024	; 0x7e8
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    4f90:	602b      	str	r3, [r5, #0]
	FTM2_C1SC = 0x28;
    4f92:	6023      	str	r3, [r4, #0]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4f94:	6002      	str	r2, [r0, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    4f96:	f001 ffcb 	bl	6f30 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    4f9a:	2019      	movs	r0, #25
    4f9c:	f7ff ff5e 	bl	4e5c <delay>
	usb_init();
    4fa0:	f001 f9b4 	bl	630c <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    4fa4:	f240 1013 	movw	r0, #275	; 0x113
}
    4fa8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    4fac:	f7ff bf56 	b.w	4e5c <delay>
    4fb0:	e000e108 	.word	0xe000e108
    4fb4:	40038004 	.word	0x40038004
    4fb8:	40038014 	.word	0x40038014
    4fbc:	40038024 	.word	0x40038024
    4fc0:	4003802c 	.word	0x4003802c
    4fc4:	4003801c 	.word	0x4003801c
    4fc8:	40038034 	.word	0x40038034
    4fcc:	400b8000 	.word	0x400b8000
    4fd0:	4003800c 	.word	0x4003800c
    4fd4:	40038008 	.word	0x40038008

00004fd8 <serial_putchar.part.0>:
#else
	return 0;
#endif
}

void serial_putchar(uint32_t c)
    4fd8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
    4fdc:	4b2c      	ldr	r3, [pc, #176]	; (5090 <serial_putchar.part.0+0xb8>)
    4fde:	681b      	ldr	r3, [r3, #0]
#else
	return 0;
#endif
}

void serial_putchar(uint32_t c)
    4fe0:	4607      	mov	r7, r0
{
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
    4fe2:	b10b      	cbz	r3, 4fe8 <serial_putchar.part.0+0x10>
    4fe4:	2201      	movs	r2, #1
    4fe6:	701a      	strb	r2, [r3, #0]
		reg |= UART_C3_TXDIR;
		UART0_C3 = reg;
		__enable_irq();
	}
	#endif 
	head = tx_buffer_head;
    4fe8:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 50a8 <serial_putchar.part.0+0xd0>
	if (++head >= tx_buffer_total_size_) head = 0;
    4fec:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 50ac <serial_putchar.part.0+0xd4>
		reg |= UART_C3_TXDIR;
		UART0_C3 = reg;
		__enable_irq();
	}
	#endif 
	head = tx_buffer_head;
    4ff0:	f899 4000 	ldrb.w	r4, [r9]
	if (++head >= tx_buffer_total_size_) head = 0;
    4ff4:	f8d8 3000 	ldr.w	r3, [r8]
    4ff8:	4d26      	ldr	r5, [pc, #152]	; (5094 <serial_putchar.part.0+0xbc>)
	while (tx_buffer_tail == head) {
		int priority = nvic_execution_priority();
		if (priority <= IRQ_PRIORITY) {
			if ((UART0_S1 & UART_S1_TDRE)) {
    4ffa:	4e27      	ldr	r6, [pc, #156]	; (5098 <serial_putchar.part.0+0xc0>)
		UART0_C3 = reg;
		__enable_irq();
	}
	#endif 
	head = tx_buffer_head;
	if (++head >= tx_buffer_total_size_) head = 0;
    4ffc:	3401      	adds	r4, #1
    4ffe:	429c      	cmp	r4, r3
    5000:	bf2a      	itet	cs
    5002:	f04f 0a00 	movcs.w	sl, #0
    5006:	fa5f fa84 	uxtbcc.w	sl, r4
    500a:	4654      	movcs	r4, sl
	while (tx_buffer_tail == head) {
    500c:	46ab      	mov	fp, r5
    500e:	782b      	ldrb	r3, [r5, #0]
    5010:	42a3      	cmp	r3, r4
    5012:	d11c      	bne.n	504e <serial_putchar.part.0+0x76>
		int priority = nvic_execution_priority();
    5014:	f7ff fcd6 	bl	49c4 <nvic_execution_priority>
		if (priority <= IRQ_PRIORITY) {
    5018:	2840      	cmp	r0, #64	; 0x40
    501a:	dc2b      	bgt.n	5074 <serial_putchar.part.0+0x9c>
			if ((UART0_S1 & UART_S1_TDRE)) {
    501c:	7933      	ldrb	r3, [r6, #4]
    501e:	061b      	lsls	r3, r3, #24
    5020:	d5f5      	bpl.n	500e <serial_putchar.part.0+0x36>
				uint32_t tail = tx_buffer_tail;
    5022:	f89b 3000 	ldrb.w	r3, [fp]
				if (++tail >= tx_buffer_total_size_) tail = 0;
    5026:	f8d8 1000 	ldr.w	r1, [r8]
	if (++head >= tx_buffer_total_size_) head = 0;
	while (tx_buffer_tail == head) {
		int priority = nvic_execution_priority();
		if (priority <= IRQ_PRIORITY) {
			if ((UART0_S1 & UART_S1_TDRE)) {
				uint32_t tail = tx_buffer_tail;
    502a:	b2db      	uxtb	r3, r3
				if (++tail >= tx_buffer_total_size_) tail = 0;
    502c:	1c5a      	adds	r2, r3, #1
    502e:	428a      	cmp	r2, r1
    5030:	d225      	bcs.n	507e <serial_putchar.part.0+0xa6>
				if (tail < SERIAL1_TX_BUFFER_SIZE) {
    5032:	2a3f      	cmp	r2, #63	; 0x3f
    5034:	d929      	bls.n	508a <serial_putchar.part.0+0xb2>
					n = tx_buffer[tail];
				} else {
					n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
    5036:	4919      	ldr	r1, [pc, #100]	; (509c <serial_putchar.part.0+0xc4>)
    5038:	3b3f      	subs	r3, #63	; 0x3f
    503a:	6809      	ldr	r1, [r1, #0]
    503c:	5ccb      	ldrb	r3, [r1, r3]
    503e:	b2d1      	uxtb	r1, r2
    5040:	b2db      	uxtb	r3, r3
				}
				if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
				UART0_D = n;
    5042:	b2db      	uxtb	r3, r3
    5044:	71f3      	strb	r3, [r6, #7]
				tx_buffer_tail = tail;
    5046:	7029      	strb	r1, [r5, #0]
		__enable_irq();
	}
	#endif 
	head = tx_buffer_head;
	if (++head >= tx_buffer_total_size_) head = 0;
	while (tx_buffer_tail == head) {
    5048:	782b      	ldrb	r3, [r5, #0]
    504a:	42a3      	cmp	r3, r4
    504c:	d0e2      	beq.n	5014 <serial_putchar.part.0+0x3c>
			}
		} else if (priority >= 256) {
			yield();
		}
	}
	if (head < SERIAL1_TX_BUFFER_SIZE) {
    504e:	2c3f      	cmp	r4, #63	; 0x3f
		tx_buffer[head] = c;
	} else {
		tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = c;
    5050:	bf8a      	itet	hi
    5052:	4b12      	ldrhi	r3, [pc, #72]	; (509c <serial_putchar.part.0+0xc4>)
		} else if (priority >= 256) {
			yield();
		}
	}
	if (head < SERIAL1_TX_BUFFER_SIZE) {
		tx_buffer[head] = c;
    5054:	4b12      	ldrls	r3, [pc, #72]	; (50a0 <serial_putchar.part.0+0xc8>)
	} else {
		tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = c;
    5056:	681b      	ldrhi	r3, [r3, #0]
	}
	transmitting = 1;
    5058:	4912      	ldr	r1, [pc, #72]	; (50a4 <serial_putchar.part.0+0xcc>)
		}
	}
	if (head < SERIAL1_TX_BUFFER_SIZE) {
		tx_buffer[head] = c;
	} else {
		tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = c;
    505a:	bf88      	it	hi
    505c:	3c40      	subhi	r4, #64	; 0x40
    505e:	b2ff      	uxtb	r7, r7
    5060:	551f      	strb	r7, [r3, r4]
	}
	transmitting = 1;
	tx_buffer_head = head;
	UART0_C2 = C2_TX_ACTIVE;
    5062:	4b0d      	ldr	r3, [pc, #52]	; (5098 <serial_putchar.part.0+0xc0>)
	if (head < SERIAL1_TX_BUFFER_SIZE) {
		tx_buffer[head] = c;
	} else {
		tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = c;
	}
	transmitting = 1;
    5064:	2001      	movs	r0, #1
	tx_buffer_head = head;
	UART0_C2 = C2_TX_ACTIVE;
    5066:	22bc      	movs	r2, #188	; 0xbc
	if (head < SERIAL1_TX_BUFFER_SIZE) {
		tx_buffer[head] = c;
	} else {
		tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = c;
	}
	transmitting = 1;
    5068:	7008      	strb	r0, [r1, #0]
	tx_buffer_head = head;
    506a:	f889 a000 	strb.w	sl, [r9]
	UART0_C2 = C2_TX_ACTIVE;
    506e:	70da      	strb	r2, [r3, #3]
    5070:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
				UART0_D = n;
				tx_buffer_tail = tail;
			}
		} else if (priority >= 256) {
    5074:	28ff      	cmp	r0, #255	; 0xff
    5076:	ddca      	ble.n	500e <serial_putchar.part.0+0x36>
			yield();
    5078:	f001 fee4 	bl	6e44 <yield>
    507c:	e7c7      	b.n	500e <serial_putchar.part.0+0x36>
	while (tx_buffer_tail == head) {
		int priority = nvic_execution_priority();
		if (priority <= IRQ_PRIORITY) {
			if ((UART0_S1 & UART_S1_TDRE)) {
				uint32_t tail = tx_buffer_tail;
				if (++tail >= tx_buffer_total_size_) tail = 0;
    507e:	2100      	movs	r1, #0
    5080:	460a      	mov	r2, r1
				if (tail < SERIAL1_TX_BUFFER_SIZE) {
					n = tx_buffer[tail];
    5082:	4b07      	ldr	r3, [pc, #28]	; (50a0 <serial_putchar.part.0+0xc8>)
    5084:	5c9b      	ldrb	r3, [r3, r2]
    5086:	b2db      	uxtb	r3, r3
    5088:	e7db      	b.n	5042 <serial_putchar.part.0+0x6a>
    508a:	b2d1      	uxtb	r1, r2
    508c:	e7f9      	b.n	5082 <serial_putchar.part.0+0xaa>
    508e:	bf00      	nop
    5090:	1fffb4dc 	.word	0x1fffb4dc
    5094:	1fffb4d5 	.word	0x1fffb4d5
    5098:	4006a000 	.word	0x4006a000
    509c:	1fffb490 	.word	0x1fffb490
    50a0:	1fffb44c 	.word	0x1fffb44c
    50a4:	1fffb4d4 	.word	0x1fffb4d4
    50a8:	1fffb4e0 	.word	0x1fffb4e0
    50ac:	1fff8740 	.word	0x1fff8740

000050b0 <serial_begin>:
#define C3_TXDIR_BIT 5


void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
    50b0:	4a2b      	ldr	r2, [pc, #172]	; (5160 <serial_begin+0xb0>)
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
    50b2:	492c      	ldr	r1, [pc, #176]	; (5164 <serial_begin+0xb4>)
#define C3_TXDIR_BIT 5


void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
    50b4:	6813      	ldr	r3, [r2, #0]
#define GPIO_BITBAND_PTR(reg, bit) ((uint32_t *)GPIO_BITBAND_ADDR((reg), (bit)))
#define C3_TXDIR_BIT 5


void serial_begin(uint32_t divisor)
{
    50b6:	b5f0      	push	{r4, r5, r6, r7, lr}
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
    50b8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    50bc:	6013      	str	r3, [r2, #0]
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
    50be:	780a      	ldrb	r2, [r1, #0]


void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
	rx_buffer_head = 0;
    50c0:	4f29      	ldr	r7, [pc, #164]	; (5168 <serial_begin+0xb8>)
	rx_buffer_tail = 0;
    50c2:	4e2a      	ldr	r6, [pc, #168]	; (516c <serial_begin+0xbc>)
	tx_buffer_head = 0;
    50c4:	4d2a      	ldr	r5, [pc, #168]	; (5170 <serial_begin+0xc0>)
	tx_buffer_tail = 0;
    50c6:	4c2b      	ldr	r4, [pc, #172]	; (5174 <serial_begin+0xc4>)
	transmitting = 0;
    50c8:	492b      	ldr	r1, [pc, #172]	; (5178 <serial_begin+0xc8>)


void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
	rx_buffer_head = 0;
    50ca:	2300      	movs	r3, #0
    50cc:	703b      	strb	r3, [r7, #0]
	rx_buffer_tail = 0;
    50ce:	7033      	strb	r3, [r6, #0]
	tx_buffer_head = 0;
    50d0:	702b      	strb	r3, [r5, #0]
	tx_buffer_tail = 0;
    50d2:	7023      	strb	r3, [r4, #0]
	transmitting = 0;
    50d4:	700b      	strb	r3, [r1, #0]
	switch (rx_pin_num) {
    50d6:	2a00      	cmp	r2, #0
    50d8:	d03d      	beq.n	5156 <serial_begin+0xa6>
    50da:	2a15      	cmp	r2, #21
    50dc:	d021      	beq.n	5122 <serial_begin+0x72>
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
    50de:	4b27      	ldr	r3, [pc, #156]	; (517c <serial_begin+0xcc>)
    50e0:	781b      	ldrb	r3, [r3, #0]
    50e2:	2b01      	cmp	r3, #1
    50e4:	d025      	beq.n	5132 <serial_begin+0x82>
    50e6:	2b05      	cmp	r3, #5
    50e8:	d030      	beq.n	514c <serial_begin+0x9c>
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
    50ea:	281f      	cmp	r0, #31
    50ec:	d827      	bhi.n	513e <serial_begin+0x8e>
    50ee:	2000      	movs	r0, #0
    50f0:	4602      	mov	r2, r0
    50f2:	2501      	movs	r5, #1
	UART0_BDH = (divisor >> 13) & 0x1F;
    50f4:	4b22      	ldr	r3, [pc, #136]	; (5180 <serial_begin+0xd0>)
	UART0_BDH = (divisor >> 8) & 0x1F;
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
    50f6:	4c23      	ldr	r4, [pc, #140]	; (5184 <serial_begin+0xd4>)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
	UART0_BDH = (divisor >> 13) & 0x1F;
    50f8:	701a      	strb	r2, [r3, #0]
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
    50fa:	4923      	ldr	r1, [pc, #140]	; (5188 <serial_begin+0xd8>)
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
	UART0_BDH = (divisor >> 13) & 0x1F;
	UART0_BDL = (divisor >> 5) & 0xFF;
    50fc:	705d      	strb	r5, [r3, #1]
	UART0_C4 = divisor & 0x1F;
#ifdef HAS_KINETISK_UART0_FIFO
	UART0_C1 = UART_C1_ILT;
    50fe:	2204      	movs	r2, #4
	UART0_TWFIFO = 2; // tx watermark, causes S1_TDRE to set
    5100:	f04f 0e02 	mov.w	lr, #2
	UART0_RWFIFO = 4; // rx watermark, causes S1_RDRF to set
	UART0_PFIFO = UART_PFIFO_TXFE | UART_PFIFO_RXFE;
    5104:	2788      	movs	r7, #136	; 0x88
	if (divisor < 1) divisor = 1;
	UART0_BDH = (divisor >> 8) & 0x1F;
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
    5106:	263c      	movs	r6, #60	; 0x3c
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
    5108:	2540      	movs	r5, #64	; 0x40
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
	UART0_BDH = (divisor >> 13) & 0x1F;
	UART0_BDL = (divisor >> 5) & 0xFF;
	UART0_C4 = divisor & 0x1F;
    510a:	7298      	strb	r0, [r3, #10]
#ifdef HAS_KINETISK_UART0_FIFO
	UART0_C1 = UART_C1_ILT;
    510c:	709a      	strb	r2, [r3, #2]
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
    510e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
	UART0_BDH = (divisor >> 13) & 0x1F;
	UART0_BDL = (divisor >> 5) & 0xFF;
	UART0_C4 = divisor & 0x1F;
#ifdef HAS_KINETISK_UART0_FIFO
	UART0_C1 = UART_C1_ILT;
	UART0_TWFIFO = 2; // tx watermark, causes S1_TDRE to set
    5112:	f883 e013 	strb.w	lr, [r3, #19]
	UART0_RWFIFO = 4; // rx watermark, causes S1_RDRF to set
    5116:	755a      	strb	r2, [r3, #21]
	UART0_PFIFO = UART_PFIFO_TXFE | UART_PFIFO_RXFE;
    5118:	741f      	strb	r7, [r3, #16]
	if (divisor < 1) divisor = 1;
	UART0_BDH = (divisor >> 8) & 0x1F;
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
    511a:	70de      	strb	r6, [r3, #3]
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
    511c:	7025      	strb	r5, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
    511e:	6008      	str	r0, [r1, #0]
    5120:	bdf0      	pop	{r4, r5, r6, r7, pc}
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		case 21: CORE_PIN21_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    5122:	4b1a      	ldr	r3, [pc, #104]	; (518c <serial_begin+0xdc>)
    5124:	f240 3213 	movw	r2, #787	; 0x313
    5128:	601a      	str	r2, [r3, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
    512a:	4b14      	ldr	r3, [pc, #80]	; (517c <serial_begin+0xcc>)
    512c:	781b      	ldrb	r3, [r3, #0]
    512e:	2b01      	cmp	r3, #1
    5130:	d1d9      	bne.n	50e6 <serial_begin+0x36>
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    5132:	4b17      	ldr	r3, [pc, #92]	; (5190 <serial_begin+0xe0>)
    5134:	f44f 7251 	mov.w	r2, #836	; 0x344
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
    5138:	281f      	cmp	r0, #31
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    513a:	601a      	str	r2, [r3, #0]
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
    513c:	d9d7      	bls.n	50ee <serial_begin+0x3e>
    513e:	f3c0 3244 	ubfx	r2, r0, #13, #5
    5142:	f3c0 1547 	ubfx	r5, r0, #5, #8
    5146:	f000 001f 	and.w	r0, r0, #31
    514a:	e7d3      	b.n	50f4 <serial_begin+0x44>
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		case 5:  CORE_PIN5_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    514c:	4b11      	ldr	r3, [pc, #68]	; (5194 <serial_begin+0xe4>)
    514e:	f44f 7251 	mov.w	r2, #836	; 0x344
    5152:	601a      	str	r2, [r3, #0]
    5154:	e7c9      	b.n	50ea <serial_begin+0x3a>
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    5156:	4b10      	ldr	r3, [pc, #64]	; (5198 <serial_begin+0xe8>)
    5158:	f240 3213 	movw	r2, #787	; 0x313
    515c:	601a      	str	r2, [r3, #0]
    515e:	e7be      	b.n	50de <serial_begin+0x2e>
    5160:	40048034 	.word	0x40048034
    5164:	1fffb48c 	.word	0x1fffb48c
    5168:	1fffb448 	.word	0x1fffb448
    516c:	1fffb449 	.word	0x1fffb449
    5170:	1fffb4e0 	.word	0x1fffb4e0
    5174:	1fffb4d5 	.word	0x1fffb4d5
    5178:	1fffb4d4 	.word	0x1fffb4d4
    517c:	1fff8744 	.word	0x1fff8744
    5180:	4006a000 	.word	0x4006a000
    5184:	e000e42d 	.word	0xe000e42d
    5188:	e000e104 	.word	0xe000e104
    518c:	4004c018 	.word	0x4004c018
    5190:	4004a044 	.word	0x4004a044
    5194:	4004c01c 	.word	0x4004c01c
    5198:	4004a040 	.word	0x4004a040

0000519c <serial_format>:

void serial_format(uint32_t format)
{
	uint8_t c;

	c = UART0_C1;
    519c:	4b23      	ldr	r3, [pc, #140]	; (522c <serial_format+0x90>)
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
    519e:	4923      	ldr	r1, [pc, #140]	; (522c <serial_format+0x90>)

void serial_format(uint32_t format)
{
	uint8_t c;

	c = UART0_C1;
    51a0:	789b      	ldrb	r3, [r3, #2]
	c = (c & ~0x13) | (format & 0x03);	// configure parity
    51a2:	f003 02ec 	and.w	r2, r3, #236	; 0xec
    51a6:	f000 0303 	and.w	r3, r0, #3
    51aa:	4313      	orrs	r3, r2
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
    51ac:	0742      	lsls	r2, r0, #29
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    51ae:	f000 020f 	and.w	r2, r0, #15
{
	uint8_t c;

	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
    51b2:	bf48      	it	mi
    51b4:	f043 0310 	orrmi.w	r3, r3, #16
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    51b8:	2a04      	cmp	r2, #4
	uint8_t c;

	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
    51ba:	708b      	strb	r3, [r1, #2]
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    51bc:	d02e      	beq.n	521c <serial_format+0x80>
	c = UART0_S2 & ~0x10;
    51be:	4b1b      	ldr	r3, [pc, #108]	; (522c <serial_format+0x90>)
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
    51c0:	4a1a      	ldr	r2, [pc, #104]	; (522c <serial_format+0x90>)
	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
    51c2:	795b      	ldrb	r3, [r3, #5]
	if (format & 0x10) c |= 0x10;		// rx invert
    51c4:	06c1      	lsls	r1, r0, #27
	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
    51c6:	f003 03ef 	and.w	r3, r3, #239	; 0xef
	if (format & 0x10) c |= 0x10;		// rx invert
    51ca:	bf48      	it	mi
    51cc:	f043 0310 	orrmi.w	r3, r3, #16
	UART0_S2 = c;
    51d0:	7153      	strb	r3, [r2, #5]
	c = UART0_C3 & ~0x10;
    51d2:	7993      	ldrb	r3, [r2, #6]
	if (format & 0x20) c |= 0x10;		// tx invert
    51d4:	0682      	lsls	r2, r0, #26
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
	c = UART0_C3 & ~0x10;
    51d6:	f003 03ef 	and.w	r3, r3, #239	; 0xef
	if (format & 0x20) c |= 0x10;		// tx invert
	UART0_C3 = c;
    51da:	4a14      	ldr	r2, [pc, #80]	; (522c <serial_format+0x90>)
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
	c = UART0_C3 & ~0x10;
	if (format & 0x20) c |= 0x10;		// tx invert
    51dc:	bf48      	it	mi
    51de:	f043 0310 	orrmi.w	r3, r3, #16
		UART0_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
		UART0_BDL = bdl;		// Says BDH not acted on until BDL is written
	}
#endif
	// process request for half duplex.
	if ((format & SERIAL_HALF_DUPLEX) != 0) {
    51e2:	f410 7000 	ands.w	r0, r0, #512	; 0x200
	c = UART0_S2 & ~0x10;
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
	c = UART0_C3 & ~0x10;
	if (format & 0x20) c |= 0x10;		// tx invert
	UART0_C3 = c;
    51e6:	7193      	strb	r3, [r2, #6]
		UART0_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
		UART0_BDL = bdl;		// Says BDH not acted on until BDL is written
	}
#endif
	// process request for half duplex.
	if ((format & SERIAL_HALF_DUPLEX) != 0) {
    51e8:	d105      	bne.n	51f6 <serial_format+0x5a>

	} else {
		#if defined(KINETISL)
		half_duplex_mode = 0; 
		#else
		if (transmit_pin == (uint8_t*)GPIO_BITBAND_PTR(UART0_C3, C3_TXDIR_BIT)) transmit_pin = NULL;
    51ea:	4b11      	ldr	r3, [pc, #68]	; (5230 <serial_format+0x94>)
    51ec:	4a11      	ldr	r2, [pc, #68]	; (5234 <serial_format+0x98>)
    51ee:	6819      	ldr	r1, [r3, #0]
    51f0:	4291      	cmp	r1, r2
    51f2:	d018      	beq.n	5226 <serial_format+0x8a>
		#endif
	}
}
    51f4:	4770      	bx	lr
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
}

void serial_format(uint32_t format)
{
    51f6:	b430      	push	{r4, r5}
		UART0_BDL = bdl;		// Says BDH not acted on until BDL is written
	}
#endif
	// process request for half duplex.
	if ((format & SERIAL_HALF_DUPLEX) != 0) {
		c = UART0_C1;
    51f8:	7891      	ldrb	r1, [r2, #2]
			case 4:  CORE_PIN4_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2) | PORT_PCR_PE | PORT_PCR_PS; break;
			case 24: CORE_PIN24_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(4) | PORT_PCR_PE | PORT_PCR_PS; break;
		}
		half_duplex_mode = 1; 
		#else
		volatile uint32_t *reg = portConfigRegister(tx_pin_num);
    51fa:	4d0f      	ldr	r5, [pc, #60]	; (5238 <serial_format+0x9c>)
    51fc:	4b0f      	ldr	r3, [pc, #60]	; (523c <serial_format+0xa0>)
		*reg = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3) | PORT_PCR_PE | PORT_PCR_PS; // pullup on output pin;
		transmit_pin = (uint8_t*)GPIO_BITBAND_PTR(UART0_C3, C3_TXDIR_BIT);
    51fe:	480c      	ldr	r0, [pc, #48]	; (5230 <serial_format+0x94>)
    5200:	4c0c      	ldr	r4, [pc, #48]	; (5234 <serial_format+0x98>)
	}
#endif
	// process request for half duplex.
	if ((format & SERIAL_HALF_DUPLEX) != 0) {
		c = UART0_C1;
		c |= UART_C1_LOOPS | UART_C1_RSRC;
    5202:	f041 01a0 	orr.w	r1, r1, #160	; 0xa0
		UART0_C1 = c;
    5206:	7091      	strb	r1, [r2, #2]
			case 4:  CORE_PIN4_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2) | PORT_PCR_PE | PORT_PCR_PS; break;
			case 24: CORE_PIN24_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(4) | PORT_PCR_PE | PORT_PCR_PS; break;
		}
		half_duplex_mode = 1; 
		#else
		volatile uint32_t *reg = portConfigRegister(tx_pin_num);
    5208:	782a      	ldrb	r2, [r5, #0]
		*reg = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3) | PORT_PCR_PE | PORT_PCR_PS; // pullup on output pin;
		transmit_pin = (uint8_t*)GPIO_BITBAND_PTR(UART0_C3, C3_TXDIR_BIT);
    520a:	6004      	str	r4, [r0, #0]
			case 4:  CORE_PIN4_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2) | PORT_PCR_PE | PORT_PCR_PS; break;
			case 24: CORE_PIN24_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(4) | PORT_PCR_PE | PORT_PCR_PS; break;
		}
		half_duplex_mode = 1; 
		#else
		volatile uint32_t *reg = portConfigRegister(tx_pin_num);
    520c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
		*reg = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3) | PORT_PCR_PE | PORT_PCR_PS; // pullup on output pin;
    5210:	f240 3247 	movw	r2, #839	; 0x347
			case 4:  CORE_PIN4_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2) | PORT_PCR_PE | PORT_PCR_PS; break;
			case 24: CORE_PIN24_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(4) | PORT_PCR_PE | PORT_PCR_PS; break;
		}
		half_duplex_mode = 1; 
		#else
		volatile uint32_t *reg = portConfigRegister(tx_pin_num);
    5214:	685b      	ldr	r3, [r3, #4]
		half_duplex_mode = 0; 
		#else
		if (transmit_pin == (uint8_t*)GPIO_BITBAND_PTR(UART0_C3, C3_TXDIR_BIT)) transmit_pin = NULL;
		#endif
	}
}
    5216:	bc30      	pop	{r4, r5}
			case 24: CORE_PIN24_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(4) | PORT_PCR_PE | PORT_PCR_PS; break;
		}
		half_duplex_mode = 1; 
		#else
		volatile uint32_t *reg = portConfigRegister(tx_pin_num);
		*reg = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3) | PORT_PCR_PE | PORT_PCR_PS; // pullup on output pin;
    5218:	601a      	str	r2, [r3, #0]
		half_duplex_mode = 0; 
		#else
		if (transmit_pin == (uint8_t*)GPIO_BITBAND_PTR(UART0_C3, C3_TXDIR_BIT)) transmit_pin = NULL;
		#endif
	}
}
    521a:	4770      	bx	lr

	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    521c:	798b      	ldrb	r3, [r1, #6]
    521e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5222:	718b      	strb	r3, [r1, #6]
    5224:	e7cb      	b.n	51be <serial_format+0x22>

	} else {
		#if defined(KINETISL)
		half_duplex_mode = 0; 
		#else
		if (transmit_pin == (uint8_t*)GPIO_BITBAND_PTR(UART0_C3, C3_TXDIR_BIT)) transmit_pin = NULL;
    5226:	6018      	str	r0, [r3, #0]
		#endif
	}
}
    5228:	4770      	bx	lr
    522a:	bf00      	nop
    522c:	4006a000 	.word	0x4006a000
    5230:	1fffb4dc 	.word	0x1fffb4dc
    5234:	42d400d4 	.word	0x42d400d4
    5238:	1fff8744 	.word	0x1fff8744
    523c:	00009520 	.word	0x00009520

00005240 <serial_end>:

void serial_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    5240:	4b23      	ldr	r3, [pc, #140]	; (52d0 <serial_end+0x90>)
    5242:	681b      	ldr	r3, [r3, #0]
    5244:	055b      	lsls	r3, r3, #21
    5246:	d541      	bpl.n	52cc <serial_end+0x8c>
		#endif
	}
}

void serial_end(void)
{
    5248:	b510      	push	{r4, lr}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
    524a:	4c22      	ldr	r4, [pc, #136]	; (52d4 <serial_end+0x94>)
    524c:	7823      	ldrb	r3, [r4, #0]
    524e:	b123      	cbz	r3, 525a <serial_end+0x1a>
    5250:	f001 fdf8 	bl	6e44 <yield>
    5254:	7823      	ldrb	r3, [r4, #0]
    5256:	2b00      	cmp	r3, #0
    5258:	d1fa      	bne.n	5250 <serial_end+0x10>
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
    525a:	481f      	ldr	r0, [pc, #124]	; (52d8 <serial_end+0x98>)
	UART0_C2 = 0;
    525c:	4a1f      	ldr	r2, [pc, #124]	; (52dc <serial_end+0x9c>)
	switch (rx_pin_num) {
    525e:	4b20      	ldr	r3, [pc, #128]	; (52e0 <serial_end+0xa0>)

void serial_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
    5260:	f44f 5400 	mov.w	r4, #8192	; 0x2000
	UART0_C2 = 0;
    5264:	2100      	movs	r1, #0

void serial_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
    5266:	6004      	str	r4, [r0, #0]
	UART0_C2 = 0;
    5268:	70d1      	strb	r1, [r2, #3]
	switch (rx_pin_num) {
    526a:	781b      	ldrb	r3, [r3, #0]
    526c:	b1fb      	cbz	r3, 52ae <serial_end+0x6e>
    526e:	2b15      	cmp	r3, #21
    5270:	d103      	bne.n	527a <serial_end+0x3a>
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		case 21: CORE_PIN21_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    5272:	4b1c      	ldr	r3, [pc, #112]	; (52e4 <serial_end+0xa4>)
    5274:	f240 1203 	movw	r2, #259	; 0x103
    5278:	601a      	str	r2, [r3, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	switch (tx_pin_num & 127) {
    527a:	4b1b      	ldr	r3, [pc, #108]	; (52e8 <serial_end+0xa8>)
    527c:	781b      	ldrb	r3, [r3, #0]
    527e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    5282:	2b01      	cmp	r3, #1
    5284:	d01d      	beq.n	52c2 <serial_end+0x82>
    5286:	2b05      	cmp	r3, #5
    5288:	d103      	bne.n	5292 <serial_end+0x52>
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		case 5:  CORE_PIN5_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    528a:	4b18      	ldr	r3, [pc, #96]	; (52ec <serial_end+0xac>)
    528c:	f240 1203 	movw	r2, #259	; 0x103
    5290:	601a      	str	r2, [r3, #0]
	}
	UART0_S1;
	UART0_D; // clear leftover error status
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	if (rts_pin) rts_deassert();
    5292:	4a17      	ldr	r2, [pc, #92]	; (52f0 <serial_end+0xb0>)
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	UART0_S1;
    5294:	4b11      	ldr	r3, [pc, #68]	; (52dc <serial_end+0x9c>)
	UART0_D; // clear leftover error status
	rx_buffer_head = 0;
    5296:	4817      	ldr	r0, [pc, #92]	; (52f4 <serial_end+0xb4>)
	rx_buffer_tail = 0;
    5298:	4917      	ldr	r1, [pc, #92]	; (52f8 <serial_end+0xb8>)
	if (rts_pin) rts_deassert();
    529a:	6812      	ldr	r2, [r2, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	UART0_S1;
    529c:	791c      	ldrb	r4, [r3, #4]
	UART0_D; // clear leftover error status
    529e:	79db      	ldrb	r3, [r3, #7]
	rx_buffer_head = 0;
    52a0:	2300      	movs	r3, #0
    52a2:	7003      	strb	r3, [r0, #0]
	rx_buffer_tail = 0;
    52a4:	700b      	strb	r3, [r1, #0]
	if (rts_pin) rts_deassert();
    52a6:	b10a      	cbz	r2, 52ac <serial_end+0x6c>
    52a8:	2301      	movs	r3, #1
    52aa:	7013      	strb	r3, [r2, #0]
    52ac:	bd10      	pop	{r4, pc}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
	UART0_C2 = 0;
	switch (rx_pin_num) {
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    52ae:	4b13      	ldr	r3, [pc, #76]	; (52fc <serial_end+0xbc>)
    52b0:	f240 1203 	movw	r2, #259	; 0x103
    52b4:	601a      	str	r2, [r3, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	switch (tx_pin_num & 127) {
    52b6:	4b0c      	ldr	r3, [pc, #48]	; (52e8 <serial_end+0xa8>)
    52b8:	781b      	ldrb	r3, [r3, #0]
    52ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    52be:	2b01      	cmp	r3, #1
    52c0:	d1e1      	bne.n	5286 <serial_end+0x46>
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    52c2:	4b0f      	ldr	r3, [pc, #60]	; (5300 <serial_end+0xc0>)
    52c4:	f240 1203 	movw	r2, #259	; 0x103
    52c8:	601a      	str	r2, [r3, #0]
    52ca:	e7e2      	b.n	5292 <serial_end+0x52>
    52cc:	4770      	bx	lr
    52ce:	bf00      	nop
    52d0:	40048034 	.word	0x40048034
    52d4:	1fffb4d4 	.word	0x1fffb4d4
    52d8:	e000e184 	.word	0xe000e184
    52dc:	4006a000 	.word	0x4006a000
    52e0:	1fffb48c 	.word	0x1fffb48c
    52e4:	4004c018 	.word	0x4004c018
    52e8:	1fff8744 	.word	0x1fff8744
    52ec:	4004c01c 	.word	0x4004c01c
    52f0:	1fffb444 	.word	0x1fffb444
    52f4:	1fffb448 	.word	0x1fffb448
    52f8:	1fffb449 	.word	0x1fffb449
    52fc:	4004a040 	.word	0x4004a040
    5300:	4004a044 	.word	0x4004a044

00005304 <serial_set_transmit_pin>:
	rx_buffer_tail = 0;
	if (rts_pin) rts_deassert();
}

void serial_set_transmit_pin(uint8_t pin)
{
    5304:	4a0a      	ldr	r2, [pc, #40]	; (5330 <serial_set_transmit_pin+0x2c>)
    5306:	b538      	push	{r3, r4, r5, lr}
    5308:	4605      	mov	r5, r0
	while (transmitting) ;
    530a:	7813      	ldrb	r3, [r2, #0]
    530c:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    5310:	2b00      	cmp	r3, #0
    5312:	d1fa      	bne.n	530a <serial_set_transmit_pin+0x6>
	pinMode(pin, OUTPUT);
    5314:	2101      	movs	r1, #1
    5316:	4628      	mov	r0, r5
    5318:	f7ff fd78 	bl	4e0c <pinMode>
	digitalWrite(pin, LOW);
    531c:	4621      	mov	r1, r4
    531e:	4628      	mov	r0, r5
    5320:	f7ff fd6e 	bl	4e00 <digitalWrite>
	transmit_pin = portOutputRegister(pin);
    5324:	4a03      	ldr	r2, [pc, #12]	; (5334 <serial_set_transmit_pin+0x30>)
    5326:	4b04      	ldr	r3, [pc, #16]	; (5338 <serial_set_transmit_pin+0x34>)
    5328:	f852 2035 	ldr.w	r2, [r2, r5, lsl #3]
    532c:	601a      	str	r2, [r3, #0]
    532e:	bd38      	pop	{r3, r4, r5, pc}
    5330:	1fffb4d4 	.word	0x1fffb4d4
    5334:	00009520 	.word	0x00009520
    5338:	1fffb4dc 	.word	0x1fffb4dc

0000533c <serial_set_tx>:

void serial_set_tx(uint8_t pin, uint8_t opendrain)
{
	uint32_t cfg;

	if (opendrain) pin |= 128;
    533c:	b109      	cbz	r1, 5342 <serial_set_tx+0x6>
    533e:	f040 0080 	orr.w	r0, r0, #128	; 0x80
	if (pin == tx_pin_num) return;
    5342:	4a17      	ldr	r2, [pc, #92]	; (53a0 <serial_set_tx+0x64>)
    5344:	7813      	ldrb	r3, [r2, #0]
    5346:	4298      	cmp	r0, r3
    5348:	d016      	beq.n	5378 <serial_set_tx+0x3c>
	transmit_mask = digitalPinToBitMask(pin);
	#endif
}

void serial_set_tx(uint8_t pin, uint8_t opendrain)
{
    534a:	b410      	push	{r4}
	uint32_t cfg;

	if (opendrain) pin |= 128;
	if (pin == tx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
    534c:	4c15      	ldr	r4, [pc, #84]	; (53a4 <serial_set_tx+0x68>)
    534e:	6824      	ldr	r4, [r4, #0]
    5350:	0564      	lsls	r4, r4, #21
    5352:	d50f      	bpl.n	5374 <serial_set_tx+0x38>
		switch (tx_pin_num & 127) {
    5354:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    5358:	2b01      	cmp	r3, #1
    535a:	d01c      	beq.n	5396 <serial_set_tx+0x5a>
    535c:	2b05      	cmp	r3, #5
    535e:	d011      	beq.n	5384 <serial_set_tx+0x48>
			#endif
		}
		if (opendrain) {
			cfg = PORT_PCR_DSE | PORT_PCR_ODE;
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
    5360:	2900      	cmp	r1, #0
		}
		switch (pin & 127) {
    5362:	f000 017f 	and.w	r1, r0, #127	; 0x7f
			#endif
		}
		if (opendrain) {
			cfg = PORT_PCR_DSE | PORT_PCR_ODE;
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
    5366:	bf14      	ite	ne
    5368:	2360      	movne	r3, #96	; 0x60
    536a:	2344      	moveq	r3, #68	; 0x44
		}
		switch (pin & 127) {
    536c:	2901      	cmp	r1, #1
    536e:	d00d      	beq.n	538c <serial_set_tx+0x50>
    5370:	2905      	cmp	r1, #5
    5372:	d002      	beq.n	537a <serial_set_tx+0x3e>
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 26: CORE_PIN26_CONFIG = cfg | PORT_PCR_MUX(3); break;
			#endif
		}
	}
	tx_pin_num = pin;
    5374:	7010      	strb	r0, [r2, #0]
}
    5376:	bc10      	pop	{r4}
    5378:	4770      	bx	lr
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
		}
		switch (pin & 127) {
			case 1:  CORE_PIN1_CONFIG = cfg | PORT_PCR_MUX(3); break;
			case 5:  CORE_PIN5_CONFIG = cfg | PORT_PCR_MUX(3); break;
    537a:	490b      	ldr	r1, [pc, #44]	; (53a8 <serial_set_tx+0x6c>)
    537c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    5380:	600b      	str	r3, [r1, #0]
    5382:	e7f7      	b.n	5374 <serial_set_tx+0x38>
	if (opendrain) pin |= 128;
	if (pin == tx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (tx_pin_num & 127) {
			case 1:  CORE_PIN1_CONFIG = 0; break; // PTB17
			case 5:  CORE_PIN5_CONFIG = 0; break; // PTD7
    5384:	4b08      	ldr	r3, [pc, #32]	; (53a8 <serial_set_tx+0x6c>)
    5386:	2400      	movs	r4, #0
    5388:	601c      	str	r4, [r3, #0]
    538a:	e7e9      	b.n	5360 <serial_set_tx+0x24>
			cfg = PORT_PCR_DSE | PORT_PCR_ODE;
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
		}
		switch (pin & 127) {
			case 1:  CORE_PIN1_CONFIG = cfg | PORT_PCR_MUX(3); break;
    538c:	4907      	ldr	r1, [pc, #28]	; (53ac <serial_set_tx+0x70>)
    538e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    5392:	600b      	str	r3, [r1, #0]
    5394:	e7ee      	b.n	5374 <serial_set_tx+0x38>

	if (opendrain) pin |= 128;
	if (pin == tx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (tx_pin_num & 127) {
			case 1:  CORE_PIN1_CONFIG = 0; break; // PTB17
    5396:	4b05      	ldr	r3, [pc, #20]	; (53ac <serial_set_tx+0x70>)
    5398:	2400      	movs	r4, #0
    539a:	601c      	str	r4, [r3, #0]
    539c:	e7e0      	b.n	5360 <serial_set_tx+0x24>
    539e:	bf00      	nop
    53a0:	1fff8744 	.word	0x1fff8744
    53a4:	40048034 	.word	0x40048034
    53a8:	4004c01c 	.word	0x4004c01c
    53ac:	4004a044 	.word	0x4004a044

000053b0 <serial_set_rx>:
	tx_pin_num = pin;
}

void serial_set_rx(uint8_t pin)
{
	if (pin == rx_pin_num) return;
    53b0:	4b10      	ldr	r3, [pc, #64]	; (53f4 <serial_set_rx+0x44>)
    53b2:	781a      	ldrb	r2, [r3, #0]
    53b4:	4282      	cmp	r2, r0
    53b6:	d00a      	beq.n	53ce <serial_set_rx+0x1e>
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
    53b8:	490f      	ldr	r1, [pc, #60]	; (53f8 <serial_set_rx+0x48>)
    53ba:	6809      	ldr	r1, [r1, #0]
    53bc:	0549      	lsls	r1, r1, #21
    53be:	d505      	bpl.n	53cc <serial_set_rx+0x1c>
		switch (rx_pin_num) {
    53c0:	b1aa      	cbz	r2, 53ee <serial_set_rx+0x3e>
    53c2:	2a15      	cmp	r2, #21
    53c4:	d009      	beq.n	53da <serial_set_rx+0x2a>
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
    53c6:	b168      	cbz	r0, 53e4 <serial_set_rx+0x34>
    53c8:	2815      	cmp	r0, #21
    53ca:	d001      	beq.n	53d0 <serial_set_rx+0x20>
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
			#endif
		}
	}
	rx_pin_num = pin;
    53cc:	7018      	strb	r0, [r3, #0]
    53ce:	4770      	bx	lr
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
			case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
			case 21: CORE_PIN21_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    53d0:	4a0a      	ldr	r2, [pc, #40]	; (53fc <serial_set_rx+0x4c>)
    53d2:	f240 3113 	movw	r1, #787	; 0x313
    53d6:	6011      	str	r1, [r2, #0]
    53d8:	e7f8      	b.n	53cc <serial_set_rx+0x1c>
{
	if (pin == rx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (rx_pin_num) {
			case 0:  CORE_PIN0_CONFIG = 0; break; // PTB16
			case 21: CORE_PIN21_CONFIG = 0; break; // PTD6
    53da:	4a08      	ldr	r2, [pc, #32]	; (53fc <serial_set_rx+0x4c>)
    53dc:	2100      	movs	r1, #0
    53de:	6011      	str	r1, [r2, #0]
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
    53e0:	2800      	cmp	r0, #0
    53e2:	d1f1      	bne.n	53c8 <serial_set_rx+0x18>
			case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    53e4:	4a06      	ldr	r2, [pc, #24]	; (5400 <serial_set_rx+0x50>)
    53e6:	f240 3113 	movw	r1, #787	; 0x313
    53ea:	6011      	str	r1, [r2, #0]
    53ec:	e7ee      	b.n	53cc <serial_set_rx+0x1c>
void serial_set_rx(uint8_t pin)
{
	if (pin == rx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (rx_pin_num) {
			case 0:  CORE_PIN0_CONFIG = 0; break; // PTB16
    53ee:	4904      	ldr	r1, [pc, #16]	; (5400 <serial_set_rx+0x50>)
    53f0:	600a      	str	r2, [r1, #0]
    53f2:	e7e8      	b.n	53c6 <serial_set_rx+0x16>
    53f4:	1fffb48c 	.word	0x1fffb48c
    53f8:	40048034 	.word	0x40048034
    53fc:	4004c018 	.word	0x4004c018
    5400:	4004a040 	.word	0x4004a040

00005404 <serial_set_rts>:



int serial_set_rts(uint8_t pin)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
    5404:	4b0d      	ldr	r3, [pc, #52]	; (543c <serial_set_rts+0x38>)
    5406:	681b      	ldr	r3, [r3, #0]
    5408:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
    540c:	d005      	beq.n	541a <serial_set_rts+0x16>
	if (pin < CORE_NUM_DIGITAL) {
    540e:	2821      	cmp	r0, #33	; 0x21
    5410:	d905      	bls.n	541e <serial_set_rts+0x1a>
		rts_mask = digitalPinToBitMask(pin);
		#endif
		pinMode(pin, OUTPUT);
		rts_assert();
	} else {
		rts_pin = NULL;
    5412:	4b0b      	ldr	r3, [pc, #44]	; (5440 <serial_set_rts+0x3c>)
    5414:	2000      	movs	r0, #0
    5416:	6018      	str	r0, [r3, #0]
		return 0;
    5418:	4770      	bx	lr



int serial_set_rts(uint8_t pin)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
    541a:	4618      	mov	r0, r3
    541c:	4770      	bx	lr
	if (pin < CORE_NUM_DIGITAL) {
		rts_pin = portOutputRegister(pin);
    541e:	4b09      	ldr	r3, [pc, #36]	; (5444 <serial_set_rts+0x40>)
}



int serial_set_rts(uint8_t pin)
{
    5420:	b510      	push	{r4, lr}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
	if (pin < CORE_NUM_DIGITAL) {
		rts_pin = portOutputRegister(pin);
    5422:	4c07      	ldr	r4, [pc, #28]	; (5440 <serial_set_rts+0x3c>)
    5424:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
    5428:	6023      	str	r3, [r4, #0]
		#if defined(KINETISL)
		rts_mask = digitalPinToBitMask(pin);
		#endif
		pinMode(pin, OUTPUT);
    542a:	2101      	movs	r1, #1
    542c:	f7ff fcee 	bl	4e0c <pinMode>
		rts_assert();
    5430:	6823      	ldr	r3, [r4, #0]
    5432:	2200      	movs	r2, #0
    5434:	701a      	strb	r2, [r3, #0]
		UART0_MODEM &= ~UART_MODEM_RXRTSE;
		return 0;
	}
	UART0_MODEM |= UART_MODEM_RXRTSE;
*/
	return 1;
    5436:	2001      	movs	r0, #1
    5438:	bd10      	pop	{r4, pc}
    543a:	bf00      	nop
    543c:	40048034 	.word	0x40048034
    5440:	1fffb444 	.word	0x1fffb444
    5444:	00009520 	.word	0x00009520

00005448 <serial_set_cts>:
}

int serial_set_cts(uint8_t pin)
{
#if defined(KINETISK)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
    5448:	4b0f      	ldr	r3, [pc, #60]	; (5488 <serial_set_cts+0x40>)
    544a:	681b      	ldr	r3, [r3, #0]
    544c:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
    5450:	d008      	beq.n	5464 <serial_set_cts+0x1c>
	if (pin == 18) {
    5452:	2812      	cmp	r0, #18
    5454:	d008      	beq.n	5468 <serial_set_cts+0x20>
		CORE_PIN18_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else if (pin == 20) {
    5456:	2814      	cmp	r0, #20
    5458:	d011      	beq.n	547e <serial_set_cts+0x36>
		CORE_PIN20_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else {
		UART0_MODEM &= ~UART_MODEM_TXCTSE;
    545a:	4a0c      	ldr	r2, [pc, #48]	; (548c <serial_set_cts+0x44>)
    545c:	7b53      	ldrb	r3, [r2, #13]
    545e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    5462:	7353      	strb	r3, [r2, #13]
		return 0;
    5464:	2000      	movs	r0, #0
    5466:	4770      	bx	lr
int serial_set_cts(uint8_t pin)
{
#if defined(KINETISK)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
	if (pin == 18) {
		CORE_PIN18_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
    5468:	4b09      	ldr	r3, [pc, #36]	; (5490 <serial_set_cts+0x48>)
    546a:	f240 3202 	movw	r2, #770	; 0x302
    546e:	601a      	str	r2, [r3, #0]
		CORE_PIN20_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else {
		UART0_MODEM &= ~UART_MODEM_TXCTSE;
		return 0;
	}
	UART0_MODEM |= UART_MODEM_TXCTSE;
    5470:	4a06      	ldr	r2, [pc, #24]	; (548c <serial_set_cts+0x44>)
    5472:	7b53      	ldrb	r3, [r2, #13]
    5474:	f043 0301 	orr.w	r3, r3, #1
    5478:	7353      	strb	r3, [r2, #13]
	return 1;
    547a:	2001      	movs	r0, #1
    547c:	4770      	bx	lr
#if defined(KINETISK)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
	if (pin == 18) {
		CORE_PIN18_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else if (pin == 20) {
		CORE_PIN20_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
    547e:	4b05      	ldr	r3, [pc, #20]	; (5494 <serial_set_cts+0x4c>)
    5480:	f240 3202 	movw	r2, #770	; 0x302
    5484:	601a      	str	r2, [r3, #0]
    5486:	e7f3      	b.n	5470 <serial_set_cts+0x28>
    5488:	40048034 	.word	0x40048034
    548c:	4006a000 	.word	0x4006a000
    5490:	4004a00c 	.word	0x4004a00c
    5494:	4004c014 	.word	0x4004c014

00005498 <serial_putchar>:

void serial_putchar(uint32_t c)
{
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    5498:	4b03      	ldr	r3, [pc, #12]	; (54a8 <serial_putchar+0x10>)
    549a:	681b      	ldr	r3, [r3, #0]
    549c:	055b      	lsls	r3, r3, #21
    549e:	d501      	bpl.n	54a4 <serial_putchar+0xc>
    54a0:	f7ff bd9a 	b.w	4fd8 <serial_putchar.part.0>
    54a4:	4770      	bx	lr
    54a6:	bf00      	nop
    54a8:	40048034 	.word	0x40048034

000054ac <serial_write>:
{
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    54ac:	4b3e      	ldr	r3, [pc, #248]	; (55a8 <serial_write+0xfc>)
    54ae:	681b      	ldr	r3, [r3, #0]
    54b0:	055a      	lsls	r2, r3, #21
    54b2:	d575      	bpl.n	55a0 <serial_write+0xf4>
	UART0_C2 = C2_TX_ACTIVE;
}

#ifdef HAS_KINETISK_UART0_FIFO
void serial_write(const void *buf, unsigned int count)
{
    54b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
    54b8:	4b3c      	ldr	r3, [pc, #240]	; (55ac <serial_write+0x100>)
    54ba:	681b      	ldr	r3, [r3, #0]
	UART0_C2 = C2_TX_ACTIVE;
}

#ifdef HAS_KINETISK_UART0_FIFO
void serial_write(const void *buf, unsigned int count)
{
    54bc:	b083      	sub	sp, #12
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
    54be:	b10b      	cbz	r3, 54c4 <serial_write+0x18>
    54c0:	2201      	movs	r2, #1
    54c2:	701a      	strb	r2, [r3, #0]

#ifdef HAS_KINETISK_UART0_FIFO
void serial_write(const void *buf, unsigned int count)
{
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
    54c4:	1843      	adds	r3, r0, r1
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    54c6:	4298      	cmp	r0, r3

#ifdef HAS_KINETISK_UART0_FIFO
void serial_write(const void *buf, unsigned int count)
{
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
    54c8:	9301      	str	r3, [sp, #4]
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    54ca:	d263      	bcs.n	5594 <serial_write+0xe8>
    54cc:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 55c0 <serial_write+0x114>
    54d0:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 55c4 <serial_write+0x118>
    54d4:	4c36      	ldr	r4, [pc, #216]	; (55b0 <serial_write+0x104>)
			} while (tx_buffer_tail == head);
		}
		if (head < SERIAL1_TX_BUFFER_SIZE) {
			tx_buffer[head] = *p++;
		} else {
			tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = *p++;
    54d6:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 55c8 <serial_write+0x11c>
	if (transmit_pin) transmit_assert();
	while (p < end) {
		head = tx_buffer_head;
		if (++head >= tx_buffer_total_size_) head = 0;
		if (tx_buffer_tail == head) {
			UART0_C2 = C2_TX_ACTIVE;
    54da:	4f36      	ldr	r7, [pc, #216]	; (55b4 <serial_write+0x108>)
    54dc:	1c45      	adds	r5, r0, #1
    54de:	e018      	b.n	5512 <serial_write+0x66>
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
		head = tx_buffer_head;
		if (++head >= tx_buffer_total_size_) head = 0;
		if (tx_buffer_tail == head) {
    54e0:	7822      	ldrb	r2, [r4, #0]
    54e2:	4592      	cmp	sl, r2
    54e4:	fa5f f68a 	uxtb.w	r6, sl
    54e8:	d029      	beq.n	553e <serial_write+0x92>
				} else if (priority >= 256) {
					yield();
				}
			} while (tx_buffer_tail == head);
		}
		if (head < SERIAL1_TX_BUFFER_SIZE) {
    54ea:	f1ba 0f3f 	cmp.w	sl, #63	; 0x3f
    54ee:	d91e      	bls.n	552e <serial_write+0x82>
			tx_buffer[head] = *p++;
		} else {
			tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = *p++;
    54f0:	f8db 2000 	ldr.w	r2, [fp]
    54f4:	f815 1c01 	ldrb.w	r1, [r5, #-1]
    54f8:	f1aa 0340 	sub.w	r3, sl, #64	; 0x40
    54fc:	54d1      	strb	r1, [r2, r3]
    54fe:	462a      	mov	r2, r5
		}
		transmitting = 1;
    5500:	492d      	ldr	r1, [pc, #180]	; (55b8 <serial_write+0x10c>)
    5502:	2301      	movs	r3, #1
    5504:	700b      	strb	r3, [r1, #0]
    5506:	441d      	add	r5, r3
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    5508:	9b01      	ldr	r3, [sp, #4]
			tx_buffer[head] = *p++;
		} else {
			tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = *p++;
		}
		transmitting = 1;
		tx_buffer_head = head;
    550a:	f888 6000 	strb.w	r6, [r8]
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    550e:	429a      	cmp	r2, r3
    5510:	d240      	bcs.n	5594 <serial_write+0xe8>
		head = tx_buffer_head;
    5512:	f898 3000 	ldrb.w	r3, [r8]
		if (++head >= tx_buffer_total_size_) head = 0;
    5516:	f8d9 2000 	ldr.w	r2, [r9]
    551a:	f103 0a01 	add.w	sl, r3, #1
    551e:	4592      	cmp	sl, r2
    5520:	d3de      	bcc.n	54e0 <serial_write+0x34>
		if (tx_buffer_tail == head) {
    5522:	7823      	ldrb	r3, [r4, #0]
    5524:	f003 06ff 	and.w	r6, r3, #255	; 0xff
    5528:	b143      	cbz	r3, 553c <serial_write+0x90>
    552a:	2600      	movs	r6, #0

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
		head = tx_buffer_head;
		if (++head >= tx_buffer_total_size_) head = 0;
    552c:	46b2      	mov	sl, r6
					yield();
				}
			} while (tx_buffer_tail == head);
		}
		if (head < SERIAL1_TX_BUFFER_SIZE) {
			tx_buffer[head] = *p++;
    552e:	4b23      	ldr	r3, [pc, #140]	; (55bc <serial_write+0x110>)
    5530:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    5534:	f803 200a 	strb.w	r2, [r3, sl]
    5538:	462a      	mov	r2, r5
    553a:	e7e1      	b.n	5500 <serial_write+0x54>

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
		head = tx_buffer_head;
		if (++head >= tx_buffer_total_size_) head = 0;
    553c:	46b2      	mov	sl, r6
		if (tx_buffer_tail == head) {
			UART0_C2 = C2_TX_ACTIVE;
    553e:	22bc      	movs	r2, #188	; 0xbc
    5540:	70fa      	strb	r2, [r7, #3]
    5542:	e005      	b.n	5550 <serial_write+0xa4>
			do {
				int priority = nvic_execution_priority();
				if (priority <= IRQ_PRIORITY) {
					if ((UART0_S1 & UART_S1_TDRE)) {
    5544:	793a      	ldrb	r2, [r7, #4]
    5546:	0613      	lsls	r3, r2, #24
    5548:	d40b      	bmi.n	5562 <serial_write+0xb6>
						tx_buffer_tail = tail;
					}
				} else if (priority >= 256) {
					yield();
				}
			} while (tx_buffer_tail == head);
    554a:	7822      	ldrb	r2, [r4, #0]
    554c:	4552      	cmp	r2, sl
    554e:	d1cc      	bne.n	54ea <serial_write+0x3e>
		head = tx_buffer_head;
		if (++head >= tx_buffer_total_size_) head = 0;
		if (tx_buffer_tail == head) {
			UART0_C2 = C2_TX_ACTIVE;
			do {
				int priority = nvic_execution_priority();
    5550:	f7ff fa38 	bl	49c4 <nvic_execution_priority>
				if (priority <= IRQ_PRIORITY) {
    5554:	2840      	cmp	r0, #64	; 0x40
    5556:	ddf5      	ble.n	5544 <serial_write+0x98>
						}
						if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
						UART0_D = n;
						tx_buffer_tail = tail;
					}
				} else if (priority >= 256) {
    5558:	28ff      	cmp	r0, #255	; 0xff
    555a:	ddf6      	ble.n	554a <serial_write+0x9e>
					yield();
    555c:	f001 fc72 	bl	6e44 <yield>
    5560:	e7f3      	b.n	554a <serial_write+0x9e>
			UART0_C2 = C2_TX_ACTIVE;
			do {
				int priority = nvic_execution_priority();
				if (priority <= IRQ_PRIORITY) {
					if ((UART0_S1 & UART_S1_TDRE)) {
						uint32_t tail = tx_buffer_tail;
    5562:	7822      	ldrb	r2, [r4, #0]
						if (++tail >= tx_buffer_total_size_) tail = 0;
    5564:	f8d9 1000 	ldr.w	r1, [r9]
			UART0_C2 = C2_TX_ACTIVE;
			do {
				int priority = nvic_execution_priority();
				if (priority <= IRQ_PRIORITY) {
					if ((UART0_S1 & UART_S1_TDRE)) {
						uint32_t tail = tx_buffer_tail;
    5568:	b2d2      	uxtb	r2, r2
						if (++tail >= tx_buffer_total_size_) tail = 0;
    556a:	1c50      	adds	r0, r2, #1
    556c:	4288      	cmp	r0, r1
    556e:	d20b      	bcs.n	5588 <serial_write+0xdc>
						if (tail < SERIAL1_TX_BUFFER_SIZE) {
    5570:	283f      	cmp	r0, #63	; 0x3f
    5572:	d916      	bls.n	55a2 <serial_write+0xf6>
							n = tx_buffer[tail];
						} else {
							n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
    5574:	f8db 1000 	ldr.w	r1, [fp]
    5578:	3a3f      	subs	r2, #63	; 0x3f
    557a:	5c8a      	ldrb	r2, [r1, r2]
    557c:	b2c1      	uxtb	r1, r0
    557e:	b2d2      	uxtb	r2, r2
						}
						if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
						UART0_D = n;
    5580:	b2d2      	uxtb	r2, r2
    5582:	71fa      	strb	r2, [r7, #7]
						tx_buffer_tail = tail;
    5584:	7021      	strb	r1, [r4, #0]
    5586:	e7e0      	b.n	554a <serial_write+0x9e>
    5588:	2100      	movs	r1, #0
			do {
				int priority = nvic_execution_priority();
				if (priority <= IRQ_PRIORITY) {
					if ((UART0_S1 & UART_S1_TDRE)) {
						uint32_t tail = tx_buffer_tail;
						if (++tail >= tx_buffer_total_size_) tail = 0;
    558a:	4608      	mov	r0, r1
						if (tail < SERIAL1_TX_BUFFER_SIZE) {
							n = tx_buffer[tail];
    558c:	4b0b      	ldr	r3, [pc, #44]	; (55bc <serial_write+0x110>)
    558e:	5c1a      	ldrb	r2, [r3, r0]
    5590:	b2d2      	uxtb	r2, r2
    5592:	e7f5      	b.n	5580 <serial_write+0xd4>
			tx_buffer_storage_[head - SERIAL1_TX_BUFFER_SIZE] = *p++;
		}
		transmitting = 1;
		tx_buffer_head = head;
	}
	UART0_C2 = C2_TX_ACTIVE;
    5594:	4b07      	ldr	r3, [pc, #28]	; (55b4 <serial_write+0x108>)
    5596:	22bc      	movs	r2, #188	; 0xbc
    5598:	70da      	strb	r2, [r3, #3]
}
    559a:	b003      	add	sp, #12
    559c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    55a0:	4770      	bx	lr
    55a2:	b2c1      	uxtb	r1, r0
    55a4:	e7f2      	b.n	558c <serial_write+0xe0>
    55a6:	bf00      	nop
    55a8:	40048034 	.word	0x40048034
    55ac:	1fffb4dc 	.word	0x1fffb4dc
    55b0:	1fffb4d5 	.word	0x1fffb4d5
    55b4:	4006a000 	.word	0x4006a000
    55b8:	1fffb4d4 	.word	0x1fffb4d4
    55bc:	1fffb44c 	.word	0x1fffb44c
    55c0:	1fffb4e0 	.word	0x1fffb4e0
    55c4:	1fff8740 	.word	0x1fff8740
    55c8:	1fffb490 	.word	0x1fffb490

000055cc <serial_flush>:
	while (count-- > 0) serial_putchar(*p++);
}
#endif

void serial_flush(void)
{
    55cc:	b510      	push	{r4, lr}
	while (transmitting) yield(); // wait
    55ce:	4c04      	ldr	r4, [pc, #16]	; (55e0 <serial_flush+0x14>)
    55d0:	7823      	ldrb	r3, [r4, #0]
    55d2:	b123      	cbz	r3, 55de <serial_flush+0x12>
    55d4:	f001 fc36 	bl	6e44 <yield>
    55d8:	7823      	ldrb	r3, [r4, #0]
    55da:	2b00      	cmp	r3, #0
    55dc:	d1fa      	bne.n	55d4 <serial_flush+0x8>
    55de:	bd10      	pop	{r4, pc}
    55e0:	1fffb4d4 	.word	0x1fffb4d4

000055e4 <serial_write_buffer_free>:

int serial_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
    55e4:	4b08      	ldr	r3, [pc, #32]	; (5608 <serial_write_buffer_free+0x24>)
	tail = tx_buffer_tail;
    55e6:	4a09      	ldr	r2, [pc, #36]	; (560c <serial_write_buffer_free+0x28>)

int serial_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
    55e8:	781b      	ldrb	r3, [r3, #0]
	tail = tx_buffer_tail;
    55ea:	7810      	ldrb	r0, [r2, #0]

int serial_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
    55ec:	b2db      	uxtb	r3, r3
	tail = tx_buffer_tail;
    55ee:	b2c0      	uxtb	r0, r0
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    55f0:	4283      	cmp	r3, r0
    55f2:	d202      	bcs.n	55fa <serial_write_buffer_free+0x16>
	return tail - head - 1;
    55f4:	3801      	subs	r0, #1
    55f6:	1ac0      	subs	r0, r0, r3
}
    55f8:	4770      	bx	lr
{
	uint32_t head, tail;

	head = tx_buffer_head;
	tail = tx_buffer_tail;
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    55fa:	4a05      	ldr	r2, [pc, #20]	; (5610 <serial_write_buffer_free+0x2c>)
    55fc:	6812      	ldr	r2, [r2, #0]
    55fe:	3a01      	subs	r2, #1
    5600:	4410      	add	r0, r2
    5602:	1ac0      	subs	r0, r0, r3
    5604:	4770      	bx	lr
    5606:	bf00      	nop
    5608:	1fffb4e0 	.word	0x1fffb4e0
    560c:	1fffb4d5 	.word	0x1fffb4d5
    5610:	1fff8740 	.word	0x1fff8740

00005614 <serial_available>:

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    5614:	4a06      	ldr	r2, [pc, #24]	; (5630 <serial_available+0x1c>)
	tail = rx_buffer_tail;
    5616:	4b07      	ldr	r3, [pc, #28]	; (5634 <serial_available+0x20>)

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    5618:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    561a:	781b      	ldrb	r3, [r3, #0]

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    561c:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    561e:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    5620:	4298      	cmp	r0, r3
    5622:	d202      	bcs.n	562a <serial_available+0x16>
	return rx_buffer_total_size_ + head - tail;
    5624:	4a04      	ldr	r2, [pc, #16]	; (5638 <serial_available+0x24>)
    5626:	6812      	ldr	r2, [r2, #0]
    5628:	4410      	add	r0, r2
    562a:	1ac0      	subs	r0, r0, r3
}
    562c:	4770      	bx	lr
    562e:	bf00      	nop
    5630:	1fffb448 	.word	0x1fffb448
    5634:	1fffb449 	.word	0x1fffb449
    5638:	1fff8734 	.word	0x1fff8734

0000563c <serial_getchar>:

int serial_getchar(void)
{
    563c:	b470      	push	{r4, r5, r6}
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    563e:	4b18      	ldr	r3, [pc, #96]	; (56a0 <serial_getchar+0x64>)
	tail = rx_buffer_tail;
    5640:	4d18      	ldr	r5, [pc, #96]	; (56a4 <serial_getchar+0x68>)
int serial_getchar(void)
{
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    5642:	781b      	ldrb	r3, [r3, #0]
	tail = rx_buffer_tail;
    5644:	782a      	ldrb	r2, [r5, #0]
int serial_getchar(void)
{
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    5646:	b2d9      	uxtb	r1, r3
	tail = rx_buffer_tail;
    5648:	b2d2      	uxtb	r2, r2
	if (head == tail) return -1;
    564a:	4291      	cmp	r1, r2
    564c:	d022      	beq.n	5694 <serial_getchar+0x58>
	if (++tail >= rx_buffer_total_size_) tail = 0;
    564e:	4b16      	ldr	r3, [pc, #88]	; (56a8 <serial_getchar+0x6c>)
    5650:	681c      	ldr	r4, [r3, #0]
    5652:	1c53      	adds	r3, r2, #1
    5654:	42a3      	cmp	r3, r4
    5656:	d314      	bcc.n	5682 <serial_getchar+0x46>
    5658:	2200      	movs	r2, #0
    565a:	4613      	mov	r3, r2
	if (tail < SERIAL1_RX_BUFFER_SIZE) {
		c = rx_buffer[tail];
    565c:	4813      	ldr	r0, [pc, #76]	; (56ac <serial_getchar+0x70>)
    565e:	5cc0      	ldrb	r0, [r0, r3]
    5660:	b2c0      	uxtb	r0, r0
	} else {
		c = rx_buffer_storage_[tail-SERIAL1_RX_BUFFER_SIZE];
	}
	rx_buffer_tail = tail;
	if (rts_pin) {
    5662:	4e13      	ldr	r6, [pc, #76]	; (56b0 <serial_getchar+0x74>)
	if (tail < SERIAL1_RX_BUFFER_SIZE) {
		c = rx_buffer[tail];
	} else {
		c = rx_buffer_storage_[tail-SERIAL1_RX_BUFFER_SIZE];
	}
	rx_buffer_tail = tail;
    5664:	702a      	strb	r2, [r5, #0]
	if (rts_pin) {
    5666:	6832      	ldr	r2, [r6, #0]
    5668:	b14a      	cbz	r2, 567e <serial_getchar+0x42>
		int avail;
		if (head >= tail) avail = head - tail;
    566a:	4299      	cmp	r1, r3
		else avail = rx_buffer_total_size_ + head - tail;
    566c:	bf38      	it	cc
    566e:	1909      	addcc	r1, r1, r4
    5670:	1acb      	subs	r3, r1, r3
		if (avail <= rts_low_watermark_) rts_assert();
    5672:	4910      	ldr	r1, [pc, #64]	; (56b4 <serial_getchar+0x78>)
    5674:	6809      	ldr	r1, [r1, #0]
    5676:	428b      	cmp	r3, r1
    5678:	d801      	bhi.n	567e <serial_getchar+0x42>
    567a:	2300      	movs	r3, #0
    567c:	7013      	strb	r3, [r2, #0]
	}
	return c;
}
    567e:	bc70      	pop	{r4, r5, r6}
    5680:	4770      	bx	lr

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= rx_buffer_total_size_) tail = 0;
	if (tail < SERIAL1_RX_BUFFER_SIZE) {
    5682:	2b3f      	cmp	r3, #63	; 0x3f
    5684:	d909      	bls.n	569a <serial_getchar+0x5e>
		c = rx_buffer[tail];
	} else {
		c = rx_buffer_storage_[tail-SERIAL1_RX_BUFFER_SIZE];
    5686:	480c      	ldr	r0, [pc, #48]	; (56b8 <serial_getchar+0x7c>)
    5688:	3a3f      	subs	r2, #63	; 0x3f
    568a:	6800      	ldr	r0, [r0, #0]
    568c:	5c80      	ldrb	r0, [r0, r2]
    568e:	b2da      	uxtb	r2, r3
    5690:	b2c0      	uxtb	r0, r0
    5692:	e7e6      	b.n	5662 <serial_getchar+0x26>
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
    5694:	f04f 30ff 	mov.w	r0, #4294967295
    5698:	e7f1      	b.n	567e <serial_getchar+0x42>
    569a:	b2da      	uxtb	r2, r3
    569c:	e7de      	b.n	565c <serial_getchar+0x20>
    569e:	bf00      	nop
    56a0:	1fffb448 	.word	0x1fffb448
    56a4:	1fffb449 	.word	0x1fffb449
    56a8:	1fff8734 	.word	0x1fff8734
    56ac:	1fffb494 	.word	0x1fffb494
    56b0:	1fffb444 	.word	0x1fffb444
    56b4:	1fff8738 	.word	0x1fff8738
    56b8:	1fffb4d8 	.word	0x1fffb4d8

000056bc <serial_peek>:

int serial_peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    56bc:	4a0d      	ldr	r2, [pc, #52]	; (56f4 <serial_peek+0x38>)
	tail = rx_buffer_tail;
    56be:	4b0e      	ldr	r3, [pc, #56]	; (56f8 <serial_peek+0x3c>)

int serial_peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    56c0:	7812      	ldrb	r2, [r2, #0]
	tail = rx_buffer_tail;
    56c2:	781b      	ldrb	r3, [r3, #0]
    56c4:	b2db      	uxtb	r3, r3
	if (head == tail) return -1;
    56c6:	429a      	cmp	r2, r3
    56c8:	d011      	beq.n	56ee <serial_peek+0x32>
	if (++tail >= rx_buffer_total_size_) tail = 0;
    56ca:	4a0c      	ldr	r2, [pc, #48]	; (56fc <serial_peek+0x40>)
    56cc:	6811      	ldr	r1, [r2, #0]
    56ce:	1c5a      	adds	r2, r3, #1
    56d0:	428a      	cmp	r2, r1
    56d2:	d304      	bcc.n	56de <serial_peek+0x22>
    56d4:	2200      	movs	r2, #0
	if (tail < SERIAL1_RX_BUFFER_SIZE) {
		return rx_buffer[tail];
    56d6:	4b0a      	ldr	r3, [pc, #40]	; (5700 <serial_peek+0x44>)
    56d8:	5c98      	ldrb	r0, [r3, r2]
    56da:	b2c0      	uxtb	r0, r0
    56dc:	4770      	bx	lr

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= rx_buffer_total_size_) tail = 0;
	if (tail < SERIAL1_RX_BUFFER_SIZE) {
    56de:	2a3f      	cmp	r2, #63	; 0x3f
    56e0:	d9f9      	bls.n	56d6 <serial_peek+0x1a>
		return rx_buffer[tail];
	}
	return rx_buffer_storage_[tail-SERIAL1_RX_BUFFER_SIZE];
    56e2:	4a08      	ldr	r2, [pc, #32]	; (5704 <serial_peek+0x48>)
    56e4:	3b3f      	subs	r3, #63	; 0x3f
    56e6:	6812      	ldr	r2, [r2, #0]
    56e8:	5cd0      	ldrb	r0, [r2, r3]
    56ea:	b2c0      	uxtb	r0, r0
    56ec:	4770      	bx	lr
{
	uint32_t head, tail;

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
    56ee:	f04f 30ff 	mov.w	r0, #4294967295
	if (++tail >= rx_buffer_total_size_) tail = 0;
	if (tail < SERIAL1_RX_BUFFER_SIZE) {
		return rx_buffer[tail];
	}
	return rx_buffer_storage_[tail-SERIAL1_RX_BUFFER_SIZE];
}
    56f2:	4770      	bx	lr
    56f4:	1fffb448 	.word	0x1fffb448
    56f8:	1fffb449 	.word	0x1fffb449
    56fc:	1fff8734 	.word	0x1fff8734
    5700:	1fffb494 	.word	0x1fffb494
    5704:	1fffb4d8 	.word	0x1fffb4d8

00005708 <serial_clear>:

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    5708:	4b0d      	ldr	r3, [pc, #52]	; (5740 <serial_clear+0x38>)
    570a:	681b      	ldr	r3, [r3, #0]
    570c:	055b      	lsls	r3, r3, #21
    570e:	d516      	bpl.n	573e <serial_clear+0x36>
	}
	return rx_buffer_storage_[tail-SERIAL1_RX_BUFFER_SIZE];
}

void serial_clear(void)
{
    5710:	b430      	push	{r4, r5}
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    5712:	4b0c      	ldr	r3, [pc, #48]	; (5744 <serial_clear+0x3c>)
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    5714:	4c0c      	ldr	r4, [pc, #48]	; (5748 <serial_clear+0x40>)

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    5716:	78da      	ldrb	r2, [r3, #3]
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
	if (rts_pin) rts_assert();
    5718:	480c      	ldr	r0, [pc, #48]	; (574c <serial_clear+0x44>)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    571a:	490d      	ldr	r1, [pc, #52]	; (5750 <serial_clear+0x48>)

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    571c:	f002 02cb 	and.w	r2, r2, #203	; 0xcb
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
    5720:	2540      	movs	r5, #64	; 0x40

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    5722:	70da      	strb	r2, [r3, #3]
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
    5724:	745d      	strb	r5, [r3, #17]
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    5726:	78da      	ldrb	r2, [r3, #3]
    5728:	f042 0234 	orr.w	r2, r2, #52	; 0x34
    572c:	70da      	strb	r2, [r3, #3]
#endif
	rx_buffer_head = rx_buffer_tail;
    572e:	7823      	ldrb	r3, [r4, #0]
	if (rts_pin) rts_assert();
    5730:	6802      	ldr	r2, [r0, #0]
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    5732:	b2db      	uxtb	r3, r3
    5734:	700b      	strb	r3, [r1, #0]
	if (rts_pin) rts_assert();
    5736:	b10a      	cbz	r2, 573c <serial_clear+0x34>
    5738:	2300      	movs	r3, #0
    573a:	7013      	strb	r3, [r2, #0]
}
    573c:	bc30      	pop	{r4, r5}
    573e:	4770      	bx	lr
    5740:	40048034 	.word	0x40048034
    5744:	4006a000 	.word	0x4006a000
    5748:	1fffb449 	.word	0x1fffb449
    574c:	1fffb444 	.word	0x1fffb444
    5750:	1fffb448 	.word	0x1fffb448

00005754 <uart0_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart0_status_isr(void)
{
    5754:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t c;
#ifdef HAS_KINETISK_UART0_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART0_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    5758:	4a50      	ldr	r2, [pc, #320]	; (589c <uart0_status_isr+0x148>)
    575a:	7913      	ldrb	r3, [r2, #4]
    575c:	f013 0f30 	tst.w	r3, #48	; 0x30
    5760:	d044      	beq.n	57ec <uart0_status_isr+0x98>
		__disable_irq();
    5762:	b672      	cpsid	i
		avail = UART0_RCFIFO;
    5764:	7d93      	ldrb	r3, [r2, #22]
		if (avail == 0) {
    5766:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    576a:	2b00      	cmp	r3, #0
    576c:	d057      	beq.n	581e <uart0_status_isr+0xca>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    576e:	b662      	cpsie	i
			head = rx_buffer_head;
    5770:	f8df 8158 	ldr.w	r8, [pc, #344]	; 58cc <uart0_status_isr+0x178>
			tail = rx_buffer_tail;
    5774:	4b4a      	ldr	r3, [pc, #296]	; (58a0 <uart0_status_isr+0x14c>)
    5776:	4d4b      	ldr	r5, [pc, #300]	; (58a4 <uart0_status_isr+0x150>)
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    5778:	f898 0000 	ldrb.w	r0, [r8]
				if (newhead != tail) {
					head = newhead;
					if (newhead < SERIAL1_RX_BUFFER_SIZE) {
						rx_buffer[head] = n;
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
    577c:	4c4a      	ldr	r4, [pc, #296]	; (58a8 <uart0_status_isr+0x154>)
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
			tail = rx_buffer_tail;
    577e:	781b      	ldrb	r3, [r3, #0]
    5780:	682f      	ldr	r7, [r5, #0]
				if (newhead != tail) {
					head = newhead;
					if (newhead < SERIAL1_RX_BUFFER_SIZE) {
						rx_buffer[head] = n;
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
    5782:	f8d4 c000 	ldr.w	ip, [r4]
				newhead = head + 1;
				if (newhead >= rx_buffer_total_size_) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					if (newhead < SERIAL1_RX_BUFFER_SIZE) {
						rx_buffer[head] = n;
    5786:	f8df e148 	ldr.w	lr, [pc, #328]	; 58d0 <uart0_status_isr+0x17c>
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    578a:	4615      	mov	r5, r2
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    578c:	b2c0      	uxtb	r0, r0
			tail = rx_buffer_tail;
    578e:	b2de      	uxtb	r6, r3
    5790:	e00c      	b.n	57ac <uart0_status_isr+0x58>
				} else {
					n = UART0_D;
				}
				newhead = head + 1;
				if (newhead >= rx_buffer_total_size_) newhead = 0;
				if (newhead != tail) {
    5792:	4296      	cmp	r6, r2
					head = newhead;
					if (newhead < SERIAL1_RX_BUFFER_SIZE) {
						rx_buffer[head] = n;
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
    5794:	f1a0 043f 	sub.w	r4, r0, #63	; 0x3f
				} else {
					n = UART0_D;
				}
				newhead = head + 1;
				if (newhead >= rx_buffer_total_size_) newhead = 0;
				if (newhead != tail) {
    5798:	d004      	beq.n	57a4 <uart0_status_isr+0x50>
					head = newhead;
					if (newhead < SERIAL1_RX_BUFFER_SIZE) {
    579a:	2a3f      	cmp	r2, #63	; 0x3f
    579c:	d97c      	bls.n	5898 <uart0_status_isr+0x144>
						rx_buffer[head] = n;
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
    579e:	f80c 3004 	strb.w	r3, [ip, r4]
    57a2:	4610      	mov	r0, r2
					}
				}
			} while (--avail > 0);
    57a4:	1e4a      	subs	r2, r1, #1
    57a6:	f012 01ff 	ands.w	r1, r2, #255	; 0xff
    57aa:	d00d      	beq.n	57c8 <uart0_status_isr+0x74>
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    57ac:	79eb      	ldrb	r3, [r5, #7]
				}
				newhead = head + 1;
    57ae:	1c42      	adds	r2, r0, #1
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    57b0:	42ba      	cmp	r2, r7
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    57b2:	b2db      	uxtb	r3, r3
				}
				newhead = head + 1;
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    57b4:	d3ed      	bcc.n	5792 <uart0_status_isr+0x3e>
				if (newhead != tail) {
    57b6:	2e00      	cmp	r6, #0
    57b8:	d0f4      	beq.n	57a4 <uart0_status_isr+0x50>
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
				}
				newhead = head + 1;
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    57ba:	2000      	movs	r0, #0
						rx_buffer[head] = n;
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
					}
				}
			} while (--avail > 0);
    57bc:	1e4a      	subs	r2, r1, #1
    57be:	f012 01ff 	ands.w	r1, r2, #255	; 0xff
				newhead = head + 1;
				if (newhead >= rx_buffer_total_size_) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					if (newhead < SERIAL1_RX_BUFFER_SIZE) {
						rx_buffer[head] = n;
    57c2:	f80e 3000 	strb.w	r3, [lr, r0]
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
					}
				}
			} while (--avail > 0);
    57c6:	d1f1      	bne.n	57ac <uart0_status_isr+0x58>
			rx_buffer_head = head;
			if (rts_pin) {
    57c8:	4b38      	ldr	r3, [pc, #224]	; (58ac <uart0_status_isr+0x158>)
    57ca:	681a      	ldr	r2, [r3, #0]
					} else {
						rx_buffer_storage_[head-SERIAL1_RX_BUFFER_SIZE] = n;
					}
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    57cc:	b2c3      	uxtb	r3, r0
    57ce:	f888 3000 	strb.w	r3, [r8]
			if (rts_pin) {
    57d2:	b15a      	cbz	r2, 57ec <uart0_status_isr+0x98>
				int avail;
				if (head >= tail) avail = head - tail;
				else avail = rx_buffer_total_size_ + head - tail;
				if (avail >= rts_high_watermark_) rts_deassert();
    57d4:	4936      	ldr	r1, [pc, #216]	; (58b0 <uart0_status_isr+0x15c>)
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    57d6:	42b0      	cmp	r0, r6
				else avail = rx_buffer_total_size_ + head - tail;
    57d8:	bf38      	it	cc
    57da:	1bbb      	subcc	r3, r7, r6
				if (avail >= rts_high_watermark_) rts_deassert();
    57dc:	6809      	ldr	r1, [r1, #0]
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    57de:	bf2c      	ite	cs
    57e0:	1b83      	subcs	r3, r0, r6
				else avail = rx_buffer_total_size_ + head - tail;
    57e2:	181b      	addcc	r3, r3, r0
				if (avail >= rts_high_watermark_) rts_deassert();
    57e4:	428b      	cmp	r3, r1
    57e6:	bf24      	itt	cs
    57e8:	2301      	movcs	r3, #1
    57ea:	7013      	strbcs	r3, [r2, #0]
			}
		}
	}
	c = UART0_C2;
    57ec:	482b      	ldr	r0, [pc, #172]	; (589c <uart0_status_isr+0x148>)
    57ee:	78c1      	ldrb	r1, [r0, #3]
    57f0:	b2c9      	uxtb	r1, r1
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    57f2:	060d      	lsls	r5, r1, #24
    57f4:	d418      	bmi.n	5828 <uart0_status_isr+0xd4>
			UART0_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
    57f6:	064a      	lsls	r2, r1, #25
    57f8:	d50f      	bpl.n	581a <uart0_status_isr+0xc6>
    57fa:	4b28      	ldr	r3, [pc, #160]	; (589c <uart0_status_isr+0x148>)
    57fc:	791b      	ldrb	r3, [r3, #4]
    57fe:	065b      	lsls	r3, r3, #25
    5800:	d50b      	bpl.n	581a <uart0_status_isr+0xc6>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    5802:	4b2c      	ldr	r3, [pc, #176]	; (58b4 <uart0_status_isr+0x160>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    5804:	492c      	ldr	r1, [pc, #176]	; (58b8 <uart0_status_isr+0x164>)
		if (transmit_pin) transmit_deassert();
    5806:	681b      	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    5808:	2200      	movs	r2, #0
    580a:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    580c:	b103      	cbz	r3, 5810 <uart0_status_isr+0xbc>
    580e:	701a      	strb	r2, [r3, #0]
			reg &= ~UART_C3_TXDIR;
			UART0_C3 = reg;
			__enable_irq();
		}
		#endif
		UART0_C2 = C2_TX_INACTIVE;
    5810:	4b22      	ldr	r3, [pc, #136]	; (589c <uart0_status_isr+0x148>)
    5812:	223c      	movs	r2, #60	; 0x3c
    5814:	70da      	strb	r2, [r3, #3]
	}
}
    5816:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    581a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    581e:	2340      	movs	r3, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART0_D;
    5820:	79d1      	ldrb	r1, [r2, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    5822:	7453      	strb	r3, [r2, #17]
			__enable_irq();
    5824:	b662      	cpsie	i
    5826:	e7e1      	b.n	57ec <uart0_status_isr+0x98>
				if (avail >= rts_high_watermark_) rts_deassert();
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    5828:	7903      	ldrb	r3, [r0, #4]
    582a:	061c      	lsls	r4, r3, #24
    582c:	d5e3      	bpl.n	57f6 <uart0_status_isr+0xa2>
		head = tx_buffer_head;
    582e:	4b23      	ldr	r3, [pc, #140]	; (58bc <uart0_status_isr+0x168>)
		tail = tx_buffer_tail;
    5830:	f8df e0a0 	ldr.w	lr, [pc, #160]	; 58d4 <uart0_status_isr+0x180>
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    5834:	781d      	ldrb	r5, [r3, #0]
		tail = tx_buffer_tail;
    5836:	f89e 3000 	ldrb.w	r3, [lr]
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    583a:	b2ed      	uxtb	r5, r5
		tail = tx_buffer_tail;
    583c:	b2db      	uxtb	r3, r3
		do {
			if (tail == head) break;
    583e:	429d      	cmp	r5, r3
    5840:	d01e      	beq.n	5880 <uart0_status_isr+0x12c>
    5842:	4c1f      	ldr	r4, [pc, #124]	; (58c0 <uart0_status_isr+0x16c>)
			if (++tail >= tx_buffer_total_size_) tail = 0;
			avail = UART0_S1;
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
				n = tx_buffer[tail];
			} else {
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
    5844:	4a1f      	ldr	r2, [pc, #124]	; (58c4 <uart0_status_isr+0x170>)
    5846:	6826      	ldr	r6, [r4, #0]
    5848:	f8d2 c000 	ldr.w	ip, [r2]
		do {
			if (tail == head) break;
			if (++tail >= tx_buffer_total_size_) tail = 0;
			avail = UART0_S1;
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
				n = tx_buffer[tail];
    584c:	4f1e      	ldr	r7, [pc, #120]	; (58c8 <uart0_status_isr+0x174>)
    584e:	e00d      	b.n	586c <uart0_status_isr+0x118>
		tail = tx_buffer_tail;
		do {
			if (tail == head) break;
			if (++tail >= tx_buffer_total_size_) tail = 0;
			avail = UART0_S1;
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
    5850:	2c3f      	cmp	r4, #63	; 0x3f
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		do {
			if (tail == head) break;
			if (++tail >= tx_buffer_total_size_) tail = 0;
			avail = UART0_S1;
    5852:	7902      	ldrb	r2, [r0, #4]
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
    5854:	d91e      	bls.n	5894 <uart0_status_isr+0x140>
				n = tx_buffer[tail];
			} else {
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
    5856:	f81c 2003 	ldrb.w	r2, [ip, r3]
    585a:	4623      	mov	r3, r4
    585c:	b2d2      	uxtb	r2, r2
			}
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
    585e:	b2d2      	uxtb	r2, r2
    5860:	71c2      	strb	r2, [r0, #7]
		} while (UART0_TCFIFO < 8);
    5862:	7d02      	ldrb	r2, [r0, #20]
    5864:	2a07      	cmp	r2, #7
    5866:	d80b      	bhi.n	5880 <uart0_status_isr+0x12c>
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		do {
			if (tail == head) break;
    5868:	429d      	cmp	r5, r3
    586a:	d009      	beq.n	5880 <uart0_status_isr+0x12c>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    586c:	1c5c      	adds	r4, r3, #1
    586e:	42a6      	cmp	r6, r4
			avail = UART0_S1;
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
				n = tx_buffer[tail];
			} else {
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
    5870:	f1a3 033f 	sub.w	r3, r3, #63	; 0x3f
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		do {
			if (tail == head) break;
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5874:	d8ec      	bhi.n	5850 <uart0_status_isr+0xfc>
			avail = UART0_S1;
    5876:	7903      	ldrb	r3, [r0, #4]
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		do {
			if (tail == head) break;
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5878:	2300      	movs	r3, #0
			avail = UART0_S1;
			if (tail < SERIAL1_TX_BUFFER_SIZE) {
				n = tx_buffer[tail];
    587a:	5cfa      	ldrb	r2, [r7, r3]
    587c:	b2d2      	uxtb	r2, r2
    587e:	e7ee      	b.n	585e <uart0_status_isr+0x10a>
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
			}
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
    5880:	b2db      	uxtb	r3, r3
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    5882:	4a06      	ldr	r2, [pc, #24]	; (589c <uart0_status_isr+0x148>)
				n = tx_buffer_storage_[tail-SERIAL1_TX_BUFFER_SIZE];
			}
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
    5884:	f88e 3000 	strb.w	r3, [lr]
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    5888:	7913      	ldrb	r3, [r2, #4]
    588a:	0618      	lsls	r0, r3, #24
    588c:	bf44      	itt	mi
    588e:	237c      	movmi	r3, #124	; 0x7c
    5890:	70d3      	strbmi	r3, [r2, #3]
    5892:	e7b0      	b.n	57f6 <uart0_status_isr+0xa2>
    5894:	4623      	mov	r3, r4
    5896:	e7f0      	b.n	587a <uart0_status_isr+0x126>
    5898:	4610      	mov	r0, r2
    589a:	e78f      	b.n	57bc <uart0_status_isr+0x68>
    589c:	4006a000 	.word	0x4006a000
    58a0:	1fffb449 	.word	0x1fffb449
    58a4:	1fff8734 	.word	0x1fff8734
    58a8:	1fffb4d8 	.word	0x1fffb4d8
    58ac:	1fffb444 	.word	0x1fffb444
    58b0:	1fff873c 	.word	0x1fff873c
    58b4:	1fffb4dc 	.word	0x1fffb4dc
    58b8:	1fffb4d4 	.word	0x1fffb4d4
    58bc:	1fffb4e0 	.word	0x1fffb4e0
    58c0:	1fff8740 	.word	0x1fff8740
    58c4:	1fffb490 	.word	0x1fffb490
    58c8:	1fffb44c 	.word	0x1fffb44c
    58cc:	1fffb448 	.word	0x1fffb448
    58d0:	1fffb494 	.word	0x1fffb494
    58d4:	1fffb4d5 	.word	0x1fffb4d5

000058d8 <serial_add_memory_for_read>:
	serial_phex(n);
}

void serial_add_memory_for_read(void *buffer, size_t length)
{
	rx_buffer_storage_ = (BUFTYPE*)buffer;
    58d8:	4b08      	ldr	r3, [pc, #32]	; (58fc <serial_add_memory_for_read+0x24>)
    58da:	6018      	str	r0, [r3, #0]
	if (buffer) {
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE + length;
    58dc:	4b08      	ldr	r3, [pc, #32]	; (5900 <serial_add_memory_for_read+0x28>)
}

void serial_add_memory_for_read(void *buffer, size_t length)
{
	rx_buffer_storage_ = (BUFTYPE*)buffer;
	if (buffer) {
    58de:	b150      	cbz	r0, 58f6 <serial_add_memory_for_read+0x1e>
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE + length;
    58e0:	f101 0240 	add.w	r2, r1, #64	; 0x40
    58e4:	601a      	str	r2, [r3, #0]
	} else {
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE;
	} 

	rts_low_watermark_ = RTS_LOW_WATERMARK + length;
    58e6:	4a07      	ldr	r2, [pc, #28]	; (5904 <serial_add_memory_for_read+0x2c>)
	rts_high_watermark_ = RTS_HIGH_WATERMARK + length;
    58e8:	4b07      	ldr	r3, [pc, #28]	; (5908 <serial_add_memory_for_read+0x30>)
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE + length;
	} else {
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE;
	} 

	rts_low_watermark_ = RTS_LOW_WATERMARK + length;
    58ea:	f101 001a 	add.w	r0, r1, #26
	rts_high_watermark_ = RTS_HIGH_WATERMARK + length;
    58ee:	3128      	adds	r1, #40	; 0x28
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE + length;
	} else {
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE;
	} 

	rts_low_watermark_ = RTS_LOW_WATERMARK + length;
    58f0:	6010      	str	r0, [r2, #0]
	rts_high_watermark_ = RTS_HIGH_WATERMARK + length;
    58f2:	6019      	str	r1, [r3, #0]
    58f4:	4770      	bx	lr
{
	rx_buffer_storage_ = (BUFTYPE*)buffer;
	if (buffer) {
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE + length;
	} else {
		rx_buffer_total_size_ = SERIAL1_RX_BUFFER_SIZE;
    58f6:	2240      	movs	r2, #64	; 0x40
    58f8:	601a      	str	r2, [r3, #0]
    58fa:	e7f4      	b.n	58e6 <serial_add_memory_for_read+0xe>
    58fc:	1fffb4d8 	.word	0x1fffb4d8
    5900:	1fff8734 	.word	0x1fff8734
    5904:	1fff8738 	.word	0x1fff8738
    5908:	1fff873c 	.word	0x1fff873c

0000590c <serial_add_memory_for_write>:
	rts_high_watermark_ = RTS_HIGH_WATERMARK + length;
}

void serial_add_memory_for_write(void *buffer, size_t length)
{
	tx_buffer_storage_ = (BUFTYPE*)buffer;
    590c:	4b04      	ldr	r3, [pc, #16]	; (5920 <serial_add_memory_for_write+0x14>)
    590e:	6018      	str	r0, [r3, #0]
	if (buffer) {
		tx_buffer_total_size_ = SERIAL1_TX_BUFFER_SIZE + length;
    5910:	4b04      	ldr	r3, [pc, #16]	; (5924 <serial_add_memory_for_write+0x18>)
}

void serial_add_memory_for_write(void *buffer, size_t length)
{
	tx_buffer_storage_ = (BUFTYPE*)buffer;
	if (buffer) {
    5912:	b110      	cbz	r0, 591a <serial_add_memory_for_write+0xe>
		tx_buffer_total_size_ = SERIAL1_TX_BUFFER_SIZE + length;
    5914:	3140      	adds	r1, #64	; 0x40
    5916:	6019      	str	r1, [r3, #0]
    5918:	4770      	bx	lr
	} else {
		tx_buffer_total_size_ = SERIAL1_TX_BUFFER_SIZE;
    591a:	2240      	movs	r2, #64	; 0x40
    591c:	601a      	str	r2, [r3, #0]
    591e:	4770      	bx	lr
    5920:	1fffb490 	.word	0x1fffb490
    5924:	1fff8740 	.word	0x1fff8740

00005928 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    5928:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    592a:	2b03      	cmp	r3, #3
    592c:	d814      	bhi.n	5958 <usb_rx+0x30>
	__disable_irq();
    592e:	b672      	cpsid	i
	ret = rx_first[endpoint];
    5930:	490a      	ldr	r1, [pc, #40]	; (595c <usb_rx+0x34>)
    5932:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    5936:	b168      	cbz	r0, 5954 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    5938:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    593a:	4c09      	ldr	r4, [pc, #36]	; (5960 <usb_rx+0x38>)
    593c:	8805      	ldrh	r5, [r0, #0]
    593e:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    5942:	6846      	ldr	r6, [r0, #4]
    5944:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    5948:	1b52      	subs	r2, r2, r5
    594a:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    594e:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    5950:	bc70      	pop	{r4, r5, r6}
    5952:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    5954:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    5956:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    5958:	2000      	movs	r0, #0
    595a:	4770      	bx	lr
    595c:	1fffb53c 	.word	0x1fffb53c
    5960:	1fffb640 	.word	0x1fffb640

00005964 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    5964:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    5966:	2803      	cmp	r0, #3
    5968:	d80b      	bhi.n	5982 <usb_tx_packet_count+0x1e>
	__disable_irq();
    596a:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    596c:	4b07      	ldr	r3, [pc, #28]	; (598c <usb_tx_packet_count+0x28>)
    596e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5972:	b143      	cbz	r3, 5986 <usb_tx_packet_count+0x22>
    5974:	2000      	movs	r0, #0
    5976:	685b      	ldr	r3, [r3, #4]
    5978:	3001      	adds	r0, #1
    597a:	2b00      	cmp	r3, #0
    597c:	d1fb      	bne.n	5976 <usb_tx_packet_count+0x12>
	__enable_irq();
    597e:	b662      	cpsie	i
	return count;
    5980:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    5982:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    5984:	4770      	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    5986:	4618      	mov	r0, r3
    5988:	e7f9      	b.n	597e <usb_tx_packet_count+0x1a>
    598a:	bf00      	nop
    598c:	1fffb590 	.word	0x1fffb590

00005990 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    5990:	b4f0      	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    5992:	b672      	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    5994:	491a      	ldr	r1, [pc, #104]	; (5a00 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    5996:	4e1b      	ldr	r6, [pc, #108]	; (5a04 <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    5998:	2301      	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    599a:	f811 4b01 	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    599e:	4f19      	ldr	r7, [pc, #100]	; (5a04 <usb_rx_memory+0x74>)
    59a0:	009a      	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    59a2:	0724      	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    59a4:	f042 0501 	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    59a8:	d505      	bpl.n	59b6 <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    59aa:	f856 4032 	ldr.w	r4, [r6, r2, lsl #3]
    59ae:	b164      	cbz	r4, 59ca <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    59b0:	f856 2035 	ldr.w	r2, [r6, r5, lsl #3]
    59b4:	b1ba      	cbz	r2, 59e6 <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    59b6:	3301      	adds	r3, #1
    59b8:	2b05      	cmp	r3, #5
    59ba:	d1ee      	bne.n	599a <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    59bc:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    59be:	4b12      	ldr	r3, [pc, #72]	; (5a08 <usb_rx_memory+0x78>)
    59c0:	2200      	movs	r2, #0
    59c2:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    59c4:	bcf0      	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    59c6:	f000 bd1b 	b.w	6400 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    59ca:	4c0f      	ldr	r4, [pc, #60]	; (5a08 <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    59cc:	4d0f      	ldr	r5, [pc, #60]	; (5a0c <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    59ce:	7821      	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    59d0:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    59d4:	3008      	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    59d6:	3901      	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    59d8:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    59da:	7021      	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    59dc:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    59e0:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    59e2:	bcf0      	pop	{r4, r5, r6, r7}
    59e4:	4770      	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    59e6:	4a08      	ldr	r2, [pc, #32]	; (5a08 <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    59e8:	4909      	ldr	r1, [pc, #36]	; (5a10 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    59ea:	7813      	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    59ec:	eb07 04c5 	add.w	r4, r7, r5, lsl #3
    59f0:	3008      	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    59f2:	3b01      	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    59f4:	6060      	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    59f6:	7013      	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    59f8:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    59fc:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    59fe:	e7f0      	b.n	59e2 <usb_rx_memory+0x52>
    5a00:	000096c4 	.word	0x000096c4
    5a04:	1fff8000 	.word	0x1fff8000
    5a08:	1fffb5b9 	.word	0x1fffb5b9
    5a0c:	00400088 	.word	0x00400088
    5a10:	004000c8 	.word	0x004000c8

00005a14 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    5a14:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    5a16:	2b03      	cmp	r3, #3
    5a18:	d81d      	bhi.n	5a56 <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    5a1a:	4a1b      	ldr	r2, [pc, #108]	; (5a88 <usb_tx+0x74>)
    5a1c:	0140      	lsls	r0, r0, #5
    5a1e:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    5a22:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    5a24:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    5a26:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    5a28:	4c18      	ldr	r4, [pc, #96]	; (5a8c <usb_tx+0x78>)
    5a2a:	5ce2      	ldrb	r2, [r4, r3]
    5a2c:	2a03      	cmp	r2, #3
    5a2e:	d81b      	bhi.n	5a68 <usb_tx+0x54>
    5a30:	e8df f002 	tbb	[pc, r2]
    5a34:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    5a38:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5a3a:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    5a3c:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5a3e:	f010 0f08 	tst.w	r0, #8
    5a42:	bf14      	ite	ne
    5a44:	23c8      	movne	r3, #200	; 0xc8
    5a46:	2388      	moveq	r3, #136	; 0x88
    5a48:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    5a4c:	3108      	adds	r1, #8
    5a4e:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5a50:	6003      	str	r3, [r0, #0]
	__enable_irq();
    5a52:	b662      	cpsie	i
}
    5a54:	bc30      	pop	{r4, r5}
    5a56:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    5a58:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    5a5a:	2202      	movs	r2, #2
		break;
    5a5c:	e7ed      	b.n	5a3a <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    5a5e:	2205      	movs	r2, #5
    5a60:	e7eb      	b.n	5a3a <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    5a62:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    5a64:	2204      	movs	r2, #4
		break;
    5a66:	e7e8      	b.n	5a3a <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    5a68:	4a09      	ldr	r2, [pc, #36]	; (5a90 <usb_tx+0x7c>)
    5a6a:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    5a6e:	b138      	cbz	r0, 5a80 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    5a70:	4a08      	ldr	r2, [pc, #32]	; (5a94 <usb_tx+0x80>)
    5a72:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    5a76:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    5a78:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    5a7c:	b662      	cpsie	i
		return;
    5a7e:	e7e9      	b.n	5a54 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    5a80:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    5a84:	4a03      	ldr	r2, [pc, #12]	; (5a94 <usb_tx+0x80>)
    5a86:	e7f7      	b.n	5a78 <usb_tx+0x64>
    5a88:	1fff8000 	.word	0x1fff8000
    5a8c:	1fffb5c8 	.word	0x1fffb5c8
    5a90:	1fffb590 	.word	0x1fffb590
    5a94:	1fffb5a0 	.word	0x1fffb5a0

00005a98 <usb_isr>:
}



void usb_isr(void)
{
    5a98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    5a9c:	f8df b314 	ldr.w	fp, [pc, #788]	; 5db4 <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    5aa0:	f8df a314 	ldr.w	sl, [pc, #788]	; 5db8 <usb_isr+0x320>
}



void usb_isr(void)
{
    5aa4:	b087      	sub	sp, #28
    5aa6:	e044      	b.n	5b32 <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    5aa8:	4fad      	ldr	r7, [pc, #692]	; (5d60 <usb_isr+0x2c8>)
    5aaa:	ea4f 0893 	mov.w	r8, r3, lsr #2
    5aae:	eb07 09c8 	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    5ab2:	3e01      	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    5ab4:	f8d9 2004 	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    5ab8:	f003 0308 	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    5abc:	b2f6      	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    5abe:	f1a2 0008 	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    5ac2:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    5ac6:	2b00      	cmp	r3, #0
    5ac8:	f040 8103 	bne.w	5cd2 <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    5acc:	f857 3038 	ldr.w	r3, [r7, r8, lsl #3]
    5ad0:	0c1b      	lsrs	r3, r3, #16
    5ad2:	b299      	uxth	r1, r3
    5ad4:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    5ad8:	2b00      	cmp	r3, #0
    5ada:	f000 80f1 	beq.w	5cc0 <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    5ade:	4ba1      	ldr	r3, [pc, #644]	; (5d64 <usb_isr+0x2cc>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    5ae0:	f822 4c06 	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    5ae4:	f842 4c04 	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    5ae8:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
    5aec:	2a00      	cmp	r2, #0
    5aee:	f000 816c 	beq.w	5dca <usb_isr+0x332>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    5af2:	4d9d      	ldr	r5, [pc, #628]	; (5d68 <usb_isr+0x2d0>)
    5af4:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
    5af8:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    5afa:	4c9c      	ldr	r4, [pc, #624]	; (5d6c <usb_isr+0x2d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    5afc:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    5b00:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
    5b04:	4419      	add	r1, r3
    5b06:	f824 1016 	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    5b0a:	f000 fc59 	bl	63c0 <usb_malloc>
					if (packet) {
    5b0e:	2800      	cmp	r0, #0
    5b10:	f000 8154 	beq.w	5dbc <usb_isr+0x324>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    5b14:	4a96      	ldr	r2, [pc, #600]	; (5d70 <usb_isr+0x2d8>)
    5b16:	4b97      	ldr	r3, [pc, #604]	; (5d74 <usb_isr+0x2dc>)
    5b18:	f019 0f08 	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    5b1c:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    5b20:	bf18      	it	ne
    5b22:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    5b24:	f8c9 0004 	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    5b28:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    5b2c:	2308      	movs	r3, #8
    5b2e:	f88b 3000 	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    5b32:	f89b 4000 	ldrb.w	r4, [fp]
    5b36:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    5b38:	0760      	lsls	r0, r4, #29
    5b3a:	d51b      	bpl.n	5b74 <usb_isr+0xdc>
		if (usb_configuration) {
    5b3c:	4b8e      	ldr	r3, [pc, #568]	; (5d78 <usb_isr+0x2e0>)
    5b3e:	781b      	ldrb	r3, [r3, #0]
    5b40:	b1ab      	cbz	r3, 5b6e <usb_isr+0xd6>
			t = usb_reboot_timer;
    5b42:	498e      	ldr	r1, [pc, #568]	; (5d7c <usb_isr+0x2e4>)
    5b44:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    5b46:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    5b4a:	b12a      	cbz	r2, 5b58 <usb_isr+0xc0>
				usb_reboot_timer = --t;
    5b4c:	3b01      	subs	r3, #1
    5b4e:	b2db      	uxtb	r3, r3
    5b50:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    5b52:	2b00      	cmp	r3, #0
    5b54:	f000 83b5 	beq.w	62c2 <usb_isr+0x82a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    5b58:	4989      	ldr	r1, [pc, #548]	; (5d80 <usb_isr+0x2e8>)
    5b5a:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    5b5c:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    5b60:	b12a      	cbz	r2, 5b6e <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    5b62:	3b01      	subs	r3, #1
    5b64:	b2db      	uxtb	r3, r3
    5b66:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    5b68:	2b00      	cmp	r3, #0
    5b6a:	f000 80f6 	beq.w	5d5a <usb_isr+0x2c2>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    5b6e:	2304      	movs	r3, #4
    5b70:	f88b 3000 	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    5b74:	f004 0308 	and.w	r3, r4, #8
    5b78:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    5b7c:	2b00      	cmp	r3, #0
    5b7e:	f000 80d5 	beq.w	5d2c <usb_isr+0x294>
		uint8_t endpoint;
		stat = USB0_STAT;
    5b82:	f89a 3000 	ldrb.w	r3, [sl]
    5b86:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    5b88:	091e      	lsrs	r6, r3, #4
    5b8a:	d18d      	bne.n	5aa8 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    5b8c:	089c      	lsrs	r4, r3, #2
    5b8e:	4f74      	ldr	r7, [pc, #464]	; (5d60 <usb_isr+0x2c8>)
	pid = BDT_PID(b->desc);
    5b90:	f857 2034 	ldr.w	r2, [r7, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    5b94:	eb07 01c4 	add.w	r1, r7, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    5b98:	f3c2 0283 	ubfx	r2, r2, #2, #4
    5b9c:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    5b9e:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    5ba0:	2a0c      	cmp	r2, #12
    5ba2:	d87e      	bhi.n	5ca2 <usb_isr+0x20a>
    5ba4:	e8df f002 	tbb	[pc, r2]
    5ba8:	7d7d8181 	.word	0x7d7d8181
    5bac:	7d7d7d7d 	.word	0x7d7d7d7d
    5bb0:	7d7d7d42 	.word	0x7d7d7d42
    5bb4:	07          	.byte	0x07
    5bb5:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    5bb6:	6808      	ldr	r0, [r1, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5bb8:	4b72      	ldr	r3, [pc, #456]	; (5d84 <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    5bba:	4d73      	ldr	r5, [pc, #460]	; (5d88 <usb_isr+0x2f0>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5bbc:	9301      	str	r3, [sp, #4]
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5bbe:	4b6c      	ldr	r3, [pc, #432]	; (5d70 <usb_isr+0x2d8>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    5bc0:	684a      	ldr	r2, [r1, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    5bc2:	4e72      	ldr	r6, [pc, #456]	; (5d8c <usb_isr+0x2f4>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5bc4:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5bc8:	b281      	uxth	r1, r0
    5bca:	f240 6481 	movw	r4, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5bce:	4b6d      	ldr	r3, [pc, #436]	; (5d84 <usb_isr+0x2ec>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    5bd0:	606a      	str	r2, [r5, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    5bd2:	6028      	str	r0, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5bd4:	2200      	movs	r2, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    5bd6:	2001      	movs	r0, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5bd8:	42a1      	cmp	r1, r4
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    5bda:	613a      	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5bdc:	601a      	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    5bde:	61ba      	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    5be0:	7030      	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5be2:	f200 80f6 	bhi.w	5dd2 <usb_isr+0x33a>
    5be6:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
    5bea:	f080 82e8 	bcs.w	61be <usb_isr+0x726>
    5bee:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    5bf2:	f000 82d3 	beq.w	619c <usb_isr+0x704>
    5bf6:	f200 81d8 	bhi.w	5faa <usb_isr+0x512>
    5bfa:	2980      	cmp	r1, #128	; 0x80
    5bfc:	f000 814d 	beq.w	5e9a <usb_isr+0x402>
    5c00:	2982      	cmp	r1, #130	; 0x82
    5c02:	f040 8292 	bne.w	612a <usb_isr+0x692>
    5c06:	88a9      	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5c08:	4b61      	ldr	r3, [pc, #388]	; (5d90 <usb_isr+0x2f8>)
    5c0a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    5c0e:	2904      	cmp	r1, #4
    5c10:	f200 828c 	bhi.w	612c <usb_isr+0x694>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    5c14:	4c5f      	ldr	r4, [pc, #380]	; (5d94 <usb_isr+0x2fc>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    5c16:	0089      	lsls	r1, r1, #2
    5c18:	440b      	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    5c1a:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    5c1c:	7062      	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    5c1e:	781a      	ldrb	r2, [r3, #0]
    5c20:	0793      	lsls	r3, r2, #30
    5c22:	f140 8338 	bpl.w	6296 <usb_isr+0x7fe>
    5c26:	7020      	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    5c28:	2002      	movs	r0, #2
    5c2a:	e13a      	b.n	5ea2 <usb_isr+0x40a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    5c2c:	4b55      	ldr	r3, [pc, #340]	; (5d84 <usb_isr+0x2ec>)
    5c2e:	9301      	str	r3, [sp, #4]
    5c30:	681a      	ldr	r2, [r3, #0]
		if (data) {
    5c32:	b362      	cbz	r2, 5c8e <usb_isr+0x1f6>
			size = ep0_tx_len;
    5c34:	4b58      	ldr	r3, [pc, #352]	; (5d98 <usb_isr+0x300>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5c36:	4959      	ldr	r1, [pc, #356]	; (5d9c <usb_isr+0x304>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5c38:	4e54      	ldr	r6, [pc, #336]	; (5d8c <usb_isr+0x2f4>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    5c3a:	8818      	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5c3c:	780c      	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5c3e:	f896 e000 	ldrb.w	lr, [r6]
    5c42:	2840      	cmp	r0, #64	; 0x40
    5c44:	4605      	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5c46:	f084 0c01 	eor.w	ip, r4, #1
    5c4a:	bf28      	it	cs
    5c4c:	2540      	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5c4e:	f044 0402 	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5c52:	f1be 0f00 	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5c56:	f881 c000 	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    5c5a:	eba0 0005 	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5c5e:	eb07 0cc4 	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5c62:	bf0c      	ite	eq
    5c64:	2188      	moveq	r1, #136	; 0x88
    5c66:	21c8      	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    5c68:	b280      	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    5c6a:	f08e 0e01 	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5c6e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5c72:	f8cc 2004 	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    5c76:	8018      	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    5c78:	f886 e000 	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    5c7c:	442a      	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5c7e:	f847 1034 	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    5c82:	b910      	cbnz	r0, 5c8a <usb_isr+0x1f2>
    5c84:	2d40      	cmp	r5, #64	; 0x40
    5c86:	bf18      	it	ne
    5c88:	2200      	movne	r2, #0
    5c8a:	9b01      	ldr	r3, [sp, #4]
    5c8c:	601a      	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    5c8e:	4b3e      	ldr	r3, [pc, #248]	; (5d88 <usb_isr+0x2f0>)
    5c90:	881a      	ldrh	r2, [r3, #0]
    5c92:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    5c96:	d104      	bne.n	5ca2 <usb_isr+0x20a>
			setup.bRequest = 0;
    5c98:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    5c9a:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    5c9c:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    5c9e:	4b40      	ldr	r3, [pc, #256]	; (5da0 <usb_isr+0x308>)
    5ca0:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5ca2:	4a40      	ldr	r2, [pc, #256]	; (5da4 <usb_isr+0x30c>)
    5ca4:	2301      	movs	r3, #1
    5ca6:	7013      	strb	r3, [r2, #0]
    5ca8:	e740      	b.n	5b2c <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    5caa:	4a37      	ldr	r2, [pc, #220]	; (5d88 <usb_isr+0x2f0>)
    5cac:	8815      	ldrh	r5, [r2, #0]
    5cae:	f242 0021 	movw	r0, #8225	; 0x2021
    5cb2:	4285      	cmp	r5, r0
    5cb4:	f000 8152 	beq.w	5f5c <usb_isr+0x4c4>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5cb8:	4a2d      	ldr	r2, [pc, #180]	; (5d70 <usb_isr+0x2d8>)
    5cba:	f847 2034 	str.w	r2, [r7, r4, lsl #3]
    5cbe:	e7f0      	b.n	5ca2 <usb_isr+0x20a>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5cc0:	4a2b      	ldr	r2, [pc, #172]	; (5d70 <usb_isr+0x2d8>)
    5cc2:	4b2c      	ldr	r3, [pc, #176]	; (5d74 <usb_isr+0x2dc>)
    5cc4:	f019 0f08 	tst.w	r9, #8
    5cc8:	bf18      	it	ne
    5cca:	4613      	movne	r3, r2
    5ccc:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    5cd0:	e72c      	b.n	5b2c <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    5cd2:	f000 fb95 	bl	6400 <usb_free>
				packet = tx_first[endpoint];
    5cd6:	4a34      	ldr	r2, [pc, #208]	; (5da8 <usb_isr+0x310>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    5cd8:	4934      	ldr	r1, [pc, #208]	; (5dac <usb_isr+0x314>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    5cda:	f852 3026 	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    5cde:	2b00      	cmp	r3, #0
    5ce0:	f000 812d 	beq.w	5f3e <usb_isr+0x4a6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    5ce4:	6858      	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    5ce6:	5d8c      	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    5ce8:	f842 0026 	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    5cec:	f103 0208 	add.w	r2, r3, #8
    5cf0:	f8c9 2004 	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    5cf4:	2c03      	cmp	r4, #3
    5cf6:	d805      	bhi.n	5d04 <usb_isr+0x26c>
    5cf8:	e8df f004 	tbb	[pc, r4]
    5cfc:	02150f12 	.word	0x02150f12
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    5d00:	2204      	movs	r2, #4
    5d02:	558a      	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    5d04:	881a      	ldrh	r2, [r3, #0]
    5d06:	f019 0f08 	tst.w	r9, #8
    5d0a:	bf0c      	ite	eq
    5d0c:	2388      	moveq	r3, #136	; 0x88
    5d0e:	23c8      	movne	r3, #200	; 0xc8
    5d10:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    5d14:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    5d18:	e708      	b.n	5b2c <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    5d1a:	2202      	movs	r2, #2
    5d1c:	558a      	strb	r2, [r1, r6]
						break;
    5d1e:	e7f1      	b.n	5d04 <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    5d20:	2203      	movs	r2, #3
    5d22:	558a      	strb	r2, [r1, r6]
						break;
    5d24:	e7ee      	b.n	5d04 <usb_isr+0x26c>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    5d26:	2205      	movs	r2, #5
    5d28:	558a      	strb	r2, [r1, r6]
						break;
    5d2a:	e7eb      	b.n	5d04 <usb_isr+0x26c>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    5d2c:	07e0      	lsls	r0, r4, #31
    5d2e:	f100 8178 	bmi.w	6022 <usb_isr+0x58a>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    5d32:	0621      	lsls	r1, r4, #24
    5d34:	f100 81a2 	bmi.w	607c <usb_isr+0x5e4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    5d38:	07a2      	lsls	r2, r4, #30
    5d3a:	d506      	bpl.n	5d4a <usb_isr+0x2b2>
		uint8_t err = USB0_ERRSTAT;
    5d3c:	4a1c      	ldr	r2, [pc, #112]	; (5db0 <usb_isr+0x318>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    5d3e:	491d      	ldr	r1, [pc, #116]	; (5db4 <usb_isr+0x31c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    5d40:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    5d42:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    5d44:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    5d46:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    5d48:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    5d4a:	06e3      	lsls	r3, r4, #27
    5d4c:	d502      	bpl.n	5d54 <usb_isr+0x2bc>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    5d4e:	4b19      	ldr	r3, [pc, #100]	; (5db4 <usb_isr+0x31c>)
    5d50:	2210      	movs	r2, #16
    5d52:	701a      	strb	r2, [r3, #0]
	}

}
    5d54:	b007      	add	sp, #28
    5d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    5d5a:	f000 fcbd 	bl	66d8 <usb_serial_flush_callback>
    5d5e:	e706      	b.n	5b6e <usb_isr+0xd6>
    5d60:	1fff8000 	.word	0x1fff8000
    5d64:	1fffb53c 	.word	0x1fffb53c
    5d68:	1fffb4e8 	.word	0x1fffb4e8
    5d6c:	1fffb640 	.word	0x1fffb640
    5d70:	004000c8 	.word	0x004000c8
    5d74:	00400088 	.word	0x00400088
    5d78:	1fffb5c4 	.word	0x1fffb5c4
    5d7c:	1fffb54d 	.word	0x1fffb54d
    5d80:	1fffb5cc 	.word	0x1fffb5cc
    5d84:	1fffb4e4 	.word	0x1fffb4e4
    5d88:	1fffb5b0 	.word	0x1fffb5b0
    5d8c:	1fffb54c 	.word	0x1fffb54c
    5d90:	400720c0 	.word	0x400720c0
    5d94:	1fffb5bc 	.word	0x1fffb5bc
    5d98:	1fffb4f8 	.word	0x1fffb4f8
    5d9c:	1fffb5b8 	.word	0x1fffb5b8
    5da0:	40072098 	.word	0x40072098
    5da4:	40072094 	.word	0x40072094
    5da8:	1fffb590 	.word	0x1fffb590
    5dac:	1fffb5c8 	.word	0x1fffb5c8
    5db0:	40072088 	.word	0x40072088
    5db4:	40072080 	.word	0x40072080
    5db8:	40072090 	.word	0x40072090
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    5dbc:	4ab7      	ldr	r2, [pc, #732]	; (609c <usb_isr+0x604>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    5dbe:	f847 0038 	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    5dc2:	7813      	ldrb	r3, [r2, #0]
    5dc4:	3301      	adds	r3, #1
    5dc6:	7013      	strb	r3, [r2, #0]
    5dc8:	e6b0      	b.n	5b2c <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    5dca:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
    5dce:	4db4      	ldr	r5, [pc, #720]	; (60a0 <usb_isr+0x608>)
    5dd0:	e693      	b.n	5afa <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5dd2:	f242 0421 	movw	r4, #8225	; 0x2021
    5dd6:	42a1      	cmp	r1, r4
    5dd8:	f000 80ad 	beq.w	5f36 <usb_isr+0x49e>
    5ddc:	f200 810e 	bhi.w	5ffc <usb_isr+0x564>
    5de0:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    5de4:	f000 8154 	beq.w	6090 <usb_isr+0x5f8>
    5de8:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    5dec:	f040 819d 	bne.w	612a <usb_isr+0x692>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    5df0:	4aac      	ldr	r2, [pc, #688]	; (60a4 <usb_isr+0x60c>)
    5df2:	78a9      	ldrb	r1, [r5, #2]
    5df4:	7011      	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    5df6:	4dac      	ldr	r5, [pc, #688]	; (60a8 <usb_isr+0x610>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    5df8:	2404      	movs	r4, #4
    5dfa:	e002      	b.n	5e02 <usb_isr+0x36a>
    5dfc:	3401      	adds	r4, #1
    5dfe:	2c14      	cmp	r4, #20
    5e00:	d00c      	beq.n	5e1c <usb_isr+0x384>
			if (table[i].desc & BDT_OWN) {
    5e02:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
    5e06:	0619      	lsls	r1, r3, #24
    5e08:	d5f8      	bpl.n	5dfc <usb_isr+0x364>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    5e0a:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    5e0e:	3401      	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    5e10:	6858      	ldr	r0, [r3, #4]
    5e12:	3808      	subs	r0, #8
    5e14:	f000 faf4 	bl	6400 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    5e18:	2c14      	cmp	r4, #20
    5e1a:	d1f2      	bne.n	5e02 <usb_isr+0x36a>
    5e1c:	49a3      	ldr	r1, [pc, #652]	; (60ac <usb_isr+0x614>)
    5e1e:	4ba4      	ldr	r3, [pc, #656]	; (60b0 <usb_isr+0x618>)
    5e20:	4aa4      	ldr	r2, [pc, #656]	; (60b4 <usb_isr+0x61c>)
    5e22:	9102      	str	r1, [sp, #8]
    5e24:	49a4      	ldr	r1, [pc, #656]	; (60b8 <usb_isr+0x620>)
    5e26:	4ca5      	ldr	r4, [pc, #660]	; (60bc <usb_isr+0x624>)
    5e28:	4d9d      	ldr	r5, [pc, #628]	; (60a0 <usb_isr+0x608>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    5e2a:	9403      	str	r4, [sp, #12]
    5e2c:	9605      	str	r6, [sp, #20]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    5e2e:	f04f 0900 	mov.w	r9, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    5e32:	4688      	mov	r8, r1
    5e34:	461c      	mov	r4, r3
    5e36:	4616      	mov	r6, r2
    5e38:	9504      	str	r5, [sp, #16]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    5e3a:	6820      	ldr	r0, [r4, #0]
			while (p) {
    5e3c:	b128      	cbz	r0, 5e4a <usb_isr+0x3b2>
				n = p->next;
    5e3e:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    5e40:	f000 fade 	bl	6400 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    5e44:	4628      	mov	r0, r5
    5e46:	2d00      	cmp	r5, #0
    5e48:	d1f9      	bne.n	5e3e <usb_isr+0x3a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    5e4a:	2300      	movs	r3, #0
    5e4c:	6023      	str	r3, [r4, #0]
			rx_last[i] = NULL;
    5e4e:	9b04      	ldr	r3, [sp, #16]
			p = tx_first[i];
    5e50:	6830      	ldr	r0, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    5e52:	461a      	mov	r2, r3
    5e54:	2300      	movs	r3, #0
    5e56:	f842 3029 	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    5e5a:	b128      	cbz	r0, 5e68 <usb_isr+0x3d0>
				n = p->next;
    5e5c:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    5e5e:	f000 facf 	bl	6400 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    5e62:	4628      	mov	r0, r5
    5e64:	2d00      	cmp	r5, #0
    5e66:	d1f9      	bne.n	5e5c <usb_isr+0x3c4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    5e68:	2200      	movs	r2, #0
    5e6a:	6032      	str	r2, [r6, #0]
			tx_last[i] = NULL;
    5e6c:	9a02      	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    5e6e:	f898 3000 	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    5e72:	4611      	mov	r1, r2
    5e74:	2200      	movs	r2, #0
    5e76:	f841 2b04 	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    5e7a:	9a03      	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    5e7c:	9102      	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    5e7e:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    5e80:	f04f 0100 	mov.w	r1, #0
    5e84:	f822 1019 	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    5e88:	2b03      	cmp	r3, #3
    5e8a:	f200 81b4 	bhi.w	61f6 <usb_isr+0x75e>
    5e8e:	e8df f013 	tbh	[pc, r3, lsl #1]
    5e92:	01e2      	.short	0x01e2
    5e94:	01e201ae 	.word	0x01e201ae
    5e98:	01ae      	.short	0x01ae
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    5e9a:	4c89      	ldr	r4, [pc, #548]	; (60c0 <usb_isr+0x628>)
		reply_buffer[1] = 0;
		datalen = 2;
    5e9c:	2002      	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    5e9e:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    5ea0:	7062      	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    5ea2:	88ea      	ldrh	r2, [r5, #6]
    5ea4:	4282      	cmp	r2, r0
    5ea6:	f080 820d 	bcs.w	62c4 <usb_isr+0x82c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5eaa:	4986      	ldr	r1, [pc, #536]	; (60c4 <usb_isr+0x62c>)
    5eac:	780d      	ldrb	r5, [r1, #0]
    5eae:	2a40      	cmp	r2, #64	; 0x40
    5eb0:	f045 0e02 	orr.w	lr, r5, #2
    5eb4:	4694      	mov	ip, r2
    5eb6:	eb07 00ce 	add.w	r0, r7, lr, lsl #3
    5eba:	bf28      	it	cs
    5ebc:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    5ec0:	eb04 030c 	add.w	r3, r4, ip
    5ec4:	6044      	str	r4, [r0, #4]
    5ec6:	9302      	str	r3, [sp, #8]
    5ec8:	ebcc 0002 	rsb	r0, ip, r2
    5ecc:	ea4f 480c 	mov.w	r8, ip, lsl #16
    5ed0:	f04f 0901 	mov.w	r9, #1
    5ed4:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5ed6:	24c8      	movs	r4, #200	; 0xc8
    5ed8:	ea44 0308 	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5edc:	f085 0401 	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5ee0:	f847 303e 	str.w	r3, [r7, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    5ee4:	7032      	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    5ee6:	700c      	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5ee8:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 60a8 <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    5eec:	4b76      	ldr	r3, [pc, #472]	; (60c8 <usb_isr+0x630>)
	ep0_tx_bdt_bank ^= 1;
    5eee:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 60c4 <usb_isr+0x62c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    5ef2:	2800      	cmp	r0, #0
    5ef4:	f040 8120 	bne.w	6138 <usb_isr+0x6a0>
    5ef8:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
    5efc:	d11b      	bne.n	5f36 <usb_isr+0x49e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5efe:	f044 0402 	orr.w	r4, r4, #2
    5f02:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
    5f06:	9f02      	ldr	r7, [sp, #8]
    5f08:	f8df e19c 	ldr.w	lr, [pc, #412]	; 60a8 <usb_isr+0x610>
    5f0c:	605f      	str	r7, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5f0e:	2a00      	cmp	r2, #0
    5f10:	f040 8127 	bne.w	6162 <usb_isr+0x6ca>
    5f14:	0402      	lsls	r2, r0, #16
    5f16:	f042 0288 	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    5f1a:	f886 9000 	strb.w	r9, [r6]
	ep0_tx_bdt_bank ^= 1;
    5f1e:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5f20:	4407      	add	r7, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5f22:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5f26:	463b      	mov	r3, r7
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    5f28:	2840      	cmp	r0, #64	; 0x40
    5f2a:	d104      	bne.n	5f36 <usb_isr+0x49e>
    5f2c:	2000      	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    5f2e:	4a67      	ldr	r2, [pc, #412]	; (60cc <usb_isr+0x634>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    5f30:	9901      	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    5f32:	8010      	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    5f34:	600b      	str	r3, [r1, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5f36:	4a66      	ldr	r2, [pc, #408]	; (60d0 <usb_isr+0x638>)
    5f38:	2301      	movs	r3, #1
    5f3a:	7013      	strb	r3, [r2, #0]
    5f3c:	e6b1      	b.n	5ca2 <usb_isr+0x20a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    5f3e:	5d8b      	ldrb	r3, [r1, r6]
    5f40:	2b03      	cmp	r3, #3
    5f42:	f200 8124 	bhi.w	618e <usb_isr+0x6f6>
    5f46:	a201      	add	r2, pc, #4	; (adr r2, 5f4c <usb_isr+0x4b4>)
    5f48:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5f4c:	00005b2d 	.word	0x00005b2d
    5f50:	00005b2d 	.word	0x00005b2d
    5f54:	00006071 	.word	0x00006071
    5f58:	00006077 	.word	0x00006077
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    5f5c:	8892      	ldrh	r2, [r2, #4]
    5f5e:	b962      	cbnz	r2, 5f7a <usb_isr+0x4e2>
    5f60:	4a5c      	ldr	r2, [pc, #368]	; (60d4 <usb_isr+0x63c>)
    5f62:	1dcd      	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    5f64:	f811 3b01 	ldrb.w	r3, [r1], #1
    5f68:	f802 3f01 	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    5f6c:	428d      	cmp	r5, r1
    5f6e:	d1f9      	bne.n	5f64 <usb_isr+0x4cc>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    5f70:	4a59      	ldr	r2, [pc, #356]	; (60d8 <usb_isr+0x640>)
    5f72:	6812      	ldr	r2, [r2, #0]
    5f74:	2a86      	cmp	r2, #134	; 0x86
    5f76:	f000 80c9 	beq.w	610c <usb_isr+0x674>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5f7a:	4952      	ldr	r1, [pc, #328]	; (60c4 <usb_isr+0x62c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5f7c:	4e52      	ldr	r6, [pc, #328]	; (60c8 <usb_isr+0x630>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5f7e:	7808      	ldrb	r0, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5f80:	7832      	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5f82:	f040 0502 	orr.w	r5, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5f86:	f080 0001 	eor.w	r0, r0, #1
    5f8a:	7008      	strb	r0, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5f8c:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5f90:	2a00      	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5f92:	f04f 0000 	mov.w	r0, #0
    5f96:	6048      	str	r0, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    5f98:	f082 0201 	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5f9c:	bf0c      	ite	eq
    5f9e:	2188      	moveq	r1, #136	; 0x88
    5fa0:	21c8      	movne	r1, #200	; 0xc8
    5fa2:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    5fa6:	7032      	strb	r2, [r6, #0]
    5fa8:	e686      	b.n	5cb8 <usb_isr+0x220>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5faa:	f240 3202 	movw	r2, #770	; 0x302
    5fae:	4291      	cmp	r1, r2
    5fb0:	f040 80b0 	bne.w	6114 <usb_isr+0x67c>
    5fb4:	88a9      	ldrh	r1, [r5, #4]
    5fb6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    5fba:	2904      	cmp	r1, #4
    5fbc:	f200 80b5 	bhi.w	612a <usb_isr+0x692>
    5fc0:	886a      	ldrh	r2, [r5, #2]
    5fc2:	2a00      	cmp	r2, #0
    5fc4:	f040 80b1 	bne.w	612a <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    5fc8:	4c44      	ldr	r4, [pc, #272]	; (60dc <usb_isr+0x644>)
    5fca:	0089      	lsls	r1, r1, #2
    5fcc:	440c      	add	r4, r1
    5fce:	4681      	mov	r9, r0
    5fd0:	7821      	ldrb	r1, [r4, #0]
    5fd2:	f041 0102 	orr.w	r1, r1, #2
    5fd6:	7021      	strb	r1, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    5fd8:	2000      	movs	r0, #0
    5fda:	9002      	str	r0, [sp, #8]
    5fdc:	4680      	mov	r8, r0
    5fde:	4684      	mov	ip, r0
    5fe0:	4604      	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5fe2:	4938      	ldr	r1, [pc, #224]	; (60c4 <usb_isr+0x62c>)
    5fe4:	780d      	ldrb	r5, [r1, #0]
    5fe6:	f045 0e02 	orr.w	lr, r5, #2
    5fea:	eb07 03ce 	add.w	r3, r7, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5fee:	f1b9 0f00 	cmp.w	r9, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5ff2:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5ff4:	bf0c      	ite	eq
    5ff6:	2488      	moveq	r4, #136	; 0x88
    5ff8:	24c8      	movne	r4, #200	; 0xc8
    5ffa:	e76d      	b.n	5ed8 <usb_isr+0x440>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5ffc:	f242 2421 	movw	r4, #8737	; 0x2221
    6000:	42a1      	cmp	r1, r4
    6002:	f040 808e 	bne.w	6122 <usb_isr+0x68a>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    6006:	88a9      	ldrh	r1, [r5, #4]
    6008:	2900      	cmp	r1, #0
    600a:	f040 8142 	bne.w	6292 <usb_isr+0x7fa>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    600e:	4b34      	ldr	r3, [pc, #208]	; (60e0 <usb_isr+0x648>)
    6010:	4a34      	ldr	r2, [pc, #208]	; (60e4 <usb_isr+0x64c>)
			usb_cdc_line_rtsdtr = setup.wValue;
    6012:	4c35      	ldr	r4, [pc, #212]	; (60e8 <usb_isr+0x650>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6014:	681b      	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    6016:	78ad      	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6018:	6013      	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    601a:	4681      	mov	r9, r0
    601c:	460a      	mov	r2, r1
    601e:	7025      	strb	r5, [r4, #0]
    6020:	e7da      	b.n	5fd8 <usb_isr+0x540>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    6022:	492b      	ldr	r1, [pc, #172]	; (60d0 <usb_isr+0x638>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    6024:	4b20      	ldr	r3, [pc, #128]	; (60a8 <usb_isr+0x610>)
    6026:	4831      	ldr	r0, [pc, #196]	; (60ec <usb_isr+0x654>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    6028:	4e26      	ldr	r6, [pc, #152]	; (60c4 <usb_isr+0x62c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    602a:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 60dc <usb_isr+0x644>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    602e:	4d30      	ldr	r5, [pc, #192]	; (60f0 <usb_isr+0x658>)
		USB0_ISTAT = 0xFF;
    6030:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 6108 <usb_isr+0x670>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    6034:	4f2f      	ldr	r7, [pc, #188]	; (60f4 <usb_isr+0x65c>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    6036:	2402      	movs	r4, #2
    6038:	700c      	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    603a:	4c2f      	ldr	r4, [pc, #188]	; (60f8 <usb_isr+0x660>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    603c:	6018      	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    603e:	605c      	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    6040:	6098      	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    6042:	482e      	ldr	r0, [pc, #184]	; (60fc <usb_isr+0x664>)
    6044:	60d8      	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    6046:	611a      	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    6048:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    604a:	230d      	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    604c:	7032      	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    604e:	4c2c      	ldr	r4, [pc, #176]	; (6100 <usb_isr+0x668>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6050:	f88c 3000 	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6054:	4e2b      	ldr	r6, [pc, #172]	; (6104 <usb_isr+0x66c>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    6056:	23ff      	movs	r3, #255	; 0xff
    6058:	702b      	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    605a:	2001      	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    605c:	259f      	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    605e:	f88e 3000 	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    6062:	703a      	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6064:	7033      	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6066:	7025      	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    6068:	7008      	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    606a:	b007      	add	sp, #28
    606c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6070:	2300      	movs	r3, #0
    6072:	558b      	strb	r3, [r1, r6]
						break;
    6074:	e55a      	b.n	5b2c <usb_isr+0x94>
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6076:	2301      	movs	r3, #1
    6078:	558b      	strb	r3, [r1, r6]
						break;
    607a:	e557      	b.n	5b2c <usb_isr+0x94>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    607c:	4917      	ldr	r1, [pc, #92]	; (60dc <usb_isr+0x644>)
		USB0_ISTAT = USB_ISTAT_STALL;
    607e:	4b22      	ldr	r3, [pc, #136]	; (6108 <usb_isr+0x670>)
    6080:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6082:	200d      	movs	r0, #13
    6084:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    6086:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    6088:	07a2      	lsls	r2, r4, #30
    608a:	f57f ae5e 	bpl.w	5d4a <usb_isr+0x2b2>
    608e:	e655      	b.n	5d3c <usb_isr+0x2a4>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    6090:	4a04      	ldr	r2, [pc, #16]	; (60a4 <usb_isr+0x60c>)
    6092:	4c0b      	ldr	r4, [pc, #44]	; (60c0 <usb_isr+0x628>)
    6094:	7812      	ldrb	r2, [r2, #0]
    6096:	7022      	strb	r2, [r4, #0]
    6098:	e703      	b.n	5ea2 <usb_isr+0x40a>
    609a:	bf00      	nop
    609c:	1fffb5b9 	.word	0x1fffb5b9
    60a0:	1fffb4e8 	.word	0x1fffb4e8
    60a4:	1fffb5c4 	.word	0x1fffb5c4
    60a8:	1fff8000 	.word	0x1fff8000
    60ac:	1fffb5a0 	.word	0x1fffb5a0
    60b0:	1fffb53c 	.word	0x1fffb53c
    60b4:	1fffb590 	.word	0x1fffb590
    60b8:	1fffb5c8 	.word	0x1fffb5c8
    60bc:	1fffb640 	.word	0x1fffb640
    60c0:	1fffb5bc 	.word	0x1fffb5bc
    60c4:	1fffb5b8 	.word	0x1fffb5b8
    60c8:	1fffb54c 	.word	0x1fffb54c
    60cc:	1fffb4f8 	.word	0x1fffb4f8
    60d0:	40072094 	.word	0x40072094
    60d4:	1fffb647 	.word	0x1fffb647
    60d8:	1fffb648 	.word	0x1fffb648
    60dc:	400720c0 	.word	0x400720c0
    60e0:	1fffb440 	.word	0x1fffb440
    60e4:	1fffb650 	.word	0x1fffb650
    60e8:	1fffb5dc 	.word	0x1fffb5dc
    60ec:	00400088 	.word	0x00400088
    60f0:	40072088 	.word	0x40072088
    60f4:	40072098 	.word	0x40072098
    60f8:	1fffb4fc 	.word	0x1fffb4fc
    60fc:	1fffb550 	.word	0x1fffb550
    6100:	40072084 	.word	0x40072084
    6104:	4007208c 	.word	0x4007208c
    6108:	40072080 	.word	0x40072080
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    610c:	4a75      	ldr	r2, [pc, #468]	; (62e4 <usb_isr+0x84c>)
    610e:	210f      	movs	r1, #15
    6110:	7011      	strb	r1, [r2, #0]
    6112:	e732      	b.n	5f7a <usb_isr+0x4e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6114:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    6118:	d107      	bne.n	612a <usb_isr+0x692>
    611a:	2200      	movs	r2, #0
    611c:	f04f 0901 	mov.w	r9, #1
    6120:	e75a      	b.n	5fd8 <usb_isr+0x540>
    6122:	f242 3221 	movw	r2, #8993	; 0x2321
    6126:	4291      	cmp	r1, r2
    6128:	d0f7      	beq.n	611a <usb_isr+0x682>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    612a:	4b6f      	ldr	r3, [pc, #444]	; (62e8 <usb_isr+0x850>)
    612c:	220f      	movs	r2, #15
    612e:	701a      	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    6130:	4a6e      	ldr	r2, [pc, #440]	; (62ec <usb_isr+0x854>)
    6132:	2301      	movs	r3, #1
    6134:	7013      	strb	r3, [r2, #0]
    6136:	e5b4      	b.n	5ca2 <usb_isr+0x20a>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    6138:	2840      	cmp	r0, #64	; 0x40
    613a:	f67f aee0 	bls.w	5efe <usb_isr+0x466>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    613e:	f044 0402 	orr.w	r4, r4, #2
    6142:	eb0e 01c4 	add.w	r1, lr, r4, lsl #3
    6146:	9e02      	ldr	r6, [sp, #8]
    6148:	604e      	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    614a:	b1aa      	cbz	r2, 6178 <usb_isr+0x6e0>
	ep0_tx_data_toggle ^= 1;
    614c:	f883 9000 	strb.w	r9, [r3]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6150:	4a67      	ldr	r2, [pc, #412]	; (62f0 <usb_isr+0x858>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6152:	f888 5000 	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6156:	4633      	mov	r3, r6
    6158:	3840      	subs	r0, #64	; 0x40
    615a:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    615c:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6160:	e6e5      	b.n	5f2e <usb_isr+0x496>
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6162:	9b02      	ldr	r3, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6164:	f886 9000 	strb.w	r9, [r6]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6168:	0402      	lsls	r2, r0, #16
    616a:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    616e:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6170:	4403      	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6172:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6176:	e6d7      	b.n	5f28 <usb_isr+0x490>
	ep0_tx_data_toggle ^= 1;
    6178:	f883 9000 	strb.w	r9, [r3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    617c:	9b02      	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    617e:	4a5d      	ldr	r2, [pc, #372]	; (62f4 <usb_isr+0x85c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6180:	f888 5000 	strb.w	r5, [r8]
    6184:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6186:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6188:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    618c:	e6cf      	b.n	5f2e <usb_isr+0x496>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    618e:	f019 0f08 	tst.w	r9, #8
    6192:	bf0c      	ite	eq
    6194:	2302      	moveq	r3, #2
    6196:	2303      	movne	r3, #3
    6198:	558b      	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    619a:	e4c7      	b.n	5b2c <usb_isr+0x94>
    619c:	88a9      	ldrh	r1, [r5, #4]
    619e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    61a2:	2904      	cmp	r1, #4
    61a4:	d8c1      	bhi.n	612a <usb_isr+0x692>
    61a6:	886a      	ldrh	r2, [r5, #2]
    61a8:	2a00      	cmp	r2, #0
    61aa:	d1be      	bne.n	612a <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    61ac:	4c4e      	ldr	r4, [pc, #312]	; (62e8 <usb_isr+0x850>)
    61ae:	0089      	lsls	r1, r1, #2
    61b0:	440c      	add	r4, r1
    61b2:	4681      	mov	r9, r0
    61b4:	7821      	ldrb	r1, [r4, #0]
    61b6:	f021 0102 	bic.w	r1, r1, #2
    61ba:	7021      	strb	r1, [r4, #0]
    61bc:	e70c      	b.n	5fd8 <usb_isr+0x540>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    61be:	4a4e      	ldr	r2, [pc, #312]	; (62f8 <usb_isr+0x860>)
    61c0:	6854      	ldr	r4, [r2, #4]
    61c2:	2c00      	cmp	r4, #0
    61c4:	d0b1      	beq.n	612a <usb_isr+0x692>
    61c6:	8868      	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    61c8:	f8b5 e004 	ldrh.w	lr, [r5, #4]
    61cc:	e003      	b.n	61d6 <usb_isr+0x73e>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    61ce:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    61d0:	6854      	ldr	r4, [r2, #4]
    61d2:	2c00      	cmp	r4, #0
    61d4:	d0a9      	beq.n	612a <usb_isr+0x692>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    61d6:	8813      	ldrh	r3, [r2, #0]
    61d8:	4283      	cmp	r3, r0
    61da:	d1f8      	bne.n	61ce <usb_isr+0x736>
    61dc:	8853      	ldrh	r3, [r2, #2]
    61de:	4573      	cmp	r3, lr
    61e0:	d1f5      	bne.n	61ce <usb_isr+0x736>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    61e2:	0a00      	lsrs	r0, r0, #8
    61e4:	2803      	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    61e6:	bf0c      	ite	eq
    61e8:	7820      	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    61ea:	8910      	ldrhne	r0, [r2, #8]
    61ec:	e659      	b.n	5ea2 <usb_isr+0x40a>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    61ee:	f04f 0301 	mov.w	r3, #1
    61f2:	f888 3000 	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    61f6:	f109 0901 	add.w	r9, r9, #1
    61fa:	f1b9 0f04 	cmp.w	r9, #4
    61fe:	f104 0404 	add.w	r4, r4, #4
    6202:	f106 0604 	add.w	r6, r6, #4
    6206:	f108 0801 	add.w	r8, r8, #1
    620a:	f47f ae16 	bne.w	5e3a <usb_isr+0x3a2>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    620e:	4b3b      	ldr	r3, [pc, #236]	; (62fc <usb_isr+0x864>)
    6210:	9e05      	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    6212:	4d3b      	ldr	r5, [pc, #236]	; (6300 <usb_isr+0x868>)
		cfg = usb_endpoint_config_table;
    6214:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 6308 <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    6218:	2000      	movs	r0, #0
    621a:	7018      	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    621c:	f04f 0901 	mov.w	r9, #1
			epconf = *cfg++;
    6220:	f818 3b01 	ldrb.w	r3, [r8], #1
			*reg = epconf;
    6224:	f805 3b04 	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    6228:	071a      	lsls	r2, r3, #28
    622a:	d419      	bmi.n	6260 <usb_isr+0x7c8>
    622c:	ea4f 0489 	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    6230:	f044 0202 	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    6234:	f044 0403 	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    6238:	2300      	movs	r3, #0
    623a:	f847 3032 	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    623e:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    6242:	4b30      	ldr	r3, [pc, #192]	; (6304 <usb_isr+0x86c>)
    6244:	429d      	cmp	r5, r3
    6246:	f109 0901 	add.w	r9, r9, #1
    624a:	d1e9      	bne.n	6220 <usb_isr+0x788>
    624c:	f896 9000 	ldrb.w	r9, [r6]
    6250:	f089 0201 	eor.w	r2, r9, #1
    6254:	e6c0      	b.n	5fd8 <usb_isr+0x540>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6256:	f04f 0300 	mov.w	r3, #0
    625a:	f888 3000 	strb.w	r3, [r8]
    625e:	e7ca      	b.n	61f6 <usb_isr+0x75e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    6260:	f000 f8ae 	bl	63c0 <usb_malloc>
				if (p) {
    6264:	b318      	cbz	r0, 62ae <usb_isr+0x816>
					table[index(i, RX, EVEN)].addr = p->buf;
    6266:	eb07 1349 	add.w	r3, r7, r9, lsl #5
    626a:	ea4f 0489 	mov.w	r4, r9, lsl #2
    626e:	3008      	adds	r0, #8
    6270:	6058      	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    6272:	4b20      	ldr	r3, [pc, #128]	; (62f4 <usb_isr+0x85c>)
    6274:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    6278:	f000 f8a2 	bl	63c0 <usb_malloc>
				if (p) {
    627c:	b168      	cbz	r0, 629a <usb_isr+0x802>
					table[index(i, RX, ODD)].addr = p->buf;
    627e:	f044 0301 	orr.w	r3, r4, #1
    6282:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    6286:	3008      	adds	r0, #8
    6288:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    628a:	4a19      	ldr	r2, [pc, #100]	; (62f0 <usb_isr+0x858>)
    628c:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
    6290:	e7ce      	b.n	6230 <usb_isr+0x798>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    6292:	4681      	mov	r9, r0
    6294:	e6a0      	b.n	5fd8 <usb_isr+0x540>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    6296:	2002      	movs	r0, #2
    6298:	e603      	b.n	5ea2 <usb_isr+0x40a>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    629a:	4b18      	ldr	r3, [pc, #96]	; (62fc <usb_isr+0x864>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    629c:	f044 0201 	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    62a0:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    62a2:	f847 0032 	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    62a6:	4a15      	ldr	r2, [pc, #84]	; (62fc <usb_isr+0x864>)
    62a8:	3301      	adds	r3, #1
    62aa:	7013      	strb	r3, [r2, #0]
    62ac:	e7c0      	b.n	6230 <usb_isr+0x798>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    62ae:	4b13      	ldr	r3, [pc, #76]	; (62fc <usb_isr+0x864>)
    62b0:	4a12      	ldr	r2, [pc, #72]	; (62fc <usb_isr+0x864>)
    62b2:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    62b4:	ea4f 0489 	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    62b8:	3301      	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    62ba:	f847 0034 	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    62be:	7013      	strb	r3, [r2, #0]
    62c0:	e7da      	b.n	6278 <usb_isr+0x7e0>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    62c2:	be00      	bkpt	0x0000
    62c4:	2840      	cmp	r0, #64	; 0x40
    62c6:	4684      	mov	ip, r0
    62c8:	bf28      	it	cs
    62ca:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    62ce:	eb04 030c 	add.w	r3, r4, ip
    62d2:	ebcc 0000 	rsb	r0, ip, r0
    62d6:	ea4f 480c 	mov.w	r8, ip, lsl #16
    62da:	9302      	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    62dc:	2200      	movs	r2, #0
    62de:	f04f 0901 	mov.w	r9, #1
    62e2:	e67e      	b.n	5fe2 <usb_isr+0x54a>
    62e4:	1fffb54d 	.word	0x1fffb54d
    62e8:	400720c0 	.word	0x400720c0
    62ec:	40072094 	.word	0x40072094
    62f0:	004000c8 	.word	0x004000c8
    62f4:	00400088 	.word	0x00400088
    62f8:	000096c8 	.word	0x000096c8
    62fc:	1fffb5b9 	.word	0x1fffb5b9
    6300:	400720c4 	.word	0x400720c4
    6304:	400720d4 	.word	0x400720d4
    6308:	000096c4 	.word	0x000096c4

0000630c <usb_init>:
}



void usb_init(void)
{
    630c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    6310:	f000 fed4 	bl	70bc <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    6314:	2300      	movs	r3, #0
    6316:	491f      	ldr	r1, [pc, #124]	; (6394 <usb_init+0x88>)
		table[i].desc = 0;
    6318:	461a      	mov	r2, r3
		table[i].addr = 0;
    631a:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    631e:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    6322:	3301      	adds	r3, #1
    6324:	2b14      	cmp	r3, #20
		table[i].desc = 0;
		table[i].addr = 0;
    6326:	6042      	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    6328:	f04f 0400 	mov.w	r4, #0
    632c:	4819      	ldr	r0, [pc, #100]	; (6394 <usb_init+0x88>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    632e:	d1f4      	bne.n	631a <usb_init+0xe>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6330:	4a19      	ldr	r2, [pc, #100]	; (6398 <usb_init+0x8c>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6332:	4f1a      	ldr	r7, [pc, #104]	; (639c <usb_init+0x90>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6334:	6813      	ldr	r3, [r2, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6336:	491a      	ldr	r1, [pc, #104]	; (63a0 <usb_init+0x94>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6338:	4d1a      	ldr	r5, [pc, #104]	; (63a4 <usb_init+0x98>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    633a:	4e1b      	ldr	r6, [pc, #108]	; (63a8 <usb_init+0x9c>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    633c:	f8df c074 	ldr.w	ip, [pc, #116]	; 63b4 <usb_init+0xa8>
	USB0_ERRSTAT = 0xFF;
    6340:	f8df e074 	ldr.w	lr, [pc, #116]	; 63b8 <usb_init+0xac>
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    6344:	f8df 8074 	ldr.w	r8, [pc, #116]	; 63bc <usb_init+0xb0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6348:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    634c:	6013      	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    634e:	f3c0 2307 	ubfx	r3, r0, #8, #8
    6352:	703b      	strb	r3, [r7, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6354:	f3c0 4307 	ubfx	r3, r0, #16, #8
    6358:	700b      	strb	r3, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    635a:	0e00      	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    635c:	23ff      	movs	r3, #255	; 0xff
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    635e:	f502 3228 	add.w	r2, r2, #172032	; 0x2a000
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6362:	7028      	strb	r0, [r5, #0]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6364:	32d4      	adds	r2, #212	; 0xd4
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6366:	f88c 3000 	strb.w	r3, [ip]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    636a:	4d10      	ldr	r5, [pc, #64]	; (63ac <usb_init+0xa0>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    636c:	f88e 3000 	strb.w	r3, [lr]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6370:	480f      	ldr	r0, [pc, #60]	; (63b0 <usb_init+0xa4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    6372:	7033      	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    6374:	2301      	movs	r3, #1
    6376:	f888 3000 	strb.w	r3, [r8]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    637a:	2670      	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    637c:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6380:	f44f 7400 	mov.w	r4, #512	; 0x200

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6384:	2110      	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    6386:	f807 3c18 	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    638a:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    638c:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    638e:	7011      	strb	r1, [r2, #0]
    6390:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6394:	1fff8000 	.word	0x1fff8000
    6398:	40048034 	.word	0x40048034
    639c:	4007209c 	.word	0x4007209c
    63a0:	400720b0 	.word	0x400720b0
    63a4:	400720b4 	.word	0x400720b4
    63a8:	40072010 	.word	0x40072010
    63ac:	e000e449 	.word	0xe000e449
    63b0:	e000e108 	.word	0xe000e108
    63b4:	40072080 	.word	0x40072080
    63b8:	40072088 	.word	0x40072088
    63bc:	40072094 	.word	0x40072094

000063c0 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    63c0:	b672      	cpsid	i
	avail = usb_buffer_available;
    63c2:	480d      	ldr	r0, [pc, #52]	; (63f8 <usb_malloc+0x38>)
    63c4:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    63c6:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    63ca:	2b0b      	cmp	r3, #11
    63cc:	dc10      	bgt.n	63f0 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    63ce:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    63d2:	40d9      	lsrs	r1, r3
    63d4:	ea22 0201 	bic.w	r2, r2, r1
    63d8:	6002      	str	r2, [r0, #0]
	__enable_irq();
    63da:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    63dc:	4807      	ldr	r0, [pc, #28]	; (63fc <usb_malloc+0x3c>)
    63de:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    63e2:	00db      	lsls	r3, r3, #3
    63e4:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    63e6:	2100      	movs	r1, #0
    63e8:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    63ea:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    63ec:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    63ee:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    63f0:	b662      	cpsie	i
		return NULL;
    63f2:	2000      	movs	r0, #0
    63f4:	4770      	bx	lr
    63f6:	bf00      	nop
    63f8:	1fff8748 	.word	0x1fff8748
    63fc:	1fff83bc 	.word	0x1fff83bc

00006400 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    6400:	4b0d      	ldr	r3, [pc, #52]	; (6438 <usb_free+0x38>)
    6402:	4a0e      	ldr	r2, [pc, #56]	; (643c <usb_free+0x3c>)
    6404:	1ac3      	subs	r3, r0, r3
    6406:	fba2 2303 	umull	r2, r3, r2, r3
    640a:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    640c:	2b0b      	cmp	r3, #11
    640e:	d80c      	bhi.n	642a <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    6410:	4a0b      	ldr	r2, [pc, #44]	; (6440 <usb_free+0x40>)
    6412:	7812      	ldrb	r2, [r2, #0]
    6414:	b952      	cbnz	r2, 642c <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    6416:	b672      	cpsid	i
	usb_buffer_available |= mask;
    6418:	480a      	ldr	r0, [pc, #40]	; (6444 <usb_free+0x44>)
    641a:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    641e:	6802      	ldr	r2, [r0, #0]
    6420:	fa21 f303 	lsr.w	r3, r1, r3
    6424:	431a      	orrs	r2, r3
    6426:	6002      	str	r2, [r0, #0]
	__enable_irq();
    6428:	b662      	cpsie	i
    642a:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    642c:	4a06      	ldr	r2, [pc, #24]	; (6448 <usb_free+0x48>)
    642e:	7812      	ldrb	r2, [r2, #0]
    6430:	2a00      	cmp	r2, #0
    6432:	d0f0      	beq.n	6416 <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    6434:	f7ff baac 	b.w	5990 <usb_rx_memory>
    6438:	1fff83bc 	.word	0x1fff83bc
    643c:	38e38e39 	.word	0x38e38e39
    6440:	1fffb5b9 	.word	0x1fffb5b9
    6444:	1fff8748 	.word	0x1fff8748
    6448:	1fffb5c4 	.word	0x1fffb5c4

0000644c <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    644c:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    644e:	4d0f      	ldr	r5, [pc, #60]	; (648c <usb_serial_getchar+0x40>)
    6450:	6828      	ldr	r0, [r5, #0]
    6452:	b178      	cbz	r0, 6474 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    6454:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    6456:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    6458:	18c1      	adds	r1, r0, r3
    645a:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    645c:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    645e:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    6460:	d202      	bcs.n	6468 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    6462:	8043      	strh	r3, [r0, #2]
	}
	return c;
    6464:	4620      	mov	r0, r4
}
    6466:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    6468:	f7ff ffca 	bl	6400 <usb_free>
		rx_packet = NULL;
    646c:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    646e:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    6470:	602b      	str	r3, [r5, #0]
    6472:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    6474:	4b06      	ldr	r3, [pc, #24]	; (6490 <usb_serial_getchar+0x44>)
    6476:	781b      	ldrb	r3, [r3, #0]
    6478:	b12b      	cbz	r3, 6486 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    647a:	2003      	movs	r0, #3
    647c:	f7ff fa54 	bl	5928 <usb_rx>
    6480:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    6482:	2800      	cmp	r0, #0
    6484:	d1e6      	bne.n	6454 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    6486:	f04f 30ff 	mov.w	r0, #4294967295
    648a:	bd38      	pop	{r3, r4, r5, pc}
    648c:	1fffb5d8 	.word	0x1fffb5d8
    6490:	1fffb5c4 	.word	0x1fffb5c4

00006494 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    6494:	b510      	push	{r4, lr}
	if (!rx_packet) {
    6496:	4c09      	ldr	r4, [pc, #36]	; (64bc <usb_serial_peekchar+0x28>)
    6498:	6820      	ldr	r0, [r4, #0]
    649a:	b118      	cbz	r0, 64a4 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    649c:	8843      	ldrh	r3, [r0, #2]
    649e:	4418      	add	r0, r3
    64a0:	7a00      	ldrb	r0, [r0, #8]
}
    64a2:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    64a4:	4b06      	ldr	r3, [pc, #24]	; (64c0 <usb_serial_peekchar+0x2c>)
    64a6:	781b      	ldrb	r3, [r3, #0]
    64a8:	b12b      	cbz	r3, 64b6 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    64aa:	2003      	movs	r0, #3
    64ac:	f7ff fa3c 	bl	5928 <usb_rx>
    64b0:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    64b2:	2800      	cmp	r0, #0
    64b4:	d1f2      	bne.n	649c <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    64b6:	f04f 30ff 	mov.w	r0, #4294967295
    64ba:	bd10      	pop	{r4, pc}
    64bc:	1fffb5d8 	.word	0x1fffb5d8
    64c0:	1fffb5c4 	.word	0x1fffb5c4

000064c4 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    64c4:	4b04      	ldr	r3, [pc, #16]	; (64d8 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    64c6:	4a05      	ldr	r2, [pc, #20]	; (64dc <usb_serial_available+0x18>)
    64c8:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    64ca:	8890      	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    64cc:	b11b      	cbz	r3, 64d6 <usb_serial_available+0x12>
    64ce:	881a      	ldrh	r2, [r3, #0]
    64d0:	885b      	ldrh	r3, [r3, #2]
    64d2:	1ad3      	subs	r3, r2, r3
    64d4:	4418      	add	r0, r3
	return count;
}
    64d6:	4770      	bx	lr
    64d8:	1fffb5d8 	.word	0x1fffb5d8
    64dc:	1fffb640 	.word	0x1fffb640

000064e0 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    64e0:	4b0b      	ldr	r3, [pc, #44]	; (6510 <usb_serial_flush_input+0x30>)
    64e2:	781b      	ldrb	r3, [r3, #0]
    64e4:	b19b      	cbz	r3, 650e <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    64e6:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    64e8:	4c0a      	ldr	r4, [pc, #40]	; (6514 <usb_serial_flush_input+0x34>)
    64ea:	6820      	ldr	r0, [r4, #0]
    64ec:	b148      	cbz	r0, 6502 <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    64ee:	f7ff ff87 	bl	6400 <usb_free>
		rx_packet = NULL;
    64f2:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    64f4:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    64f6:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    64f8:	f7ff fa16 	bl	5928 <usb_rx>
		if (!rx) break;
    64fc:	b130      	cbz	r0, 650c <usb_serial_flush_input+0x2c>
		usb_free(rx);
    64fe:	f7ff ff7f 	bl	6400 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    6502:	2003      	movs	r0, #3
    6504:	f7ff fa10 	bl	5928 <usb_rx>
		if (!rx) break;
    6508:	2800      	cmp	r0, #0
    650a:	d1f8      	bne.n	64fe <usb_serial_flush_input+0x1e>
    650c:	bd10      	pop	{r4, pc}
    650e:	4770      	bx	lr
    6510:	1fffb5c4 	.word	0x1fffb5c4
    6514:	1fffb5d8 	.word	0x1fffb5d8

00006518 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    6518:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    651c:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 6618 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    6520:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    6522:	2201      	movs	r2, #1
    6524:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    6528:	9101      	str	r1, [sp, #4]
    652a:	b369      	cbz	r1, 6588 <usb_serial_write+0x70>
    652c:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 661c <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    6530:	4f36      	ldr	r7, [pc, #216]	; (660c <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    6532:	9e01      	ldr	r6, [sp, #4]
    6534:	4683      	mov	fp, r0
		if (!tx_packet) {
    6536:	f8d8 0000 	ldr.w	r0, [r8]
    653a:	b3b0      	cbz	r0, 65aa <usb_serial_write+0x92>
    653c:	4d34      	ldr	r5, [pc, #208]	; (6610 <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    653e:	8844      	ldrh	r4, [r0, #2]
    6540:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    6544:	42b1      	cmp	r1, r6
    6546:	bf28      	it	cs
    6548:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    654a:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    654e:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    6550:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    6554:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    6556:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    6558:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    655c:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    6560:	b151      	cbz	r1, 6578 <usb_serial_write+0x60>
    6562:	3c01      	subs	r4, #1
    6564:	4422      	add	r2, r4
    6566:	4459      	add	r1, fp
    6568:	f81b 4b01 	ldrb.w	r4, [fp], #1
    656c:	f802 4f01 	strb.w	r4, [r2, #1]!
    6570:	458b      	cmp	fp, r1
    6572:	d1f9      	bne.n	6568 <usb_serial_write+0x50>
    6574:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    6578:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    657c:	d80b      	bhi.n	6596 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    657e:	4a25      	ldr	r2, [pc, #148]	; (6614 <usb_serial_write+0xfc>)
    6580:	2105      	movs	r1, #5
    6582:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    6584:	2e00      	cmp	r6, #0
    6586:	d1d6      	bne.n	6536 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    6588:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    658a:	2300      	movs	r3, #0
    658c:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    6590:	b003      	add	sp, #12
    6592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    6596:	2240      	movs	r2, #64	; 0x40
    6598:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    659a:	4601      	mov	r1, r0
    659c:	2004      	movs	r0, #4
    659e:	f7ff fa39 	bl	5a14 <usb_tx>
			tx_packet = NULL;
    65a2:	2200      	movs	r2, #0
    65a4:	f8c8 2000 	str.w	r2, [r8]
    65a8:	e7e9      	b.n	657e <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    65aa:	783a      	ldrb	r2, [r7, #0]
    65ac:	b32a      	cbz	r2, 65fa <usb_serial_write+0xe2>
    65ae:	4d18      	ldr	r5, [pc, #96]	; (6610 <usb_serial_write+0xf8>)
    65b0:	f24a 24f9 	movw	r4, #41721	; 0xa2f9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    65b4:	f04f 0a01 	mov.w	sl, #1
    65b8:	e007      	b.n	65ca <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    65ba:	3c01      	subs	r4, #1
    65bc:	d016      	beq.n	65ec <usb_serial_write+0xd4>
    65be:	782a      	ldrb	r2, [r5, #0]
    65c0:	b9a2      	cbnz	r2, 65ec <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    65c2:	f000 fc3f 	bl	6e44 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    65c6:	783a      	ldrb	r2, [r7, #0]
    65c8:	b1ba      	cbz	r2, 65fa <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    65ca:	2004      	movs	r0, #4
    65cc:	f7ff f9ca 	bl	5964 <usb_tx_packet_count>
    65d0:	2807      	cmp	r0, #7
    65d2:	d8f2      	bhi.n	65ba <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    65d4:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    65d8:	f7ff fef2 	bl	63c0 <usb_malloc>
    65dc:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    65e0:	2800      	cmp	r0, #0
    65e2:	d1ac      	bne.n	653e <usb_serial_write+0x26>
					tx_noautoflush = 0;
    65e4:	4b0c      	ldr	r3, [pc, #48]	; (6618 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    65e6:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    65e8:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    65ea:	d1e8      	bne.n	65be <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    65ec:	2301      	movs	r3, #1
					return -1;
    65ee:	f04f 30ff 	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    65f2:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    65f4:	b003      	add	sp, #12
    65f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    65fa:	2300      	movs	r3, #0
					return -1;
    65fc:	f04f 30ff 	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    6600:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    6604:	b003      	add	sp, #12
    6606:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    660a:	bf00      	nop
    660c:	1fffb5c4 	.word	0x1fffb5c4
    6610:	1fffb5d4 	.word	0x1fffb5d4
    6614:	1fffb5cc 	.word	0x1fffb5cc
    6618:	1fffb5cd 	.word	0x1fffb5cd
    661c:	1fffb5d0 	.word	0x1fffb5d0

00006620 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    6620:	b500      	push	{lr}
    6622:	b083      	sub	sp, #12
    6624:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    6626:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    6628:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    662c:	4618      	mov	r0, r3
    662e:	f7ff ff73 	bl	6518 <usb_serial_write>
}
    6632:	b003      	add	sp, #12
    6634:	f85d fb04 	ldr.w	pc, [sp], #4

00006638 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    6638:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    663a:	4d0e      	ldr	r5, [pc, #56]	; (6674 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    663c:	4c0e      	ldr	r4, [pc, #56]	; (6678 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    663e:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    6640:	2301      	movs	r3, #1
    6642:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    6644:	b128      	cbz	r0, 6652 <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    6646:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    6648:	2300      	movs	r3, #0
    664a:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    664c:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    6650:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    6652:	4b0a      	ldr	r3, [pc, #40]	; (667c <usb_serial_write_buffer_free+0x44>)
    6654:	781b      	ldrb	r3, [r3, #0]
    6656:	b913      	cbnz	r3, 665e <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    6658:	2000      	movs	r0, #0
    665a:	7020      	strb	r0, [r4, #0]
			return 0;
    665c:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    665e:	2004      	movs	r0, #4
    6660:	f7ff f980 	bl	5964 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    6664:	2807      	cmp	r0, #7
    6666:	d8f7      	bhi.n	6658 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    6668:	f7ff feaa 	bl	63c0 <usb_malloc>
    666c:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    666e:	2800      	cmp	r0, #0
    6670:	d1e9      	bne.n	6646 <usb_serial_write_buffer_free+0xe>
    6672:	e7f1      	b.n	6658 <usb_serial_write_buffer_free+0x20>
    6674:	1fffb5d0 	.word	0x1fffb5d0
    6678:	1fffb5cd 	.word	0x1fffb5cd
    667c:	1fffb5c4 	.word	0x1fffb5c4

00006680 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    6680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    6682:	4b11      	ldr	r3, [pc, #68]	; (66c8 <usb_serial_flush_output+0x48>)
    6684:	781b      	ldrb	r3, [r3, #0]
    6686:	b18b      	cbz	r3, 66ac <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    6688:	4e10      	ldr	r6, [pc, #64]	; (66cc <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    668a:	4d11      	ldr	r5, [pc, #68]	; (66d0 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    668c:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    668e:	2701      	movs	r7, #1
    6690:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    6692:	b164      	cbz	r4, 66ae <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    6694:	4a0f      	ldr	r2, [pc, #60]	; (66d4 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    6696:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    6698:	2700      	movs	r7, #0
    669a:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    669c:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    669e:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    66a0:	2004      	movs	r0, #4
    66a2:	f7ff f9b7 	bl	5a14 <usb_tx>
		tx_packet = NULL;
    66a6:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    66a8:	2300      	movs	r3, #0
    66aa:	702b      	strb	r3, [r5, #0]
    66ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    66ae:	f7ff fe87 	bl	63c0 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    66b2:	4b08      	ldr	r3, [pc, #32]	; (66d4 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    66b4:	b128      	cbz	r0, 66c2 <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    66b6:	4601      	mov	r1, r0
    66b8:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    66ba:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    66bc:	f7ff f9aa 	bl	5a14 <usb_tx>
    66c0:	e7f2      	b.n	66a8 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    66c2:	701f      	strb	r7, [r3, #0]
    66c4:	e7f0      	b.n	66a8 <usb_serial_flush_output+0x28>
    66c6:	bf00      	nop
    66c8:	1fffb5c4 	.word	0x1fffb5c4
    66cc:	1fffb5d0 	.word	0x1fffb5d0
    66d0:	1fffb5cd 	.word	0x1fffb5cd
    66d4:	1fffb5cc 	.word	0x1fffb5cc

000066d8 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    66d8:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    66da:	4b0e      	ldr	r3, [pc, #56]	; (6714 <usb_serial_flush_callback+0x3c>)
    66dc:	781b      	ldrb	r3, [r3, #0]
    66de:	b973      	cbnz	r3, 66fe <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    66e0:	4c0d      	ldr	r4, [pc, #52]	; (6718 <usb_serial_flush_callback+0x40>)
    66e2:	6821      	ldr	r1, [r4, #0]
    66e4:	b161      	cbz	r1, 6700 <usb_serial_flush_callback+0x28>
    66e6:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    66ea:	884b      	ldrh	r3, [r1, #2]
    66ec:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    66ee:	2004      	movs	r0, #4
    66f0:	f7ff f990 	bl	5a14 <usb_tx>
		tx_packet = NULL;
    66f4:	6025      	str	r5, [r4, #0]
    66f6:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    66f8:	4b08      	ldr	r3, [pc, #32]	; (671c <usb_serial_flush_callback+0x44>)
    66fa:	2201      	movs	r2, #1
    66fc:	701a      	strb	r2, [r3, #0]
    66fe:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    6700:	f7ff fe5e 	bl	63c0 <usb_malloc>
		if (tx) {
    6704:	2800      	cmp	r0, #0
    6706:	d0f7      	beq.n	66f8 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    6708:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    670a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    670e:	2004      	movs	r0, #4
    6710:	f7ff b980 	b.w	5a14 <usb_tx>
    6714:	1fffb5cd 	.word	0x1fffb5cd
    6718:	1fffb5d0 	.word	0x1fffb5d0
    671c:	1fffb5cc 	.word	0x1fffb5cc

00006720 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    6720:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t ch = 0;

	__disable_irq();
    6722:	b672      	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    6724:	b999      	cbnz	r1, 674e <DMAChannel::begin(bool)+0x2e>
    6726:	6802      	ldr	r2, [r0, #0]
    6728:	b18a      	cbz	r2, 674e <DMAChannel::begin(bool)+0x2e>
    672a:	7903      	ldrb	r3, [r0, #4]
    672c:	2b0f      	cmp	r3, #15
    672e:	d80e      	bhi.n	674e <DMAChannel::begin(bool)+0x2e>
	  && (dma_channel_allocated_mask & (1 << channel))
    6730:	4c27      	ldr	r4, [pc, #156]	; (67d0 <DMAChannel::begin(bool)+0xb0>)
    6732:	8821      	ldrh	r1, [r4, #0]
    6734:	fa41 f503 	asr.w	r5, r1, r3
    6738:	07ed      	lsls	r5, r5, #31
    673a:	d50a      	bpl.n	6752 <DMAChannel::begin(bool)+0x32>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    673c:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    6740:	f503 6390 	add.w	r3, r3, #1152	; 0x480
    6744:	ebb2 1f43 	cmp.w	r2, r3, lsl #5
    6748:	d103      	bne.n	6752 <DMAChannel::begin(bool)+0x32>
		// DMA channel already allocated
		__enable_irq();
    674a:	b662      	cpsie	i
		return;
    674c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    674e:	4c20      	ldr	r4, [pc, #128]	; (67d0 <DMAChannel::begin(bool)+0xb0>)
    6750:	8821      	ldrh	r1, [r4, #0]
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    6752:	2300      	movs	r3, #0
		// DMA channel already allocated
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    6754:	fa41 f203 	asr.w	r2, r1, r3
    6758:	f012 0201 	ands.w	r2, r2, #1
    675c:	d007      	beq.n	676e <DMAChannel::begin(bool)+0x4e>
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    675e:	3301      	adds	r3, #1
    6760:	2b10      	cmp	r3, #16
    6762:	d1f7      	bne.n	6754 <DMAChannel::begin(bool)+0x34>
			__enable_irq();
    6764:	b662      	cpsie	i
			TCD = (TCD_t *)0;
    6766:	2200      	movs	r2, #0
			channel = DMA_MAX_CHANNELS;
    6768:	7103      	strb	r3, [r0, #4]
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
			__enable_irq();
			TCD = (TCD_t *)0;
    676a:	6002      	str	r2, [r0, #0]
    676c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
    676e:	2501      	movs	r5, #1
    6770:	409d      	lsls	r5, r3
    6772:	4329      	orrs	r1, r5
    6774:	8021      	strh	r1, [r4, #0]
			__enable_irq();
    6776:	b662      	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    6778:	4e16      	ldr	r6, [pc, #88]	; (67d4 <DMAChannel::begin(bool)+0xb4>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    677a:	4d17      	ldr	r5, [pc, #92]	; (67d8 <DMAChannel::begin(bool)+0xb8>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    677c:	4f17      	ldr	r7, [pc, #92]	; (67dc <DMAChannel::begin(bool)+0xbc>)
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    677e:	f8df e064 	ldr.w	lr, [pc, #100]	; 67e4 <DMAChannel::begin(bool)+0xc4>
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    6782:	b2d9      	uxtb	r1, r3
    6784:	7101      	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    6786:	6834      	ldr	r4, [r6, #0]
    6788:	f044 0402 	orr.w	r4, r4, #2
    678c:	6034      	str	r4, [r6, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    678e:	682c      	ldr	r4, [r5, #0]
    6790:	f044 0402 	orr.w	r4, r4, #2
    6794:	602c      	str	r4, [r5, #0]
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    6796:	f5a6 2680 	sub.w	r6, r6, #262144	; 0x40000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    679a:	2482      	movs	r4, #130	; 0x82
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
    679c:	f5a5 2580 	sub.w	r5, r5, #262144	; 0x40000
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    67a0:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    67a4:	603c      	str	r4, [r7, #0]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    67a6:	f503 6390 	add.w	r3, r3, #1152	; 0x480
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    67aa:	3e22      	subs	r6, #34	; 0x22
	DMA_CEEI = ch;
    67ac:	3d24      	subs	r5, #36	; 0x24
	DMA_CINT = ch;
    67ae:	4c0c      	ldr	r4, [pc, #48]	; (67e0 <DMAChannel::begin(bool)+0xc0>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    67b0:	f88e 1000 	strb.w	r1, [lr]
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    67b4:	015b      	lsls	r3, r3, #5
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    67b6:	7031      	strb	r1, [r6, #0]
	DMA_CEEI = ch;
    67b8:	7029      	strb	r1, [r5, #0]
	DMA_CINT = ch;
    67ba:	7021      	strb	r1, [r4, #0]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    67bc:	6003      	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    67be:	601a      	str	r2, [r3, #0]
	*p++ = 0;
    67c0:	605a      	str	r2, [r3, #4]
	*p++ = 0;
    67c2:	609a      	str	r2, [r3, #8]
	*p++ = 0;
    67c4:	60da      	str	r2, [r3, #12]
	*p++ = 0;
    67c6:	611a      	str	r2, [r3, #16]
	*p++ = 0;
    67c8:	615a      	str	r2, [r3, #20]
	*p++ = 0;
    67ca:	619a      	str	r2, [r3, #24]
	*p++ = 0;
    67cc:	61da      	str	r2, [r3, #28]
    67ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    67d0:	1fffb5de 	.word	0x1fffb5de
    67d4:	40048040 	.word	0x40048040
    67d8:	4004803c 	.word	0x4004803c
    67dc:	40008000 	.word	0x40008000
    67e0:	4000801f 	.word	0x4000801f
    67e4:	4000801a 	.word	0x4000801a

000067e8 <DMAChannel::release()>:
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    67e8:	7903      	ldrb	r3, [r0, #4]
    67ea:	2b0f      	cmp	r3, #15
    67ec:	d811      	bhi.n	6812 <DMAChannel::release()+0x2a>
	DMA_CERQ = channel;
    67ee:	4a09      	ldr	r2, [pc, #36]	; (6814 <DMAChannel::release()+0x2c>)
	*p++ = 0;
	*p++ = 0;
}

void DMAChannel::release(void)
{
    67f0:	b410      	push	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
    67f2:	7013      	strb	r3, [r2, #0]
	__disable_irq();
    67f4:	b672      	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    67f6:	4908      	ldr	r1, [pc, #32]	; (6818 <DMAChannel::release()+0x30>)
    67f8:	7904      	ldrb	r4, [r0, #4]
    67fa:	880a      	ldrh	r2, [r1, #0]
    67fc:	2301      	movs	r3, #1
    67fe:	40a3      	lsls	r3, r4
    6800:	ea22 0303 	bic.w	r3, r2, r3
    6804:	800b      	strh	r3, [r1, #0]
	__enable_irq();
    6806:	b662      	cpsie	i
	channel = DMA_MAX_CHANNELS;
    6808:	2210      	movs	r2, #16
	TCD = (TCD_t *)0;
    680a:	2300      	movs	r3, #0
}
    680c:	bc10      	pop	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
	__disable_irq();
	dma_channel_allocated_mask &= ~(1 << channel);
	__enable_irq();
	channel = DMA_MAX_CHANNELS;
    680e:	7102      	strb	r2, [r0, #4]
	TCD = (TCD_t *)0;
    6810:	6003      	str	r3, [r0, #0]
}
    6812:	4770      	bx	lr
    6814:	4000801a 	.word	0x4000801a
    6818:	1fffb5de 	.word	0x1fffb5de

0000681c <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    681c:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    681e:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    6822:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    6824:	4c0c      	ldr	r4, [pc, #48]	; (6858 <EventResponder::runFromInterrupt()+0x3c>)
    6826:	6820      	ldr	r0, [r4, #0]
		if (first) {
    6828:	b180      	cbz	r0, 684c <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    682a:	4e0c      	ldr	r6, [pc, #48]	; (685c <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    682c:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    682e:	6943      	ldr	r3, [r0, #20]
    6830:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    6832:	b173      	cbz	r3, 6852 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    6834:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6836:	b902      	cbnz	r2, 683a <EventResponder::runFromInterrupt()+0x1e>
    6838:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    683a:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    683c:	6883      	ldr	r3, [r0, #8]
    683e:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    6840:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    6844:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    6846:	6820      	ldr	r0, [r4, #0]
		if (first) {
    6848:	2800      	cmp	r0, #0
    684a:	d1f0      	bne.n	682e <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    684c:	b902      	cbnz	r2, 6850 <EventResponder::runFromInterrupt()+0x34>
    684e:	b662      	cpsie	i
    6850:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    6852:	6033      	str	r3, [r6, #0]
    6854:	e7ef      	b.n	6836 <EventResponder::runFromInterrupt()+0x1a>
    6856:	bf00      	nop
    6858:	1fffb5e0 	.word	0x1fffb5e0
    685c:	1fffb5e4 	.word	0x1fffb5e4

00006860 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    6860:	f7ff bfdc 	b.w	681c <EventResponder::runFromInterrupt()>

00006864 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    6864:	4a02      	ldr	r2, [pc, #8]	; (6870 <systick_isr+0xc>)
    6866:	6813      	ldr	r3, [r2, #0]
    6868:	3301      	adds	r3, #1
    686a:	6013      	str	r3, [r2, #0]
    686c:	4770      	bx	lr
    686e:	bf00      	nop
    6870:	1fffb440 	.word	0x1fffb440

00006874 <HardwareSerial::write(unsigned long)>:
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
 	virtual void addMemoryForRead(void *buffer, size_t length) {serial_add_memory_for_read(buffer, length);}
	virtual void addMemoryForWrite(void *buffer, size_t length){serial_add_memory_for_write(buffer, length);}
	using Print::write;
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
    6874:	6803      	ldr	r3, [r0, #0]
    6876:	b2c9      	uxtb	r1, r1
    6878:	681b      	ldr	r3, [r3, #0]
    687a:	4718      	bx	r3

0000687c <HardwareSerial::write(long)>:
	virtual size_t write(long n)            { return write((uint8_t)n); }
    687c:	6803      	ldr	r3, [r0, #0]
    687e:	b2c9      	uxtb	r1, r1
    6880:	681b      	ldr	r3, [r3, #0]
    6882:	4718      	bx	r3

00006884 <HardwareSerial::write(unsigned int)>:
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
    6884:	6803      	ldr	r3, [r0, #0]
    6886:	b2c9      	uxtb	r1, r1
    6888:	681b      	ldr	r3, [r3, #0]
    688a:	4718      	bx	r3

0000688c <HardwareSerial::write(int)>:
	virtual size_t write(int n)             { return write((uint8_t)n); }
    688c:	6803      	ldr	r3, [r0, #0]
    688e:	b2c9      	uxtb	r1, r1
    6890:	681b      	ldr	r3, [r3, #0]
    6892:	4718      	bx	r3

00006894 <HardwareSerial::begin(unsigned long)>:
uint8_t _serialEvent1_default __attribute__((weak)) PROGMEM = 0 ;

HardwareSerial Serial1(&serialEvent1);

void HardwareSerial::begin(uint32_t baud) { 
	serial_begin(BAUD2DIV(baud)); 
    6894:	084b      	lsrs	r3, r1, #1
    6896:	f103 6337 	add.w	r3, r3, #191889408	; 0xb700000
    689a:	f503 33d8 	add.w	r3, r3, #110592	; 0x1b000

uint8_t _serialEvent1_default __attribute__((weak)) PROGMEM = 0 ;

HardwareSerial Serial1(&serialEvent1);

void HardwareSerial::begin(uint32_t baud) { 
    689e:	b510      	push	{r4, lr}
    68a0:	4604      	mov	r4, r0
	serial_begin(BAUD2DIV(baud)); 
    68a2:	fbb3 f0f1 	udiv	r0, r3, r1
    68a6:	f7fe fc03 	bl	50b0 <serial_begin>
	if (!_serialEvent1_default) addToSerialEventsList();
    68aa:	4b04      	ldr	r3, [pc, #16]	; (68bc <HardwareSerial::begin(unsigned long)+0x28>)
    68ac:	781b      	ldrb	r3, [r3, #0]
    68ae:	b103      	cbz	r3, 68b2 <HardwareSerial::begin(unsigned long)+0x1e>
    68b0:	bd10      	pop	{r4, pc}
    68b2:	4620      	mov	r0, r4
}
    68b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

HardwareSerial Serial1(&serialEvent1);

void HardwareSerial::begin(uint32_t baud) { 
	serial_begin(BAUD2DIV(baud)); 
	if (!_serialEvent1_default) addToSerialEventsList();
    68b8:	f000 bc42 	b.w	7140 <HardwareSerial::addToSerialEventsList()>
    68bc:	1fffb5f1 	.word	0x1fffb5f1

000068c0 <HardwareSerial::write9bit(unsigned long)>:
	virtual size_t write(const uint8_t *buffer, size_t size)
					{ serial_write(buffer, size); return size; }
        virtual size_t write(const char *str)	{ size_t len = strlen(str);
					  serial_write((const uint8_t *)str, len);
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
    68c0:	b508      	push	{r3, lr}
    68c2:	4608      	mov	r0, r1
    68c4:	f7fe fde8 	bl	5498 <serial_putchar>
    68c8:	2001      	movs	r0, #1
    68ca:	bd08      	pop	{r3, pc}

000068cc <HardwareSerial::write(unsigned char)>:
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
 	virtual void addMemoryForRead(void *buffer, size_t length) {serial_add_memory_for_read(buffer, length);}
	virtual void addMemoryForWrite(void *buffer, size_t length){serial_add_memory_for_write(buffer, length);}
	using Print::write;
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
    68cc:	b508      	push	{r3, lr}
    68ce:	4608      	mov	r0, r1
    68d0:	f7fe fde2 	bl	5498 <serial_putchar>
    68d4:	2001      	movs	r0, #1
    68d6:	bd08      	pop	{r3, pc}

000068d8 <HardwareSerial::write(char const*)>:
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
					{ serial_write(buffer, size); return size; }
        virtual size_t write(const char *str)	{ size_t len = strlen(str);
    68d8:	b538      	push	{r3, r4, r5, lr}
    68da:	4608      	mov	r0, r1
    68dc:	460d      	mov	r5, r1
    68de:	f002 f90f 	bl	8b00 <strlen>
    68e2:	4604      	mov	r4, r0
					  serial_write((const uint8_t *)str, len);
    68e4:	4601      	mov	r1, r0
    68e6:	4628      	mov	r0, r5
    68e8:	f7fe fde0 	bl	54ac <serial_write>
					  return len; }
    68ec:	4620      	mov	r0, r4
    68ee:	bd38      	pop	{r3, r4, r5, pc}

000068f0 <HardwareSerial::write(unsigned char const*, unsigned int)>:
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
    68f0:	b510      	push	{r4, lr}
					{ serial_write(buffer, size); return size; }
    68f2:	4608      	mov	r0, r1
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
    68f4:	4614      	mov	r4, r2
					{ serial_write(buffer, size); return size; }
    68f6:	4611      	mov	r1, r2
    68f8:	f7fe fdd8 	bl	54ac <serial_write>
    68fc:	4620      	mov	r0, r4
    68fe:	bd10      	pop	{r4, pc}

00006900 <HardwareSerial::addMemoryForWrite(void*, unsigned int)>:
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
 	virtual void addMemoryForRead(void *buffer, size_t length) {serial_add_memory_for_read(buffer, length);}
	virtual void addMemoryForWrite(void *buffer, size_t length){serial_add_memory_for_write(buffer, length);}
    6900:	4608      	mov	r0, r1
    6902:	4611      	mov	r1, r2
    6904:	f7ff b802 	b.w	590c <serial_add_memory_for_write>

00006908 <HardwareSerial::addMemoryForRead(void*, unsigned int)>:
	virtual int peek(void)          { return serial_peek(); }
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
 	virtual void addMemoryForRead(void *buffer, size_t length) {serial_add_memory_for_read(buffer, length);}
    6908:	4608      	mov	r0, r1
    690a:	4611      	mov	r1, r2
    690c:	f7fe bfe4 	b.w	58d8 <serial_add_memory_for_read>

00006910 <HardwareSerial::clear()>:
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
	virtual int peek(void)          { return serial_peek(); }
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
	virtual void clear(void)	{ serial_clear(); }
    6910:	f7fe befa 	b.w	5708 <serial_clear>

00006914 <HardwareSerial::attachCts(unsigned char)>:
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
    6914:	b508      	push	{r3, lr}
    6916:	4608      	mov	r0, r1
    6918:	f7fe fd96 	bl	5448 <serial_set_cts>
    691c:	3000      	adds	r0, #0
    691e:	bf18      	it	ne
    6920:	2001      	movne	r0, #1
    6922:	bd08      	pop	{r3, pc}

00006924 <HardwareSerial::attachRts(unsigned char)>:
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
    6924:	b508      	push	{r3, lr}
    6926:	4608      	mov	r0, r1
    6928:	f7fe fd6c 	bl	5404 <serial_set_rts>
    692c:	3000      	adds	r0, #0
    692e:	bf18      	it	ne
    6930:	2001      	movne	r0, #1
    6932:	bd08      	pop	{r3, pc}

00006934 <HardwareSerial::setTX(unsigned char, bool)>:
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
    6934:	4608      	mov	r0, r1
    6936:	4611      	mov	r1, r2
    6938:	f7fe bd00 	b.w	533c <serial_set_tx>

0000693c <HardwareSerial::setRX(unsigned char)>:
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
    693c:	4608      	mov	r0, r1
    693e:	f7fe bd37 	b.w	53b0 <serial_set_rx>
    6942:	bf00      	nop

00006944 <HardwareSerial::transmitterEnable(unsigned char)>:
	virtual void begin(uint32_t baud);
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
    6944:	4608      	mov	r0, r1
    6946:	f7fe bcdd 	b.w	5304 <serial_set_transmit_pin>
    694a:	bf00      	nop

0000694c <HardwareSerial::end()>:
	#endif
	virtual void begin(uint32_t baud);
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
    694c:	f7fe bc78 	b.w	5240 <serial_end>

00006950 <HardwareSerial::begin(unsigned long, unsigned long)>:
	enum {CNT_HARDWARE_SERIAL = 6};
	#else //(__MK64FX512__) || defined(__MK66FX1M0__) 
	enum {CNT_HARDWARE_SERIAL = 3};
	#endif
	virtual void begin(uint32_t baud);
	virtual void begin(uint32_t baud, uint32_t format) {
    6950:	b510      	push	{r4, lr}
					  serial_begin(BAUD2DIV(baud));
    6952:	084b      	lsrs	r3, r1, #1
    6954:	f103 6037 	add.w	r0, r3, #191889408	; 0xb700000
	enum {CNT_HARDWARE_SERIAL = 6};
	#else //(__MK64FX512__) || defined(__MK66FX1M0__) 
	enum {CNT_HARDWARE_SERIAL = 3};
	#endif
	virtual void begin(uint32_t baud);
	virtual void begin(uint32_t baud, uint32_t format) {
    6958:	4614      	mov	r4, r2
					  serial_begin(BAUD2DIV(baud));
    695a:	f500 30d8 	add.w	r0, r0, #110592	; 0x1b000
    695e:	fbb0 f0f1 	udiv	r0, r0, r1
    6962:	f7fe fba5 	bl	50b0 <serial_begin>
					  serial_format(format); }
    6966:	4620      	mov	r0, r4
    6968:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    696c:	f7fe bc16 	b.w	519c <serial_format>

00006970 <HardwareSerial::peek()>:
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
	virtual int peek(void)          { return serial_peek(); }
    6970:	f7fe bea4 	b.w	56bc <serial_peek>

00006974 <HardwareSerial::read()>:
	virtual int read(void)          { return serial_getchar(); }
    6974:	f7fe be62 	b.w	563c <serial_getchar>

00006978 <HardwareSerial::available()>:
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    6978:	f7fe be4c 	b.w	5614 <serial_available>

0000697c <HardwareSerial::flush()>:
	virtual int peek(void)          { return serial_peek(); }
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
    697c:	f7fe be26 	b.w	55cc <serial_flush>

00006980 <HardwareSerial::availableForWrite()>:
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
    6980:	f7fe be30 	b.w	55e4 <serial_write_buffer_free>

00006984 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    6984:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    6986:	f7fb f867 	bl	1a58 <setup>
	while (1) {
		loop();
    698a:	f7fa ff3d 	bl	1808 <loop>
		yield();
    698e:	f000 fa59 	bl	6e44 <yield>
    6992:	e7fa      	b.n	698a <main+0x6>

00006994 <operator new(unsigned int)>:
    6994:	f001 b936 	b.w	7c04 <malloc>

00006998 <Print::print(String const&)>:
	return count;
}


size_t Print::print(const String &s)
{
    6998:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    699c:	688c      	ldr	r4, [r1, #8]
    699e:	b08b      	sub	sp, #44	; 0x2c
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    69a0:	b1ec      	cbz	r4, 69de <Print::print(String const&)+0x46>
    69a2:	2500      	movs	r5, #0
    69a4:	4606      	mov	r6, r0
    69a6:	4689      	mov	r9, r1
    69a8:	462f      	mov	r7, r5
		s.getBytes(buffer, sizeof(buffer), index);
    69aa:	462b      	mov	r3, r5
    69ac:	2221      	movs	r2, #33	; 0x21
    69ae:	a901      	add	r1, sp, #4
    69b0:	4648      	mov	r0, r9
    69b2:	f000 fa03 	bl	6dbc <String::getBytes(unsigned char*, unsigned int, unsigned int) const>
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
    69b6:	6832      	ldr	r2, [r6, #0]
    69b8:	2c20      	cmp	r4, #32
    69ba:	4623      	mov	r3, r4
    69bc:	bf28      	it	cs
    69be:	2320      	movcs	r3, #32
    69c0:	f8d2 8004 	ldr.w	r8, [r2, #4]
    69c4:	a901      	add	r1, sp, #4
    69c6:	461a      	mov	r2, r3
    69c8:	4630      	mov	r0, r6
	unsigned int len = s.length();
	while (len > 0) {
		s.getBytes(buffer, sizeof(buffer), index);
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
    69ca:	441d      	add	r5, r3
		len -= nbytes;
    69cc:	1ae4      	subs	r4, r4, r3
		count += write(buffer, nbytes);
    69ce:	47c0      	blx	r8
    69d0:	4407      	add	r7, r0
{
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    69d2:	2c00      	cmp	r4, #0
    69d4:	d1e9      	bne.n	69aa <Print::print(String const&)+0x12>
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
	}
	return count;
}
    69d6:	4638      	mov	r0, r7
    69d8:	b00b      	add	sp, #44	; 0x2c
    69da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}


size_t Print::print(const String &s)
{
	uint8_t buffer[33];
	size_t count = 0;
    69de:	4627      	mov	r7, r4
    69e0:	e7f9      	b.n	69d6 <Print::print(String const&)+0x3e>
    69e2:	bf00      	nop

000069e4 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    69e4:	b530      	push	{r4, r5, lr}
    69e6:	4604      	mov	r4, r0
    69e8:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    69ea:	2502      	movs	r5, #2
    69ec:	462a      	mov	r2, r5
    69ee:	a801      	add	r0, sp, #4
    69f0:	4905      	ldr	r1, [pc, #20]	; (6a08 <Print::println()+0x24>)
    69f2:	f7fd fec3 	bl	477c <memcpy>
	return write(buf, 2);
    69f6:	6823      	ldr	r3, [r4, #0]
    69f8:	462a      	mov	r2, r5
    69fa:	a901      	add	r1, sp, #4
    69fc:	685b      	ldr	r3, [r3, #4]
    69fe:	4620      	mov	r0, r4
    6a00:	4798      	blx	r3
}
    6a02:	b003      	add	sp, #12
    6a04:	bd30      	pop	{r4, r5, pc}
    6a06:	bf00      	nop
    6a08:	00009698 	.word	0x00009698

00006a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    6a0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    6a0e:	4607      	mov	r7, r0
    6a10:	b08b      	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    6a12:	2a00      	cmp	r2, #0
    6a14:	d033      	beq.n	6a7e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    6a16:	2a01      	cmp	r2, #1
    6a18:	bf08      	it	eq
    6a1a:	220a      	moveq	r2, #10
	}


	if (n == 0) {
    6a1c:	b351      	cbz	r1, 6a74 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    6a1e:	2421      	movs	r4, #33	; 0x21
    6a20:	e000      	b.n	6a24 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    6a22:	b2f4      	uxtb	r4, r6
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    6a24:	fbb1 f5f2 	udiv	r5, r1, r2
    6a28:	fb02 1115 	mls	r1, r2, r5, r1
    6a2c:	b2c8      	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    6a2e:	2909      	cmp	r1, #9
    6a30:	f100 0130 	add.w	r1, r0, #48	; 0x30
    6a34:	bf98      	it	ls
    6a36:	b2c8      	uxtbls	r0, r1
    6a38:	a90a      	add	r1, sp, #40	; 0x28
    6a3a:	bf88      	it	hi
    6a3c:	3037      	addhi	r0, #55	; 0x37
    6a3e:	4421      	add	r1, r4
    6a40:	bf88      	it	hi
    6a42:	b2c0      	uxtbhi	r0, r0
    6a44:	f801 0c24 	strb.w	r0, [r1, #-36]
			n /= base;
			if (n == 0) break;
			i--;
    6a48:	1e66      	subs	r6, r4, #1
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    6a4a:	4629      	mov	r1, r5
    6a4c:	2d00      	cmp	r5, #0
    6a4e:	d1e8      	bne.n	6a22 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    6a50:	b133      	cbz	r3, 6a60 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    6a52:	3c01      	subs	r4, #1
    6a54:	b2e4      	uxtb	r4, r4
		buf[i] = '-';
    6a56:	ab0a      	add	r3, sp, #40	; 0x28
    6a58:	4423      	add	r3, r4
    6a5a:	222d      	movs	r2, #45	; 0x2d
    6a5c:	f803 2c24 	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    6a60:	683b      	ldr	r3, [r7, #0]
    6a62:	aa01      	add	r2, sp, #4
    6a64:	1911      	adds	r1, r2, r4
    6a66:	685b      	ldr	r3, [r3, #4]
    6a68:	4638      	mov	r0, r7
    6a6a:	f1c4 0222 	rsb	r2, r4, #34	; 0x22
    6a6e:	4798      	blx	r3
}
    6a70:	b00b      	add	sp, #44	; 0x2c
    6a72:	bdf0      	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    6a74:	2230      	movs	r2, #48	; 0x30
    6a76:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    6a7a:	2421      	movs	r4, #33	; 0x21
    6a7c:	e7e8      	b.n	6a50 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    6a7e:	6803      	ldr	r3, [r0, #0]
    6a80:	b2c9      	uxtb	r1, r1
    6a82:	681b      	ldr	r3, [r3, #0]
    6a84:	4798      	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    6a86:	b00b      	add	sp, #44	; 0x2c
    6a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6a8a:	bf00      	nop

00006a8c <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    6a8c:	2900      	cmp	r1, #0
		sign = '-';
		n = -n;
    6a8e:	bfba      	itte	lt
    6a90:	4249      	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    6a92:	232d      	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    6a94:	2300      	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    6a96:	220a      	movs	r2, #10
    6a98:	f7ff bfb8 	b.w	6a0c <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00006a9c <usb_serial_class::clear()>:
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    6a9c:	f7ff bd20 	b.w	64e0 <usb_serial_flush_input>

00006aa0 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    6aa0:	f7ff bcf8 	b.w	6494 <usb_serial_peekchar>

00006aa4 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    6aa4:	f7ff bcd2 	b.w	644c <usb_serial_getchar>

00006aa8 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    6aa8:	f7ff bd0c 	b.w	64c4 <usb_serial_available>

00006aac <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6aac:	f7ff bde8 	b.w	6680 <usb_serial_flush_output>

00006ab0 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    6ab0:	f7ff bdc2 	b.w	6638 <usb_serial_write_buffer_free>

00006ab4 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    6ab4:	4608      	mov	r0, r1
    6ab6:	4611      	mov	r1, r2
    6ab8:	f7ff bd2e 	b.w	6518 <usb_serial_write>

00006abc <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    6abc:	4608      	mov	r0, r1
    6abe:	f7ff bdaf 	b.w	6620 <usb_serial_putchar>
    6ac2:	bf00      	nop

00006ac4 <random(unsigned long) [clone .part.0]>:
	if (x < 0) x += 0x7FFFFFFF;
	seed = x;
	return x;
}

uint32_t random(uint32_t howbig)
    6ac4:	b5f0      	push	{r4, r5, r6, r7, lr}
int32_t random(void)
{
	int32_t hi, lo, x;

	// the algorithm used in avr-libc 1.6.4
	x = seed;
    6ac6:	4d16      	ldr	r5, [pc, #88]	; (6b20 <random(unsigned long) [clone .part.0]+0x5c>)
    6ac8:	682a      	ldr	r2, [r5, #0]
	if (x == 0) x = 123459876;
    6aca:	b30a      	cbz	r2, 6b10 <random(unsigned long) [clone .part.0]+0x4c>
	hi = x / 127773;
	lo = x % 127773;
	x = 16807 * lo - 2836 * hi;
    6acc:	4915      	ldr	r1, [pc, #84]	; (6b24 <random(unsigned long) [clone .part.0]+0x60>)
    6ace:	4b16      	ldr	r3, [pc, #88]	; (6b28 <random(unsigned long) [clone .part.0]+0x64>)
    6ad0:	f8df e05c 	ldr.w	lr, [pc, #92]	; 6b30 <random(unsigned long) [clone .part.0]+0x6c>
    6ad4:	fb82 6701 	smull	r6, r7, r2, r1
    6ad8:	fb81 1402 	smull	r1, r4, r1, r2
    6adc:	17d6      	asrs	r6, r2, #31
    6ade:	19d1      	adds	r1, r2, r7
    6ae0:	4414      	add	r4, r2
    6ae2:	ebc6 4121 	rsb	r1, r6, r1, asr #16
    6ae6:	ebc6 4424 	rsb	r4, r6, r4, asr #16
    6aea:	fb03 f404 	mul.w	r4, r3, r4
    6aee:	fb0e 2211 	mls	r2, lr, r1, r2
    6af2:	f244 13a7 	movw	r3, #16807	; 0x41a7
    6af6:	fb03 4302 	mla	r3, r3, r2, r4
	if (x < 0) x += 0x7FFFFFFF;
    6afa:	2b00      	cmp	r3, #0
    6afc:	da02      	bge.n	6b04 <random(unsigned long) [clone .part.0]+0x40>
    6afe:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    6b02:	3b01      	subs	r3, #1
    6b04:	fbb3 f2f0 	udiv	r2, r3, r0
	seed = x;
    6b08:	602b      	str	r3, [r5, #0]

uint32_t random(uint32_t howbig)
{
	if (howbig == 0) return 0;
	return random() % howbig;
}
    6b0a:	fb00 3012 	mls	r0, r0, r2, r3
    6b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	int32_t hi, lo, x;

	// the algorithm used in avr-libc 1.6.4
	x = seed;
	if (x == 0) x = 123459876;
    6b10:	4b06      	ldr	r3, [pc, #24]	; (6b2c <random(unsigned long) [clone .part.0]+0x68>)
	hi = x / 127773;
	lo = x % 127773;
	x = 16807 * lo - 2836 * hi;
	if (x < 0) x += 0x7FFFFFFF;
	seed = x;
    6b12:	602b      	str	r3, [r5, #0]
    6b14:	fbb3 f2f0 	udiv	r2, r3, r0

uint32_t random(uint32_t howbig)
{
	if (howbig == 0) return 0;
	return random() % howbig;
}
    6b18:	fb00 3012 	mls	r0, r0, r2, r3
    6b1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6b1e:	bf00      	nop
    6b20:	1fffb5f4 	.word	0x1fffb5f4
    6b24:	834e0b5f 	.word	0x834e0b5f
    6b28:	fffff4ec 	.word	0xfffff4ec
    6b2c:	1f0cce42 	.word	0x1f0cce42
    6b30:	0001f31d 	.word	0x0001f31d

00006b34 <random(unsigned long)>:
	return x;
}

uint32_t random(uint32_t howbig)
{
	if (howbig == 0) return 0;
    6b34:	b108      	cbz	r0, 6b3a <random(unsigned long)+0x6>
    6b36:	f7ff bfc5 	b.w	6ac4 <random(unsigned long) [clone .part.0]>
	return random() % howbig;
}
    6b3a:	4770      	bx	lr

00006b3c <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    6b3c:	b510      	push	{r4, lr}
    6b3e:	4604      	mov	r4, r0
{
	free(buffer);
    6b40:	6800      	ldr	r0, [r0, #0]
    6b42:	f001 f867 	bl	7c14 <free>
}
    6b46:	4620      	mov	r0, r4
    6b48:	bd10      	pop	{r4, pc}
    6b4a:	bf00      	nop

00006b4c <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    6b4c:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    6b4e:	6843      	ldr	r3, [r0, #4]
    6b50:	428b      	cmp	r3, r1
    6b52:	d301      	bcc.n	6b58 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6b54:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    6b56:	bd38      	pop	{r3, r4, r5, pc}
    6b58:	460d      	mov	r5, r1
    6b5a:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    6b5c:	3101      	adds	r1, #1
    6b5e:	6800      	ldr	r0, [r0, #0]
    6b60:	f001 fbe4 	bl	832c <realloc>
	if (newbuffer) {
    6b64:	2800      	cmp	r0, #0
    6b66:	d0f6      	beq.n	6b56 <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6b68:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    6b6a:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6b6e:	2b00      	cmp	r3, #0
    6b70:	d1f0      	bne.n	6b54 <String::reserve(unsigned int)+0x8>
    6b72:	7003      	strb	r3, [r0, #0]
    6b74:	e7ee      	b.n	6b54 <String::reserve(unsigned int)+0x8>
    6b76:	bf00      	nop

00006b78 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    6b78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6b7a:	4604      	mov	r4, r0
	if (length == 0) {
    6b7c:	4615      	mov	r5, r2
    6b7e:	b932      	cbnz	r2, 6b8e <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    6b80:	6803      	ldr	r3, [r0, #0]
    6b82:	b103      	cbz	r3, 6b86 <String::copy(char const*, unsigned int)+0xe>
    6b84:	701a      	strb	r2, [r3, #0]
		len = 0;
    6b86:	2300      	movs	r3, #0
    6b88:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    6b8a:	4620      	mov	r0, r4
    6b8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6b8e:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    6b90:	4611      	mov	r1, r2
    6b92:	f7ff ffdb 	bl	6b4c <String::reserve(unsigned int)>
    6b96:	4607      	mov	r7, r0
    6b98:	b948      	cbnz	r0, 6bae <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    6b9a:	6820      	ldr	r0, [r4, #0]
    6b9c:	b110      	cbz	r0, 6ba4 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    6b9e:	f001 f839 	bl	7c14 <free>
			buffer = NULL;
    6ba2:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    6ba4:	2300      	movs	r3, #0
    6ba6:	6063      	str	r3, [r4, #4]
    6ba8:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    6baa:	4620      	mov	r0, r4
    6bac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    6bae:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    6bb0:	4631      	mov	r1, r6
    6bb2:	6820      	ldr	r0, [r4, #0]
    6bb4:	f001 ff32 	bl	8a1c <strcpy>
	return *this;
    6bb8:	e7e7      	b.n	6b8a <String::copy(char const*, unsigned int)+0x12>
    6bba:	bf00      	nop

00006bbc <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    6bbc:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6bbe:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    6bc0:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6bc2:	6003      	str	r3, [r0, #0]
	capacity = 0;
    6bc4:	6043      	str	r3, [r0, #4]
	len = 0;
    6bc6:	6083      	str	r3, [r0, #8]
	flags = 0;
    6bc8:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    6bca:	b141      	cbz	r1, 6bde <String::String(char const*)+0x22>
    6bcc:	4608      	mov	r0, r1
    6bce:	460d      	mov	r5, r1
    6bd0:	f001 ff96 	bl	8b00 <strlen>
    6bd4:	4629      	mov	r1, r5
    6bd6:	4602      	mov	r2, r0
    6bd8:	4620      	mov	r0, r4
    6bda:	f7ff ffcd 	bl	6b78 <String::copy(char const*, unsigned int)>
}
    6bde:	4620      	mov	r0, r4
    6be0:	bd38      	pop	{r3, r4, r5, pc}
    6be2:	bf00      	nop

00006be4 <String::String(__FlashStringHelper const*)>:

String::String(const __FlashStringHelper *pgmstr)
    6be4:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6be6:	2300      	movs	r3, #0
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
}

String::String(const __FlashStringHelper *pgmstr)
    6be8:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6bea:	6003      	str	r3, [r0, #0]
	capacity = 0;
    6bec:	6043      	str	r3, [r0, #4]
	len = 0;
    6bee:	6083      	str	r3, [r0, #8]
	flags = 0;
    6bf0:	7303      	strb	r3, [r0, #12]
	unsigned char reserve(unsigned int size);
	inline unsigned int length(void) const {return len;}

	// copy and move
	String & copy(const char *cstr, unsigned int length);
	String & copy(const __FlashStringHelper *s) { return copy((const char *)s, strlen((const char *)s)); }
    6bf2:	4608      	mov	r0, r1
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
}

String::String(const __FlashStringHelper *pgmstr)
    6bf4:	460d      	mov	r5, r1
    6bf6:	f001 ff83 	bl	8b00 <strlen>
    6bfa:	4629      	mov	r1, r5
    6bfc:	4602      	mov	r2, r0
    6bfe:	4620      	mov	r0, r4
    6c00:	f7ff ffba 	bl	6b78 <String::copy(char const*, unsigned int)>
{
	init();
	*this = pgmstr;
}
    6c04:	4620      	mov	r0, r4
    6c06:	bd38      	pop	{r3, r4, r5, pc}

00006c08 <String::String(String const&)>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6c08:	2300      	movs	r3, #0
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    6c0a:	4288      	cmp	r0, r1
{
	init();
	*this = pgmstr;
}

String::String(const String &value)
    6c0c:	b510      	push	{r4, lr}
    6c0e:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6c10:	6003      	str	r3, [r0, #0]
	capacity = 0;
    6c12:	6043      	str	r3, [r0, #4]
	len = 0;
    6c14:	6083      	str	r3, [r0, #8]
	flags = 0;
    6c16:	7303      	strb	r3, [r0, #12]
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    6c18:	d003      	beq.n	6c22 <String::String(String const&)+0x1a>
	return copy(rhs.buffer, rhs.len);
    6c1a:	688a      	ldr	r2, [r1, #8]
    6c1c:	6809      	ldr	r1, [r1, #0]
    6c1e:	f7ff ffab 	bl	6b78 <String::copy(char const*, unsigned int)>

String::String(const String &value)
{
	init();
	*this = value;
}
    6c22:	4620      	mov	r0, r4
    6c24:	bd10      	pop	{r4, pc}
    6c26:	bf00      	nop

00006c28 <String::operator=(char const*) [clone .part.2]>:
	if (this != &rval) move(rval);
	return *this;
}
#endif

String & String::operator = (const char *cstr)
    6c28:	b538      	push	{r3, r4, r5, lr}
    6c2a:	4605      	mov	r5, r0
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    6c2c:	4608      	mov	r0, r1
	if (this != &rval) move(rval);
	return *this;
}
#endif

String & String::operator = (const char *cstr)
    6c2e:	460c      	mov	r4, r1
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    6c30:	f001 ff66 	bl	8b00 <strlen>
    6c34:	4621      	mov	r1, r4
    6c36:	4602      	mov	r2, r0
    6c38:	4628      	mov	r0, r5
	} else {
		len = 0;
	}
	return *this;
}
    6c3a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    6c3e:	f7ff bf9b 	b.w	6b78 <String::copy(char const*, unsigned int)>
    6c42:	bf00      	nop

00006c44 <String::operator=(String const&)>:
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    6c44:	4281      	cmp	r1, r0
    6c46:	d003      	beq.n	6c50 <String::operator=(String const&)+0xc>
	return copy(rhs.buffer, rhs.len);
    6c48:	688a      	ldr	r2, [r1, #8]
    6c4a:	6809      	ldr	r1, [r1, #0]
    6c4c:	f7ff bf94 	b.w	6b78 <String::copy(char const*, unsigned int)>
}
    6c50:	4770      	bx	lr
    6c52:	bf00      	nop

00006c54 <String::operator=(char const*)>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
    6c54:	b510      	push	{r4, lr}
    6c56:	4604      	mov	r4, r0
	if (cstr) {
    6c58:	b119      	cbz	r1, 6c62 <String::operator=(char const*)+0xe>
    6c5a:	f7ff ffe5 	bl	6c28 <String::operator=(char const*) [clone .part.2]>
		copy(cstr, strlen(cstr));
	} else {
		len = 0;
	}
	return *this;
}
    6c5e:	4620      	mov	r0, r4
    6c60:	bd10      	pop	{r4, pc}
String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
	} else {
		len = 0;
    6c62:	60a1      	str	r1, [r4, #8]
	}
	return *this;
}
    6c64:	4620      	mov	r0, r4
    6c66:	bd10      	pop	{r4, pc}

00006c68 <String::append(char const*, unsigned int)>:
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    6c68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    6c6c:	6803      	ldr	r3, [r0, #0]
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    6c6e:	460f      	mov	r7, r1
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    6c70:	42bb      	cmp	r3, r7
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    6c72:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
    6c74:	6881      	ldr	r1, [r0, #8]
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    6c76:	4615      	mov	r5, r2
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    6c78:	d80a      	bhi.n	6c90 <String::append(char const*, unsigned int)+0x28>
    6c7a:	185a      	adds	r2, r3, r1
    6c7c:	4297      	cmp	r7, r2
    6c7e:	d207      	bcs.n	6c90 <String::append(char const*, unsigned int)+0x28>
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
    6c80:	ebc3 0907 	rsb	r9, r3, r7
{
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
    6c84:	f04f 0801 	mov.w	r8, #1
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    6c88:	b935      	cbnz	r5, 6c98 <String::append(char const*, unsigned int)+0x30>
		}
	else
		strcpy(buffer + len, cstr);
	len = newlen;
	return *this;
}
    6c8a:	4620      	mov	r0, r4
    6c8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	bool self = false;
    6c90:	f04f 0800 	mov.w	r8, #0
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    6c94:	2d00      	cmp	r5, #0
    6c96:	d0f8      	beq.n	6c8a <String::append(char const*, unsigned int)+0x22>
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
    6c98:	194e      	adds	r6, r1, r5
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    6c9a:	4631      	mov	r1, r6
    6c9c:	4620      	mov	r0, r4
    6c9e:	f7ff ff55 	bl	6b4c <String::reserve(unsigned int)>
    6ca2:	2800      	cmp	r0, #0
    6ca4:	d0f1      	beq.n	6c8a <String::append(char const*, unsigned int)+0x22>
	if ( self ) {
    6ca6:	f1b8 0f00 	cmp.w	r8, #0
    6caa:	d00e      	beq.n	6cca <String::append(char const*, unsigned int)+0x62>
		memcpy(buffer + len, buffer+buffer_offset, length);
    6cac:	6823      	ldr	r3, [r4, #0]
    6cae:	68a0      	ldr	r0, [r4, #8]
    6cb0:	462a      	mov	r2, r5
    6cb2:	eb03 0109 	add.w	r1, r3, r9
    6cb6:	4418      	add	r0, r3
    6cb8:	f7fd fd60 	bl	477c <memcpy>
		buffer[newlen] = 0;
    6cbc:	6823      	ldr	r3, [r4, #0]
    6cbe:	2200      	movs	r2, #0
    6cc0:	559a      	strb	r2, [r3, r6]
		}
	else
		strcpy(buffer + len, cstr);
	len = newlen;
    6cc2:	60a6      	str	r6, [r4, #8]
	return *this;
}
    6cc4:	4620      	mov	r0, r4
    6cc6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ( self ) {
		memcpy(buffer + len, buffer+buffer_offset, length);
		buffer[newlen] = 0;
		}
	else
		strcpy(buffer + len, cstr);
    6cca:	6820      	ldr	r0, [r4, #0]
    6ccc:	68a3      	ldr	r3, [r4, #8]
    6cce:	4639      	mov	r1, r7
    6cd0:	4418      	add	r0, r3
    6cd2:	f001 fea3 	bl	8a1c <strcpy>
    6cd6:	e7f4      	b.n	6cc2 <String::append(char const*, unsigned int)+0x5a>

00006cd8 <String::append(char)>:
	if (cstr) append(cstr, strlen(cstr));
	return *this;
}

String & String::append(char c)
{
    6cd8:	b510      	push	{r4, lr}
    6cda:	b082      	sub	sp, #8
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
    6cdc:	2300      	movs	r3, #0
}

String & String::append(char c)
{
	char buf[2];
	buf[0] = c;
    6cde:	f88d 1004 	strb.w	r1, [sp, #4]
	buf[1] = 0;
	append(buf, 1);
    6ce2:	2201      	movs	r2, #1
    6ce4:	a901      	add	r1, sp, #4
	if (cstr) append(cstr, strlen(cstr));
	return *this;
}

String & String::append(char c)
{
    6ce6:	4604      	mov	r4, r0
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
    6ce8:	f88d 3005 	strb.w	r3, [sp, #5]
	append(buf, 1);
    6cec:	f7ff ffbc 	bl	6c68 <String::append(char const*, unsigned int)>
	return *this;
}
    6cf0:	4620      	mov	r0, r4
    6cf2:	b002      	add	sp, #8
    6cf4:	bd10      	pop	{r4, pc}
    6cf6:	bf00      	nop

00006cf8 <String::append(long)>:
	append(buf, strlen(buf));
	return *this;
}

String & String::append(long num)
{
    6cf8:	b510      	push	{r4, lr}
    6cfa:	460b      	mov	r3, r1
    6cfc:	b084      	sub	sp, #16
    6cfe:	4604      	mov	r4, r0
	char buf[12];
	ltoa(num, buf, 10);
    6d00:	a901      	add	r1, sp, #4
    6d02:	4618      	mov	r0, r3
    6d04:	220a      	movs	r2, #10
    6d06:	f000 f9c7 	bl	7098 <ltoa>
	append(buf, strlen(buf));
    6d0a:	a801      	add	r0, sp, #4
    6d0c:	f001 fef8 	bl	8b00 <strlen>
    6d10:	a901      	add	r1, sp, #4
    6d12:	4602      	mov	r2, r0
    6d14:	4620      	mov	r0, r4
    6d16:	f7ff ffa7 	bl	6c68 <String::append(char const*, unsigned int)>
	return *this;
}
    6d1a:	4620      	mov	r0, r4
    6d1c:	b004      	add	sp, #16
    6d1e:	bd10      	pop	{r4, pc}

00006d20 <operator+(StringSumHelper const&, int)>:
	a.append(c);
	return a;
}

StringSumHelper & operator + (const StringSumHelper &lhs, int num)
{
    6d20:	b510      	push	{r4, lr}
    6d22:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	a.append((long)num);
    6d24:	f7ff ffe8 	bl	6cf8 <String::append(long)>
	return a;
}
    6d28:	4620      	mov	r0, r4
    6d2a:	bd10      	pop	{r4, pc}

00006d2c <String::compareTo(String const&) const>:
/*  Comparison                               */
/*********************************************/

int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
    6d2c:	6803      	ldr	r3, [r0, #0]
    6d2e:	b153      	cbz	r3, 6d46 <String::compareTo(String const&) const+0x1a>
    6d30:	6809      	ldr	r1, [r1, #0]
    6d32:	b111      	cbz	r1, 6d3a <String::compareTo(String const&) const+0xe>
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
		if (buffer && len > 0) return *(unsigned char *)buffer;
		return 0;
	}
	return strcmp(buffer, s.buffer);
    6d34:	4618      	mov	r0, r3
    6d36:	f001 bd07 	b.w	8748 <strcmp>

int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
		if (buffer && len > 0) return *(unsigned char *)buffer;
    6d3a:	6880      	ldr	r0, [r0, #8]
    6d3c:	b110      	cbz	r0, 6d44 <String::compareTo(String const&) const+0x18>
    6d3e:	7818      	ldrb	r0, [r3, #0]
    6d40:	4770      	bx	lr
		return 0;
    6d42:	4618      	mov	r0, r3
	}
	return strcmp(buffer, s.buffer);
}
    6d44:	4770      	bx	lr
/*********************************************/

int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
    6d46:	680b      	ldr	r3, [r1, #0]
    6d48:	2b00      	cmp	r3, #0
    6d4a:	d0fa      	beq.n	6d42 <String::compareTo(String const&) const+0x16>
    6d4c:	6888      	ldr	r0, [r1, #8]
    6d4e:	2800      	cmp	r0, #0
    6d50:	d0f8      	beq.n	6d44 <String::compareTo(String const&) const+0x18>
    6d52:	7818      	ldrb	r0, [r3, #0]
    6d54:	4240      	negs	r0, r0
    6d56:	4770      	bx	lr

00006d58 <String::equals(String const&) const>:
	}
	return strcmp(buffer, s.buffer);
}

unsigned char String::equals(const String &s2) const
{
    6d58:	b508      	push	{r3, lr}
	return (len == s2.len && compareTo(s2) == 0);
    6d5a:	6882      	ldr	r2, [r0, #8]
    6d5c:	688b      	ldr	r3, [r1, #8]
    6d5e:	429a      	cmp	r2, r3
    6d60:	d001      	beq.n	6d66 <String::equals(String const&) const+0xe>
    6d62:	2000      	movs	r0, #0
}
    6d64:	bd08      	pop	{r3, pc}
	return strcmp(buffer, s.buffer);
}

unsigned char String::equals(const String &s2) const
{
	return (len == s2.len && compareTo(s2) == 0);
    6d66:	f7ff ffe1 	bl	6d2c <String::compareTo(String const&) const>
    6d6a:	fab0 f080 	clz	r0, r0
    6d6e:	0940      	lsrs	r0, r0, #5
    6d70:	bd08      	pop	{r3, pc}
    6d72:	bf00      	nop

00006d74 <String::equals(char const*) const>:
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    6d74:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    6d76:	b508      	push	{r3, lr}
    6d78:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    6d7a:	b92a      	cbnz	r2, 6d88 <String::equals(char const*) const+0x14>
    6d7c:	b171      	cbz	r1, 6d9c <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    6d7e:	7818      	ldrb	r0, [r3, #0]
    6d80:	fab0 f080 	clz	r0, r0
    6d84:	0940      	lsrs	r0, r0, #5
    6d86:	bd08      	pop	{r3, pc}
    6d88:	b131      	cbz	r1, 6d98 <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    6d8a:	6800      	ldr	r0, [r0, #0]
    6d8c:	f001 fcdc 	bl	8748 <strcmp>
    6d90:	fab0 f080 	clz	r0, r0
    6d94:	0940      	lsrs	r0, r0, #5
}
    6d96:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    6d98:	6803      	ldr	r3, [r0, #0]
    6d9a:	e7f0      	b.n	6d7e <String::equals(char const*) const+0xa>
    6d9c:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    6d9e:	bd08      	pop	{r3, pc}

00006da0 <String::operator[](unsigned int)>:
}

char & String::operator[](unsigned int index)
{
	static char dummy_writable_char;
	if (index >= len || !buffer) {
    6da0:	6883      	ldr	r3, [r0, #8]
    6da2:	428b      	cmp	r3, r1
    6da4:	d903      	bls.n	6dae <String::operator[](unsigned int)+0xe>
    6da6:	6800      	ldr	r0, [r0, #0]
    6da8:	b108      	cbz	r0, 6dae <String::operator[](unsigned int)+0xe>
		dummy_writable_char = 0;
		return dummy_writable_char;
	}
	return buffer[index];
    6daa:	4408      	add	r0, r1
}
    6dac:	4770      	bx	lr

char & String::operator[](unsigned int index)
{
	static char dummy_writable_char;
	if (index >= len || !buffer) {
		dummy_writable_char = 0;
    6dae:	4902      	ldr	r1, [pc, #8]	; (6db8 <String::operator[](unsigned int)+0x18>)
    6db0:	2300      	movs	r3, #0
    6db2:	700b      	strb	r3, [r1, #0]
		return dummy_writable_char;
    6db4:	4608      	mov	r0, r1
    6db6:	4770      	bx	lr
    6db8:	1fffb5f8 	.word	0x1fffb5f8

00006dbc <String::getBytes(unsigned char*, unsigned int, unsigned int) const>:
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    6dbc:	b1b2      	cbz	r2, 6dec <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x30>
    6dbe:	b1a9      	cbz	r1, 6dec <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x30>
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    6dc0:	b538      	push	{r3, r4, r5, lr}
	if (!bufsize || !buf) return;
	if (index >= len) {
    6dc2:	6884      	ldr	r4, [r0, #8]
    6dc4:	429c      	cmp	r4, r3
    6dc6:	d90e      	bls.n	6de6 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x2a>
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
    6dc8:	1ae4      	subs	r4, r4, r3
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
    6dca:	3a01      	subs	r2, #1
    6dcc:	460d      	mov	r5, r1
    6dce:	4294      	cmp	r4, r2
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
    6dd0:	6801      	ldr	r1, [r0, #0]
    6dd2:	bf28      	it	cs
    6dd4:	4614      	movcs	r4, r2
    6dd6:	4419      	add	r1, r3
    6dd8:	4622      	mov	r2, r4
    6dda:	4628      	mov	r0, r5
    6ddc:	f001 fefe 	bl	8bdc <strncpy>
	buf[n] = 0;
    6de0:	2300      	movs	r3, #0
    6de2:	552b      	strb	r3, [r5, r4]
    6de4:	bd38      	pop	{r3, r4, r5, pc}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
    6de6:	2300      	movs	r3, #0
    6de8:	700b      	strb	r3, [r1, #0]
		return;
    6dea:	bd38      	pop	{r3, r4, r5, pc}
    6dec:	4770      	bx	lr
    6dee:	bf00      	nop

00006df0 <String::substring(unsigned int, unsigned int) const>:
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
    6df0:	429a      	cmp	r2, r3
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
    6df2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6df4:	4604      	mov	r4, r0
    6df6:	460e      	mov	r6, r1
	if (left > right) {
    6df8:	d902      	bls.n	6e00 <String::substring(unsigned int, unsigned int) const+0x10>
    6dfa:	4611      	mov	r1, r2
    6dfc:	461a      	mov	r2, r3
    6dfe:	460b      	mov	r3, r1
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6e00:	2100      	movs	r1, #0
	capacity = 0;
	len = 0;
    6e02:	60a1      	str	r1, [r4, #8]
	flags = 0;
    6e04:	7321      	strb	r1, [r4, #12]
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
	if (left > len) return out;
    6e06:	68b0      	ldr	r0, [r6, #8]
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6e08:	6021      	str	r1, [r4, #0]
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
	if (left > len) return out;
    6e0a:	4282      	cmp	r2, r0
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
	capacity = 0;
    6e0c:	6061      	str	r1, [r4, #4]
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
	if (left > len) return out;
    6e0e:	d80e      	bhi.n	6e2e <String::substring(unsigned int, unsigned int) const+0x3e>
    6e10:	4283      	cmp	r3, r0
    6e12:	bf28      	it	cs
    6e14:	4603      	movcs	r3, r0
    6e16:	461d      	mov	r5, r3
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
    6e18:	6833      	ldr	r3, [r6, #0]
    6e1a:	5d5f      	ldrb	r7, [r3, r5]
	buffer[right] = '\0';	
    6e1c:	5559      	strb	r1, [r3, r5]
	out = buffer + left;  // pointer arithmetic
    6e1e:	6833      	ldr	r3, [r6, #0]
}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) {
    6e20:	1899      	adds	r1, r3, r2
    6e22:	d006      	beq.n	6e32 <String::substring(unsigned int, unsigned int) const+0x42>
    6e24:	4620      	mov	r0, r4
    6e26:	f7ff feff 	bl	6c28 <String::operator=(char const*) [clone .part.2]>
    6e2a:	6833      	ldr	r3, [r6, #0]
	if (left > len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
	buffer[right] = '\0';	
	out = buffer + left;  // pointer arithmetic
	buffer[right] = temp;  //restore character
    6e2c:	555f      	strb	r7, [r3, r5]
	return out;
}
    6e2e:	4620      	mov	r0, r4
    6e30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
	} else {
		len = 0;
    6e32:	60a1      	str	r1, [r4, #8]
	if (left > len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
	buffer[right] = '\0';	
	out = buffer + left;  // pointer arithmetic
	buffer[right] = temp;  //restore character
    6e34:	555f      	strb	r7, [r3, r5]
    6e36:	e7fa      	b.n	6e2e <String::substring(unsigned int, unsigned int) const+0x3e>

00006e38 <String::toInt() const>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
    6e38:	6800      	ldr	r0, [r0, #0]
    6e3a:	b108      	cbz	r0, 6e40 <String::toInt() const+0x8>
    6e3c:	f000 bea6 	b.w	7b8c <atol>
	return 0;
}
    6e40:	4770      	bx	lr
    6e42:	bf00      	nop

00006e44 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    6e44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    6e48:	4e31      	ldr	r6, [pc, #196]	; (6f10 <yield+0xcc>)
    6e4a:	7833      	ldrb	r3, [r6, #0]
    6e4c:	b193      	cbz	r3, 6e74 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    6e4e:	4f31      	ldr	r7, [pc, #196]	; (6f14 <yield+0xd0>)
    6e50:	783a      	ldrb	r2, [r7, #0]
    6e52:	b97a      	cbnz	r2, 6e74 <yield+0x30>
	running = 1;
    6e54:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6e56:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    6e58:	703a      	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6e5a:	d436      	bmi.n	6eca <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    6e5c:	079a      	lsls	r2, r3, #30
    6e5e:	d419      	bmi.n	6e94 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    6e60:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    6e62:	075b      	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    6e64:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    6e66:	d505      	bpl.n	6e74 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    6e68:	4b2b      	ldr	r3, [pc, #172]	; (6f18 <yield+0xd4>)
    6e6a:	681a      	ldr	r2, [r3, #0]
    6e6c:	b112      	cbz	r2, 6e74 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    6e6e:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    6e72:	b10a      	cbz	r2, 6e78 <yield+0x34>
    6e74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    6e78:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    6e7c:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    6e7e:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    6e80:	b118      	cbz	r0, 6e8a <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    6e82:	4c26      	ldr	r4, [pc, #152]	; (6f1c <yield+0xd8>)
    6e84:	7822      	ldrb	r2, [r4, #0]
    6e86:	2a00      	cmp	r2, #0
    6e88:	d02e      	beq.n	6ee8 <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6e8a:	2900      	cmp	r1, #0
    6e8c:	d1f2      	bne.n	6e74 <yield+0x30>
    6e8e:	b662      	cpsie	i
    6e90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    6e94:	f8df 8090 	ldr.w	r8, [pc, #144]	; 6f28 <yield+0xe4>
    6e98:	f898 2000 	ldrb.w	r2, [r8]
    6e9c:	2a00      	cmp	r2, #0
    6e9e:	d0df      	beq.n	6e60 <yield+0x1c>
    6ea0:	f8df 9088 	ldr.w	r9, [pc, #136]	; 6f2c <yield+0xe8>
    6ea4:	2400      	movs	r4, #0
    6ea6:	e005      	b.n	6eb4 <yield+0x70>
    6ea8:	3401      	adds	r4, #1
    6eaa:	f898 3000 	ldrb.w	r3, [r8]
    6eae:	b2e4      	uxtb	r4, r4
    6eb0:	42a3      	cmp	r3, r4
    6eb2:	d912      	bls.n	6eda <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    6eb4:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    6eb8:	682b      	ldr	r3, [r5, #0]
    6eba:	4628      	mov	r0, r5
    6ebc:	691b      	ldr	r3, [r3, #16]
    6ebe:	4798      	blx	r3
    6ec0:	2800      	cmp	r0, #0
    6ec2:	d0f1      	beq.n	6ea8 <yield+0x64>
    6ec4:	692b      	ldr	r3, [r5, #16]
    6ec6:	4798      	blx	r3
    6ec8:	e7ee      	b.n	6ea8 <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    6eca:	f7ff fafb 	bl	64c4 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    6ece:	b9c8      	cbnz	r0, 6f04 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    6ed0:	4b13      	ldr	r3, [pc, #76]	; (6f20 <yield+0xdc>)
    6ed2:	781b      	ldrb	r3, [r3, #0]
    6ed4:	b91b      	cbnz	r3, 6ede <yield+0x9a>
    6ed6:	7833      	ldrb	r3, [r6, #0]
    6ed8:	e7c0      	b.n	6e5c <yield+0x18>
    6eda:	7833      	ldrb	r3, [r6, #0]
    6edc:	e7c0      	b.n	6e60 <yield+0x1c>
    6ede:	7833      	ldrb	r3, [r6, #0]
    6ee0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    6ee4:	7033      	strb	r3, [r6, #0]
    6ee6:	e7b9      	b.n	6e5c <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    6ee8:	6945      	ldr	r5, [r0, #20]
    6eea:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    6eec:	2301      	movs	r3, #1
    6eee:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    6ef0:	b15d      	cbz	r5, 6f0a <yield+0xc6>
			firstYield->_prev = nullptr;
    6ef2:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6ef4:	b901      	cbnz	r1, 6ef8 <yield+0xb4>
    6ef6:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    6ef8:	2500      	movs	r5, #0
    6efa:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    6efc:	6883      	ldr	r3, [r0, #8]
    6efe:	4798      	blx	r3
		runningFromYield = false;
    6f00:	7025      	strb	r5, [r4, #0]
    6f02:	e7b7      	b.n	6e74 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    6f04:	f000 f944 	bl	7190 <serialEvent()>
    6f08:	e7e2      	b.n	6ed0 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    6f0a:	4b06      	ldr	r3, [pc, #24]	; (6f24 <yield+0xe0>)
    6f0c:	601d      	str	r5, [r3, #0]
    6f0e:	e7f1      	b.n	6ef4 <yield+0xb0>
    6f10:	1fff8770 	.word	0x1fff8770
    6f14:	1fffb5f9 	.word	0x1fffb5f9
    6f18:	1fffb5ec 	.word	0x1fffb5ec
    6f1c:	1fffb5f0 	.word	0x1fffb5f0
    6f20:	1fff8816 	.word	0x1fff8816
    6f24:	1fffb5e8 	.word	0x1fffb5e8
    6f28:	1fffb608 	.word	0x1fffb608
    6f2c:	1fffb5fc 	.word	0x1fffb5fc

00006f30 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    6f30:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    6f32:	4829      	ldr	r0, [pc, #164]	; (6fd8 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    6f34:	4a29      	ldr	r2, [pc, #164]	; (6fdc <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    6f36:	4b2a      	ldr	r3, [pc, #168]	; (6fe0 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6f38:	4d2a      	ldr	r5, [pc, #168]	; (6fe4 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    6f3a:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    6f3c:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    6f3e:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    6f40:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    6f42:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6f44:	4c28      	ldr	r4, [pc, #160]	; (6fe8 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    6f46:	2b08      	cmp	r3, #8
    6f48:	d030      	beq.n	6fac <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    6f4a:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6f4c:	4827      	ldr	r0, [pc, #156]	; (6fec <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6f4e:	4928      	ldr	r1, [pc, #160]	; (6ff0 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    6f50:	d037      	beq.n	6fc2 <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    6f52:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    6f54:	bf0c      	ite	eq
    6f56:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6f58:	223d      	movne	r2, #61	; 0x3d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6f5a:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6f5c:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6f5e:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6f60:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6f62:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6f64:	4b23      	ldr	r3, [pc, #140]	; (6ff4 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6f66:	4924      	ldr	r1, [pc, #144]	; (6ff8 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6f68:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6f6a:	4a24      	ldr	r2, [pc, #144]	; (6ffc <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6f6c:	b1bb      	cbz	r3, 6f9e <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6f6e:	2301      	movs	r3, #1
    6f70:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6f72:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    6f74:	4b22      	ldr	r3, [pc, #136]	; (7000 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    6f76:	4923      	ldr	r1, [pc, #140]	; (7004 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    6f78:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    6f7a:	4a23      	ldr	r2, [pc, #140]	; (7008 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    6f7c:	2b01      	cmp	r3, #1
    6f7e:	d926      	bls.n	6fce <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    6f80:	2b04      	cmp	r3, #4
    6f82:	d90f      	bls.n	6fa4 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    6f84:	2b08      	cmp	r3, #8
    6f86:	d91e      	bls.n	6fc6 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    6f88:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    6f8a:	bf94      	ite	ls
    6f8c:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    6f8e:	2387      	movhi	r3, #135	; 0x87
    6f90:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    6f92:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    6f94:	4b1d      	ldr	r3, [pc, #116]	; (700c <analog_init+0xdc>)
    6f96:	2201      	movs	r2, #1
    6f98:	701a      	strb	r2, [r3, #0]
}
    6f9a:	bc30      	pop	{r4, r5}
    6f9c:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    6f9e:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    6fa0:	6013      	str	r3, [r2, #0]
    6fa2:	e7e7      	b.n	6f74 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    6fa4:	2384      	movs	r3, #132	; 0x84
    6fa6:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    6fa8:	6013      	str	r3, [r2, #0]
    6faa:	e7f3      	b.n	6f94 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6fac:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6fb0:	490f      	ldr	r1, [pc, #60]	; (6ff0 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6fb2:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6fb4:	2201      	movs	r2, #1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6fb6:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6fb8:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6fba:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6fbc:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6fbe:	600b      	str	r3, [r1, #0]
    6fc0:	e7d0      	b.n	6f64 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6fc2:	2239      	movs	r2, #57	; 0x39
    6fc4:	e7f7      	b.n	6fb6 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    6fc6:	2385      	movs	r3, #133	; 0x85
    6fc8:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    6fca:	6013      	str	r3, [r2, #0]
    6fcc:	e7e2      	b.n	6f94 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    6fce:	2380      	movs	r3, #128	; 0x80
    6fd0:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    6fd2:	6013      	str	r3, [r2, #0]
    6fd4:	e7de      	b.n	6f94 <analog_init+0x64>
    6fd6:	bf00      	nop
    6fd8:	40074000 	.word	0x40074000
    6fdc:	40074001 	.word	0x40074001
    6fe0:	1fff8771 	.word	0x1fff8771
    6fe4:	4003b008 	.word	0x4003b008
    6fe8:	4003b00c 	.word	0x4003b00c
    6fec:	400bb008 	.word	0x400bb008
    6ff0:	400bb00c 	.word	0x400bb00c
    6ff4:	1fffb5fb 	.word	0x1fffb5fb
    6ff8:	4003b020 	.word	0x4003b020
    6ffc:	400bb020 	.word	0x400bb020
    7000:	1fff8772 	.word	0x1fff8772
    7004:	4003b024 	.word	0x4003b024
    7008:	400bb024 	.word	0x400bb024
    700c:	1fffb5fa 	.word	0x1fffb5fa

00007010 <analogWriteDAC0>:
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    7010:	4a0a      	ldr	r2, [pc, #40]	; (703c <analogWriteDAC0+0x2c>)
	if (analog_reference_internal) {
    7012:	490b      	ldr	r1, [pc, #44]	; (7040 <analogWriteDAC0+0x30>)
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    7014:	6813      	ldr	r3, [r2, #0]
    7016:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    701a:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    701c:	780b      	ldrb	r3, [r1, #0]
    701e:	b943      	cbnz	r3, 7032 <analogWriteDAC0+0x22>
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    7020:	4b08      	ldr	r3, [pc, #32]	; (7044 <analogWriteDAC0+0x34>)
    7022:	22c0      	movs	r2, #192	; 0xc0
    7024:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    7026:	4b08      	ldr	r3, [pc, #32]	; (7048 <analogWriteDAC0+0x38>)
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    7028:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    702c:	b200      	sxth	r0, r0
    702e:	8018      	strh	r0, [r3, #0]
    7030:	4770      	bx	lr
void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    7032:	4b04      	ldr	r3, [pc, #16]	; (7044 <analogWriteDAC0+0x34>)
    7034:	2280      	movs	r2, #128	; 0x80
    7036:	701a      	strb	r2, [r3, #0]
    7038:	e7f5      	b.n	7026 <analogWriteDAC0+0x16>
    703a:	bf00      	nop
    703c:	4004802c 	.word	0x4004802c
    7040:	1fffb5fb 	.word	0x1fffb5fb
    7044:	400cc021 	.word	0x400cc021
    7048:	400cc000 	.word	0x400cc000

0000704c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    704c:	b4f0      	push	{r4, r5, r6, r7}
    704e:	1e4d      	subs	r5, r1, #1
    7050:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    7052:	2400      	movs	r4, #0
    7054:	e000      	b.n	7058 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    7056:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    7058:	fbb0 f3f2 	udiv	r3, r0, r2
    705c:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    7060:	2809      	cmp	r0, #9
    7062:	f100 0730 	add.w	r7, r0, #48	; 0x30
    7066:	bf8a      	itet	hi
    7068:	3037      	addhi	r0, #55	; 0x37
    706a:	b2f8      	uxtbls	r0, r7
    706c:	b2c0      	uxtbhi	r0, r0
    706e:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    7072:	4618      	mov	r0, r3
    7074:	2b00      	cmp	r3, #0
    7076:	d1ee      	bne.n	7056 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    7078:	190a      	adds	r2, r1, r4
    707a:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    707c:	b14c      	cbz	r4, 7092 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    707e:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    7080:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    7084:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    7086:	3301      	adds	r3, #1
    7088:	1ae0      	subs	r0, r4, r3
    708a:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    708c:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    7090:	dbf5      	blt.n	707e <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    7092:	4608      	mov	r0, r1
    7094:	bcf0      	pop	{r4, r5, r6, r7}
    7096:	4770      	bx	lr

00007098 <ltoa>:

char * ltoa(long val, char *buf, int radix)
{
    7098:	b510      	push	{r4, lr}
	if (val >= 0) {
    709a:	1e04      	subs	r4, r0, #0
    709c:	db03      	blt.n	70a6 <ltoa+0xe>
	} else {
		buf[0] = '-';
		ultoa(-val, buf + 1, radix);
		return buf;
	}
}
    709e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

char * ltoa(long val, char *buf, int radix)
{
	if (val >= 0) {
		return ultoa(val, buf, radix);
    70a2:	f7ff bfd3 	b.w	704c <ultoa>
	} else {
		buf[0] = '-';
    70a6:	232d      	movs	r3, #45	; 0x2d
    70a8:	4620      	mov	r0, r4
		ultoa(-val, buf + 1, radix);
    70aa:	4240      	negs	r0, r0
    70ac:	460c      	mov	r4, r1
char * ltoa(long val, char *buf, int radix)
{
	if (val >= 0) {
		return ultoa(val, buf, radix);
	} else {
		buf[0] = '-';
    70ae:	f801 3b01 	strb.w	r3, [r1], #1
		ultoa(-val, buf + 1, radix);
    70b2:	f7ff ffcb 	bl	704c <ultoa>
		return buf;
	}
}
    70b6:	4620      	mov	r0, r4
    70b8:	bd10      	pop	{r4, pc}
    70ba:	bf00      	nop

000070bc <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    70bc:	b570      	push	{r4, r5, r6, lr}
    70be:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    70c0:	b672      	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    70c2:	4b19      	ldr	r3, [pc, #100]	; (7128 <usb_init_serialnumber+0x6c>)
	FTFL_FCCOB0 = 0x41;
    70c4:	4d19      	ldr	r5, [pc, #100]	; (712c <usb_init_serialnumber+0x70>)
	FTFL_FCCOB1 = 15;
    70c6:	481a      	ldr	r0, [pc, #104]	; (7130 <usb_init_serialnumber+0x74>)
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    70c8:	2270      	movs	r2, #112	; 0x70
	FTFL_FCCOB0 = 0x41;
    70ca:	2641      	movs	r6, #65	; 0x41
	FTFL_FCCOB1 = 15;
    70cc:	240f      	movs	r4, #15
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    70ce:	2180      	movs	r1, #128	; 0x80
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    70d0:	701a      	strb	r2, [r3, #0]
	FTFL_FCCOB0 = 0x41;
    70d2:	702e      	strb	r6, [r5, #0]
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    70d4:	461a      	mov	r2, r3

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	FTFL_FCCOB0 = 0x41;
	FTFL_FCCOB1 = 15;
    70d6:	7004      	strb	r4, [r0, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    70d8:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    70da:	7813      	ldrb	r3, [r2, #0]
    70dc:	061b      	lsls	r3, r3, #24
    70de:	d5fc      	bpl.n	70da <usb_init_serialnumber+0x1e>
	num = *(uint32_t *)&FTFL_FCCOB7;
    70e0:	4b14      	ldr	r3, [pc, #80]	; (7134 <usb_init_serialnumber+0x78>)
    70e2:	6818      	ldr	r0, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    70e4:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    70e6:	4b14      	ldr	r3, [pc, #80]	; (7138 <usb_init_serialnumber+0x7c>)
    70e8:	4c14      	ldr	r4, [pc, #80]	; (713c <usb_init_serialnumber+0x80>)
    70ea:	4298      	cmp	r0, r3
    70ec:	bf98      	it	ls
    70ee:	eb00 0080 	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    70f2:	a901      	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    70f4:	bf98      	it	ls
    70f6:	0040      	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    70f8:	220a      	movs	r2, #10
    70fa:	f7ff ffa7 	bl	704c <ultoa>
    70fe:	a901      	add	r1, sp, #4
    7100:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    7102:	2300      	movs	r3, #0
		char c = buf[i];
    7104:	f811 2b01 	ldrb.w	r2, [r1], #1
    7108:	3301      	adds	r3, #1
		if (!c) break;
    710a:	b13a      	cbz	r2, 711c <usb_init_serialnumber+0x60>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    710c:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    710e:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    7112:	d1f7      	bne.n	7104 <usb_init_serialnumber+0x48>
    7114:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    7116:	7023      	strb	r3, [r4, #0]
}
    7118:	b004      	add	sp, #16
    711a:	bd70      	pop	{r4, r5, r6, pc}
    711c:	005b      	lsls	r3, r3, #1
    711e:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    7120:	7023      	strb	r3, [r4, #0]
}
    7122:	b004      	add	sp, #16
    7124:	bd70      	pop	{r4, r5, r6, pc}
    7126:	bf00      	nop
    7128:	40020000 	.word	0x40020000
    712c:	40020007 	.word	0x40020007
    7130:	40020006 	.word	0x40020006
    7134:	40020008 	.word	0x40020008
    7138:	0098967f 	.word	0x0098967f
    713c:	1fff8800 	.word	0x1fff8800

00007140 <HardwareSerial::addToSerialEventsList()>:
HardwareSerial 	*HardwareSerial::s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
    7140:	b470      	push	{r4, r5, r6}
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7142:	4e10      	ldr	r6, [pc, #64]	; (7184 <HardwareSerial::addToSerialEventsList()+0x44>)
    7144:	4d10      	ldr	r5, [pc, #64]	; (7188 <HardwareSerial::addToSerialEventsList()+0x48>)
    7146:	7834      	ldrb	r4, [r6, #0]
    7148:	b1cc      	cbz	r4, 717e <HardwareSerial::addToSerialEventsList()+0x3e>
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
    714a:	682b      	ldr	r3, [r5, #0]
    714c:	4298      	cmp	r0, r3
    714e:	d014      	beq.n	717a <HardwareSerial::addToSerialEventsList()+0x3a>
    7150:	462a      	mov	r2, r5
    7152:	2300      	movs	r3, #0
    7154:	e003      	b.n	715e <HardwareSerial::addToSerialEventsList()+0x1e>
    7156:	f852 1f04 	ldr.w	r1, [r2, #4]!
    715a:	4281      	cmp	r1, r0
    715c:	d00d      	beq.n	717a <HardwareSerial::addToSerialEventsList()+0x3a>
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    715e:	3301      	adds	r3, #1
    7160:	b2db      	uxtb	r3, r3
    7162:	42a3      	cmp	r3, r4
    7164:	d1f7      	bne.n	7156 <HardwareSerial::addToSerialEventsList()+0x16>
    7166:	1c5a      	adds	r2, r3, #1
    7168:	b2d2      	uxtb	r2, r2
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    716a:	4908      	ldr	r1, [pc, #32]	; (718c <HardwareSerial::addToSerialEventsList()+0x4c>)
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    716c:	f845 0023 	str.w	r0, [r5, r3, lsl #2]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    7170:	780b      	ldrb	r3, [r1, #0]
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    7172:	7032      	strb	r2, [r6, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    7174:	f043 0302 	orr.w	r3, r3, #2
    7178:	700b      	strb	r3, [r1, #0]
}
    717a:	bc70      	pop	{r4, r5, r6}
    717c:	4770      	bx	lr
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    717e:	4623      	mov	r3, r4
    7180:	2201      	movs	r2, #1
    7182:	e7f2      	b.n	716a <HardwareSerial::addToSerialEventsList()+0x2a>
    7184:	1fffb608 	.word	0x1fffb608
    7188:	1fffb5fc 	.word	0x1fffb5fc
    718c:	1fff8770 	.word	0x1fff8770

00007190 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    7190:	4770      	bx	lr
    7192:	bf00      	nop

00007194 <__aeabi_atexit>:
    7194:	460b      	mov	r3, r1
    7196:	4601      	mov	r1, r0
    7198:	4618      	mov	r0, r3
    719a:	f000 bcfb 	b.w	7b94 <__cxa_atexit>
    719e:	bf00      	nop

000071a0 <__aeabi_drsub>:
    71a0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    71a4:	e002      	b.n	71ac <__adddf3>
    71a6:	bf00      	nop

000071a8 <__aeabi_dsub>:
    71a8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000071ac <__adddf3>:
    71ac:	b530      	push	{r4, r5, lr}
    71ae:	ea4f 0441 	mov.w	r4, r1, lsl #1
    71b2:	ea4f 0543 	mov.w	r5, r3, lsl #1
    71b6:	ea94 0f05 	teq	r4, r5
    71ba:	bf08      	it	eq
    71bc:	ea90 0f02 	teqeq	r0, r2
    71c0:	bf1f      	itttt	ne
    71c2:	ea54 0c00 	orrsne.w	ip, r4, r0
    71c6:	ea55 0c02 	orrsne.w	ip, r5, r2
    71ca:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    71ce:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    71d2:	f000 80e2 	beq.w	739a <__adddf3+0x1ee>
    71d6:	ea4f 5454 	mov.w	r4, r4, lsr #21
    71da:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    71de:	bfb8      	it	lt
    71e0:	426d      	neglt	r5, r5
    71e2:	dd0c      	ble.n	71fe <__adddf3+0x52>
    71e4:	442c      	add	r4, r5
    71e6:	ea80 0202 	eor.w	r2, r0, r2
    71ea:	ea81 0303 	eor.w	r3, r1, r3
    71ee:	ea82 0000 	eor.w	r0, r2, r0
    71f2:	ea83 0101 	eor.w	r1, r3, r1
    71f6:	ea80 0202 	eor.w	r2, r0, r2
    71fa:	ea81 0303 	eor.w	r3, r1, r3
    71fe:	2d36      	cmp	r5, #54	; 0x36
    7200:	bf88      	it	hi
    7202:	bd30      	pophi	{r4, r5, pc}
    7204:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    7208:	ea4f 3101 	mov.w	r1, r1, lsl #12
    720c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    7210:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    7214:	d002      	beq.n	721c <__adddf3+0x70>
    7216:	4240      	negs	r0, r0
    7218:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    721c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    7220:	ea4f 3303 	mov.w	r3, r3, lsl #12
    7224:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    7228:	d002      	beq.n	7230 <__adddf3+0x84>
    722a:	4252      	negs	r2, r2
    722c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    7230:	ea94 0f05 	teq	r4, r5
    7234:	f000 80a7 	beq.w	7386 <__adddf3+0x1da>
    7238:	f1a4 0401 	sub.w	r4, r4, #1
    723c:	f1d5 0e20 	rsbs	lr, r5, #32
    7240:	db0d      	blt.n	725e <__adddf3+0xb2>
    7242:	fa02 fc0e 	lsl.w	ip, r2, lr
    7246:	fa22 f205 	lsr.w	r2, r2, r5
    724a:	1880      	adds	r0, r0, r2
    724c:	f141 0100 	adc.w	r1, r1, #0
    7250:	fa03 f20e 	lsl.w	r2, r3, lr
    7254:	1880      	adds	r0, r0, r2
    7256:	fa43 f305 	asr.w	r3, r3, r5
    725a:	4159      	adcs	r1, r3
    725c:	e00e      	b.n	727c <__adddf3+0xd0>
    725e:	f1a5 0520 	sub.w	r5, r5, #32
    7262:	f10e 0e20 	add.w	lr, lr, #32
    7266:	2a01      	cmp	r2, #1
    7268:	fa03 fc0e 	lsl.w	ip, r3, lr
    726c:	bf28      	it	cs
    726e:	f04c 0c02 	orrcs.w	ip, ip, #2
    7272:	fa43 f305 	asr.w	r3, r3, r5
    7276:	18c0      	adds	r0, r0, r3
    7278:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    727c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    7280:	d507      	bpl.n	7292 <__adddf3+0xe6>
    7282:	f04f 0e00 	mov.w	lr, #0
    7286:	f1dc 0c00 	rsbs	ip, ip, #0
    728a:	eb7e 0000 	sbcs.w	r0, lr, r0
    728e:	eb6e 0101 	sbc.w	r1, lr, r1
    7292:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    7296:	d31b      	bcc.n	72d0 <__adddf3+0x124>
    7298:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    729c:	d30c      	bcc.n	72b8 <__adddf3+0x10c>
    729e:	0849      	lsrs	r1, r1, #1
    72a0:	ea5f 0030 	movs.w	r0, r0, rrx
    72a4:	ea4f 0c3c 	mov.w	ip, ip, rrx
    72a8:	f104 0401 	add.w	r4, r4, #1
    72ac:	ea4f 5244 	mov.w	r2, r4, lsl #21
    72b0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    72b4:	f080 809a 	bcs.w	73ec <__adddf3+0x240>
    72b8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    72bc:	bf08      	it	eq
    72be:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    72c2:	f150 0000 	adcs.w	r0, r0, #0
    72c6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    72ca:	ea41 0105 	orr.w	r1, r1, r5
    72ce:	bd30      	pop	{r4, r5, pc}
    72d0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    72d4:	4140      	adcs	r0, r0
    72d6:	eb41 0101 	adc.w	r1, r1, r1
    72da:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    72de:	f1a4 0401 	sub.w	r4, r4, #1
    72e2:	d1e9      	bne.n	72b8 <__adddf3+0x10c>
    72e4:	f091 0f00 	teq	r1, #0
    72e8:	bf04      	itt	eq
    72ea:	4601      	moveq	r1, r0
    72ec:	2000      	moveq	r0, #0
    72ee:	fab1 f381 	clz	r3, r1
    72f2:	bf08      	it	eq
    72f4:	3320      	addeq	r3, #32
    72f6:	f1a3 030b 	sub.w	r3, r3, #11
    72fa:	f1b3 0220 	subs.w	r2, r3, #32
    72fe:	da0c      	bge.n	731a <__adddf3+0x16e>
    7300:	320c      	adds	r2, #12
    7302:	dd08      	ble.n	7316 <__adddf3+0x16a>
    7304:	f102 0c14 	add.w	ip, r2, #20
    7308:	f1c2 020c 	rsb	r2, r2, #12
    730c:	fa01 f00c 	lsl.w	r0, r1, ip
    7310:	fa21 f102 	lsr.w	r1, r1, r2
    7314:	e00c      	b.n	7330 <__adddf3+0x184>
    7316:	f102 0214 	add.w	r2, r2, #20
    731a:	bfd8      	it	le
    731c:	f1c2 0c20 	rsble	ip, r2, #32
    7320:	fa01 f102 	lsl.w	r1, r1, r2
    7324:	fa20 fc0c 	lsr.w	ip, r0, ip
    7328:	bfdc      	itt	le
    732a:	ea41 010c 	orrle.w	r1, r1, ip
    732e:	4090      	lslle	r0, r2
    7330:	1ae4      	subs	r4, r4, r3
    7332:	bfa2      	ittt	ge
    7334:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    7338:	4329      	orrge	r1, r5
    733a:	bd30      	popge	{r4, r5, pc}
    733c:	ea6f 0404 	mvn.w	r4, r4
    7340:	3c1f      	subs	r4, #31
    7342:	da1c      	bge.n	737e <__adddf3+0x1d2>
    7344:	340c      	adds	r4, #12
    7346:	dc0e      	bgt.n	7366 <__adddf3+0x1ba>
    7348:	f104 0414 	add.w	r4, r4, #20
    734c:	f1c4 0220 	rsb	r2, r4, #32
    7350:	fa20 f004 	lsr.w	r0, r0, r4
    7354:	fa01 f302 	lsl.w	r3, r1, r2
    7358:	ea40 0003 	orr.w	r0, r0, r3
    735c:	fa21 f304 	lsr.w	r3, r1, r4
    7360:	ea45 0103 	orr.w	r1, r5, r3
    7364:	bd30      	pop	{r4, r5, pc}
    7366:	f1c4 040c 	rsb	r4, r4, #12
    736a:	f1c4 0220 	rsb	r2, r4, #32
    736e:	fa20 f002 	lsr.w	r0, r0, r2
    7372:	fa01 f304 	lsl.w	r3, r1, r4
    7376:	ea40 0003 	orr.w	r0, r0, r3
    737a:	4629      	mov	r1, r5
    737c:	bd30      	pop	{r4, r5, pc}
    737e:	fa21 f004 	lsr.w	r0, r1, r4
    7382:	4629      	mov	r1, r5
    7384:	bd30      	pop	{r4, r5, pc}
    7386:	f094 0f00 	teq	r4, #0
    738a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    738e:	bf06      	itte	eq
    7390:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    7394:	3401      	addeq	r4, #1
    7396:	3d01      	subne	r5, #1
    7398:	e74e      	b.n	7238 <__adddf3+0x8c>
    739a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    739e:	bf18      	it	ne
    73a0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    73a4:	d029      	beq.n	73fa <__adddf3+0x24e>
    73a6:	ea94 0f05 	teq	r4, r5
    73aa:	bf08      	it	eq
    73ac:	ea90 0f02 	teqeq	r0, r2
    73b0:	d005      	beq.n	73be <__adddf3+0x212>
    73b2:	ea54 0c00 	orrs.w	ip, r4, r0
    73b6:	bf04      	itt	eq
    73b8:	4619      	moveq	r1, r3
    73ba:	4610      	moveq	r0, r2
    73bc:	bd30      	pop	{r4, r5, pc}
    73be:	ea91 0f03 	teq	r1, r3
    73c2:	bf1e      	ittt	ne
    73c4:	2100      	movne	r1, #0
    73c6:	2000      	movne	r0, #0
    73c8:	bd30      	popne	{r4, r5, pc}
    73ca:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    73ce:	d105      	bne.n	73dc <__adddf3+0x230>
    73d0:	0040      	lsls	r0, r0, #1
    73d2:	4149      	adcs	r1, r1
    73d4:	bf28      	it	cs
    73d6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    73da:	bd30      	pop	{r4, r5, pc}
    73dc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    73e0:	bf3c      	itt	cc
    73e2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    73e6:	bd30      	popcc	{r4, r5, pc}
    73e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    73ec:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    73f0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    73f4:	f04f 0000 	mov.w	r0, #0
    73f8:	bd30      	pop	{r4, r5, pc}
    73fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    73fe:	bf1a      	itte	ne
    7400:	4619      	movne	r1, r3
    7402:	4610      	movne	r0, r2
    7404:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    7408:	bf1c      	itt	ne
    740a:	460b      	movne	r3, r1
    740c:	4602      	movne	r2, r0
    740e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    7412:	bf06      	itte	eq
    7414:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    7418:	ea91 0f03 	teqeq	r1, r3
    741c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    7420:	bd30      	pop	{r4, r5, pc}
    7422:	bf00      	nop

00007424 <__aeabi_ui2d>:
    7424:	f090 0f00 	teq	r0, #0
    7428:	bf04      	itt	eq
    742a:	2100      	moveq	r1, #0
    742c:	4770      	bxeq	lr
    742e:	b530      	push	{r4, r5, lr}
    7430:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7434:	f104 0432 	add.w	r4, r4, #50	; 0x32
    7438:	f04f 0500 	mov.w	r5, #0
    743c:	f04f 0100 	mov.w	r1, #0
    7440:	e750      	b.n	72e4 <__adddf3+0x138>
    7442:	bf00      	nop

00007444 <__aeabi_i2d>:
    7444:	f090 0f00 	teq	r0, #0
    7448:	bf04      	itt	eq
    744a:	2100      	moveq	r1, #0
    744c:	4770      	bxeq	lr
    744e:	b530      	push	{r4, r5, lr}
    7450:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7454:	f104 0432 	add.w	r4, r4, #50	; 0x32
    7458:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    745c:	bf48      	it	mi
    745e:	4240      	negmi	r0, r0
    7460:	f04f 0100 	mov.w	r1, #0
    7464:	e73e      	b.n	72e4 <__adddf3+0x138>
    7466:	bf00      	nop

00007468 <__aeabi_f2d>:
    7468:	0042      	lsls	r2, r0, #1
    746a:	ea4f 01e2 	mov.w	r1, r2, asr #3
    746e:	ea4f 0131 	mov.w	r1, r1, rrx
    7472:	ea4f 7002 	mov.w	r0, r2, lsl #28
    7476:	bf1f      	itttt	ne
    7478:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    747c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    7480:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    7484:	4770      	bxne	lr
    7486:	f092 0f00 	teq	r2, #0
    748a:	bf14      	ite	ne
    748c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    7490:	4770      	bxeq	lr
    7492:	b530      	push	{r4, r5, lr}
    7494:	f44f 7460 	mov.w	r4, #896	; 0x380
    7498:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    749c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    74a0:	e720      	b.n	72e4 <__adddf3+0x138>
    74a2:	bf00      	nop

000074a4 <__aeabi_ul2d>:
    74a4:	ea50 0201 	orrs.w	r2, r0, r1
    74a8:	bf08      	it	eq
    74aa:	4770      	bxeq	lr
    74ac:	b530      	push	{r4, r5, lr}
    74ae:	f04f 0500 	mov.w	r5, #0
    74b2:	e00a      	b.n	74ca <__aeabi_l2d+0x16>

000074b4 <__aeabi_l2d>:
    74b4:	ea50 0201 	orrs.w	r2, r0, r1
    74b8:	bf08      	it	eq
    74ba:	4770      	bxeq	lr
    74bc:	b530      	push	{r4, r5, lr}
    74be:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    74c2:	d502      	bpl.n	74ca <__aeabi_l2d+0x16>
    74c4:	4240      	negs	r0, r0
    74c6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    74ca:	f44f 6480 	mov.w	r4, #1024	; 0x400
    74ce:	f104 0432 	add.w	r4, r4, #50	; 0x32
    74d2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    74d6:	f43f aedc 	beq.w	7292 <__adddf3+0xe6>
    74da:	f04f 0203 	mov.w	r2, #3
    74de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    74e2:	bf18      	it	ne
    74e4:	3203      	addne	r2, #3
    74e6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    74ea:	bf18      	it	ne
    74ec:	3203      	addne	r2, #3
    74ee:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    74f2:	f1c2 0320 	rsb	r3, r2, #32
    74f6:	fa00 fc03 	lsl.w	ip, r0, r3
    74fa:	fa20 f002 	lsr.w	r0, r0, r2
    74fe:	fa01 fe03 	lsl.w	lr, r1, r3
    7502:	ea40 000e 	orr.w	r0, r0, lr
    7506:	fa21 f102 	lsr.w	r1, r1, r2
    750a:	4414      	add	r4, r2
    750c:	e6c1      	b.n	7292 <__adddf3+0xe6>
    750e:	bf00      	nop

00007510 <__aeabi_d2uiz>:
    7510:	004a      	lsls	r2, r1, #1
    7512:	d211      	bcs.n	7538 <__aeabi_d2uiz+0x28>
    7514:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    7518:	d211      	bcs.n	753e <__aeabi_d2uiz+0x2e>
    751a:	d50d      	bpl.n	7538 <__aeabi_d2uiz+0x28>
    751c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    7520:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    7524:	d40e      	bmi.n	7544 <__aeabi_d2uiz+0x34>
    7526:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    752a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    752e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    7532:	fa23 f002 	lsr.w	r0, r3, r2
    7536:	4770      	bx	lr
    7538:	f04f 0000 	mov.w	r0, #0
    753c:	4770      	bx	lr
    753e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    7542:	d102      	bne.n	754a <__aeabi_d2uiz+0x3a>
    7544:	f04f 30ff 	mov.w	r0, #4294967295
    7548:	4770      	bx	lr
    754a:	f04f 0000 	mov.w	r0, #0
    754e:	4770      	bx	lr

00007550 <__aeabi_frsub>:
    7550:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
    7554:	e002      	b.n	755c <__addsf3>
    7556:	bf00      	nop

00007558 <__aeabi_fsub>:
    7558:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0000755c <__addsf3>:
    755c:	0042      	lsls	r2, r0, #1
    755e:	bf1f      	itttt	ne
    7560:	ea5f 0341 	movsne.w	r3, r1, lsl #1
    7564:	ea92 0f03 	teqne	r2, r3
    7568:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
    756c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    7570:	d06a      	beq.n	7648 <__addsf3+0xec>
    7572:	ea4f 6212 	mov.w	r2, r2, lsr #24
    7576:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
    757a:	bfc1      	itttt	gt
    757c:	18d2      	addgt	r2, r2, r3
    757e:	4041      	eorgt	r1, r0
    7580:	4048      	eorgt	r0, r1
    7582:	4041      	eorgt	r1, r0
    7584:	bfb8      	it	lt
    7586:	425b      	neglt	r3, r3
    7588:	2b19      	cmp	r3, #25
    758a:	bf88      	it	hi
    758c:	4770      	bxhi	lr
    758e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    7592:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    7596:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    759a:	bf18      	it	ne
    759c:	4240      	negne	r0, r0
    759e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    75a2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
    75a6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    75aa:	bf18      	it	ne
    75ac:	4249      	negne	r1, r1
    75ae:	ea92 0f03 	teq	r2, r3
    75b2:	d03f      	beq.n	7634 <__addsf3+0xd8>
    75b4:	f1a2 0201 	sub.w	r2, r2, #1
    75b8:	fa41 fc03 	asr.w	ip, r1, r3
    75bc:	eb10 000c 	adds.w	r0, r0, ip
    75c0:	f1c3 0320 	rsb	r3, r3, #32
    75c4:	fa01 f103 	lsl.w	r1, r1, r3
    75c8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    75cc:	d502      	bpl.n	75d4 <__addsf3+0x78>
    75ce:	4249      	negs	r1, r1
    75d0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
    75d4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    75d8:	d313      	bcc.n	7602 <__addsf3+0xa6>
    75da:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    75de:	d306      	bcc.n	75ee <__addsf3+0x92>
    75e0:	0840      	lsrs	r0, r0, #1
    75e2:	ea4f 0131 	mov.w	r1, r1, rrx
    75e6:	f102 0201 	add.w	r2, r2, #1
    75ea:	2afe      	cmp	r2, #254	; 0xfe
    75ec:	d251      	bcs.n	7692 <__addsf3+0x136>
    75ee:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
    75f2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    75f6:	bf08      	it	eq
    75f8:	f020 0001 	biceq.w	r0, r0, #1
    75fc:	ea40 0003 	orr.w	r0, r0, r3
    7600:	4770      	bx	lr
    7602:	0049      	lsls	r1, r1, #1
    7604:	eb40 0000 	adc.w	r0, r0, r0
    7608:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
    760c:	f1a2 0201 	sub.w	r2, r2, #1
    7610:	d1ed      	bne.n	75ee <__addsf3+0x92>
    7612:	fab0 fc80 	clz	ip, r0
    7616:	f1ac 0c08 	sub.w	ip, ip, #8
    761a:	ebb2 020c 	subs.w	r2, r2, ip
    761e:	fa00 f00c 	lsl.w	r0, r0, ip
    7622:	bfaa      	itet	ge
    7624:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
    7628:	4252      	neglt	r2, r2
    762a:	4318      	orrge	r0, r3
    762c:	bfbc      	itt	lt
    762e:	40d0      	lsrlt	r0, r2
    7630:	4318      	orrlt	r0, r3
    7632:	4770      	bx	lr
    7634:	f092 0f00 	teq	r2, #0
    7638:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
    763c:	bf06      	itte	eq
    763e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
    7642:	3201      	addeq	r2, #1
    7644:	3b01      	subne	r3, #1
    7646:	e7b5      	b.n	75b4 <__addsf3+0x58>
    7648:	ea4f 0341 	mov.w	r3, r1, lsl #1
    764c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    7650:	bf18      	it	ne
    7652:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    7656:	d021      	beq.n	769c <__addsf3+0x140>
    7658:	ea92 0f03 	teq	r2, r3
    765c:	d004      	beq.n	7668 <__addsf3+0x10c>
    765e:	f092 0f00 	teq	r2, #0
    7662:	bf08      	it	eq
    7664:	4608      	moveq	r0, r1
    7666:	4770      	bx	lr
    7668:	ea90 0f01 	teq	r0, r1
    766c:	bf1c      	itt	ne
    766e:	2000      	movne	r0, #0
    7670:	4770      	bxne	lr
    7672:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
    7676:	d104      	bne.n	7682 <__addsf3+0x126>
    7678:	0040      	lsls	r0, r0, #1
    767a:	bf28      	it	cs
    767c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
    7680:	4770      	bx	lr
    7682:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
    7686:	bf3c      	itt	cc
    7688:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
    768c:	4770      	bxcc	lr
    768e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    7692:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
    7696:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    769a:	4770      	bx	lr
    769c:	ea7f 6222 	mvns.w	r2, r2, asr #24
    76a0:	bf16      	itet	ne
    76a2:	4608      	movne	r0, r1
    76a4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
    76a8:	4601      	movne	r1, r0
    76aa:	0242      	lsls	r2, r0, #9
    76ac:	bf06      	itte	eq
    76ae:	ea5f 2341 	movseq.w	r3, r1, lsl #9
    76b2:	ea90 0f01 	teqeq	r0, r1
    76b6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
    76ba:	4770      	bx	lr

000076bc <__aeabi_ui2f>:
    76bc:	f04f 0300 	mov.w	r3, #0
    76c0:	e004      	b.n	76cc <__aeabi_i2f+0x8>
    76c2:	bf00      	nop

000076c4 <__aeabi_i2f>:
    76c4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
    76c8:	bf48      	it	mi
    76ca:	4240      	negmi	r0, r0
    76cc:	ea5f 0c00 	movs.w	ip, r0
    76d0:	bf08      	it	eq
    76d2:	4770      	bxeq	lr
    76d4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
    76d8:	4601      	mov	r1, r0
    76da:	f04f 0000 	mov.w	r0, #0
    76de:	e01c      	b.n	771a <__aeabi_l2f+0x2a>

000076e0 <__aeabi_ul2f>:
    76e0:	ea50 0201 	orrs.w	r2, r0, r1
    76e4:	bf08      	it	eq
    76e6:	4770      	bxeq	lr
    76e8:	f04f 0300 	mov.w	r3, #0
    76ec:	e00a      	b.n	7704 <__aeabi_l2f+0x14>
    76ee:	bf00      	nop

000076f0 <__aeabi_l2f>:
    76f0:	ea50 0201 	orrs.w	r2, r0, r1
    76f4:	bf08      	it	eq
    76f6:	4770      	bxeq	lr
    76f8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
    76fc:	d502      	bpl.n	7704 <__aeabi_l2f+0x14>
    76fe:	4240      	negs	r0, r0
    7700:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    7704:	ea5f 0c01 	movs.w	ip, r1
    7708:	bf02      	ittt	eq
    770a:	4684      	moveq	ip, r0
    770c:	4601      	moveq	r1, r0
    770e:	2000      	moveq	r0, #0
    7710:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
    7714:	bf08      	it	eq
    7716:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
    771a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
    771e:	fabc f28c 	clz	r2, ip
    7722:	3a08      	subs	r2, #8
    7724:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
    7728:	db10      	blt.n	774c <__aeabi_l2f+0x5c>
    772a:	fa01 fc02 	lsl.w	ip, r1, r2
    772e:	4463      	add	r3, ip
    7730:	fa00 fc02 	lsl.w	ip, r0, r2
    7734:	f1c2 0220 	rsb	r2, r2, #32
    7738:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    773c:	fa20 f202 	lsr.w	r2, r0, r2
    7740:	eb43 0002 	adc.w	r0, r3, r2
    7744:	bf08      	it	eq
    7746:	f020 0001 	biceq.w	r0, r0, #1
    774a:	4770      	bx	lr
    774c:	f102 0220 	add.w	r2, r2, #32
    7750:	fa01 fc02 	lsl.w	ip, r1, r2
    7754:	f1c2 0220 	rsb	r2, r2, #32
    7758:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
    775c:	fa21 f202 	lsr.w	r2, r1, r2
    7760:	eb43 0002 	adc.w	r0, r3, r2
    7764:	bf08      	it	eq
    7766:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    776a:	4770      	bx	lr

0000776c <__aeabi_fmul>:
    776c:	f04f 0cff 	mov.w	ip, #255	; 0xff
    7770:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    7774:	bf1e      	ittt	ne
    7776:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    777a:	ea92 0f0c 	teqne	r2, ip
    777e:	ea93 0f0c 	teqne	r3, ip
    7782:	d06f      	beq.n	7864 <__aeabi_fmul+0xf8>
    7784:	441a      	add	r2, r3
    7786:	ea80 0c01 	eor.w	ip, r0, r1
    778a:	0240      	lsls	r0, r0, #9
    778c:	bf18      	it	ne
    778e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
    7792:	d01e      	beq.n	77d2 <__aeabi_fmul+0x66>
    7794:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    7798:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
    779c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
    77a0:	fba0 3101 	umull	r3, r1, r0, r1
    77a4:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    77a8:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    77ac:	bf3e      	ittt	cc
    77ae:	0049      	lslcc	r1, r1, #1
    77b0:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
    77b4:	005b      	lslcc	r3, r3, #1
    77b6:	ea40 0001 	orr.w	r0, r0, r1
    77ba:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
    77be:	2afd      	cmp	r2, #253	; 0xfd
    77c0:	d81d      	bhi.n	77fe <__aeabi_fmul+0x92>
    77c2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    77c6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    77ca:	bf08      	it	eq
    77cc:	f020 0001 	biceq.w	r0, r0, #1
    77d0:	4770      	bx	lr
    77d2:	f090 0f00 	teq	r0, #0
    77d6:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    77da:	bf08      	it	eq
    77dc:	0249      	lsleq	r1, r1, #9
    77de:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    77e2:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
    77e6:	3a7f      	subs	r2, #127	; 0x7f
    77e8:	bfc2      	ittt	gt
    77ea:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    77ee:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    77f2:	4770      	bxgt	lr
    77f4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    77f8:	f04f 0300 	mov.w	r3, #0
    77fc:	3a01      	subs	r2, #1
    77fe:	dc5d      	bgt.n	78bc <__aeabi_fmul+0x150>
    7800:	f112 0f19 	cmn.w	r2, #25
    7804:	bfdc      	itt	le
    7806:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
    780a:	4770      	bxle	lr
    780c:	f1c2 0200 	rsb	r2, r2, #0
    7810:	0041      	lsls	r1, r0, #1
    7812:	fa21 f102 	lsr.w	r1, r1, r2
    7816:	f1c2 0220 	rsb	r2, r2, #32
    781a:	fa00 fc02 	lsl.w	ip, r0, r2
    781e:	ea5f 0031 	movs.w	r0, r1, rrx
    7822:	f140 0000 	adc.w	r0, r0, #0
    7826:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
    782a:	bf08      	it	eq
    782c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    7830:	4770      	bx	lr
    7832:	f092 0f00 	teq	r2, #0
    7836:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    783a:	bf02      	ittt	eq
    783c:	0040      	lsleq	r0, r0, #1
    783e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    7842:	3a01      	subeq	r2, #1
    7844:	d0f9      	beq.n	783a <__aeabi_fmul+0xce>
    7846:	ea40 000c 	orr.w	r0, r0, ip
    784a:	f093 0f00 	teq	r3, #0
    784e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    7852:	bf02      	ittt	eq
    7854:	0049      	lsleq	r1, r1, #1
    7856:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    785a:	3b01      	subeq	r3, #1
    785c:	d0f9      	beq.n	7852 <__aeabi_fmul+0xe6>
    785e:	ea41 010c 	orr.w	r1, r1, ip
    7862:	e78f      	b.n	7784 <__aeabi_fmul+0x18>
    7864:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    7868:	ea92 0f0c 	teq	r2, ip
    786c:	bf18      	it	ne
    786e:	ea93 0f0c 	teqne	r3, ip
    7872:	d00a      	beq.n	788a <__aeabi_fmul+0x11e>
    7874:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    7878:	bf18      	it	ne
    787a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    787e:	d1d8      	bne.n	7832 <__aeabi_fmul+0xc6>
    7880:	ea80 0001 	eor.w	r0, r0, r1
    7884:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    7888:	4770      	bx	lr
    788a:	f090 0f00 	teq	r0, #0
    788e:	bf17      	itett	ne
    7890:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
    7894:	4608      	moveq	r0, r1
    7896:	f091 0f00 	teqne	r1, #0
    789a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
    789e:	d014      	beq.n	78ca <__aeabi_fmul+0x15e>
    78a0:	ea92 0f0c 	teq	r2, ip
    78a4:	d101      	bne.n	78aa <__aeabi_fmul+0x13e>
    78a6:	0242      	lsls	r2, r0, #9
    78a8:	d10f      	bne.n	78ca <__aeabi_fmul+0x15e>
    78aa:	ea93 0f0c 	teq	r3, ip
    78ae:	d103      	bne.n	78b8 <__aeabi_fmul+0x14c>
    78b0:	024b      	lsls	r3, r1, #9
    78b2:	bf18      	it	ne
    78b4:	4608      	movne	r0, r1
    78b6:	d108      	bne.n	78ca <__aeabi_fmul+0x15e>
    78b8:	ea80 0001 	eor.w	r0, r0, r1
    78bc:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    78c0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    78c4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    78c8:	4770      	bx	lr
    78ca:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    78ce:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
    78d2:	4770      	bx	lr

000078d4 <__aeabi_fdiv>:
    78d4:	f04f 0cff 	mov.w	ip, #255	; 0xff
    78d8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    78dc:	bf1e      	ittt	ne
    78de:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    78e2:	ea92 0f0c 	teqne	r2, ip
    78e6:	ea93 0f0c 	teqne	r3, ip
    78ea:	d069      	beq.n	79c0 <__aeabi_fdiv+0xec>
    78ec:	eba2 0203 	sub.w	r2, r2, r3
    78f0:	ea80 0c01 	eor.w	ip, r0, r1
    78f4:	0249      	lsls	r1, r1, #9
    78f6:	ea4f 2040 	mov.w	r0, r0, lsl #9
    78fa:	d037      	beq.n	796c <__aeabi_fdiv+0x98>
    78fc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    7900:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
    7904:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
    7908:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    790c:	428b      	cmp	r3, r1
    790e:	bf38      	it	cc
    7910:	005b      	lslcc	r3, r3, #1
    7912:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
    7916:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
    791a:	428b      	cmp	r3, r1
    791c:	bf24      	itt	cs
    791e:	1a5b      	subcs	r3, r3, r1
    7920:	ea40 000c 	orrcs.w	r0, r0, ip
    7924:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
    7928:	bf24      	itt	cs
    792a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
    792e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    7932:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
    7936:	bf24      	itt	cs
    7938:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
    793c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    7940:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    7944:	bf24      	itt	cs
    7946:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
    794a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    794e:	011b      	lsls	r3, r3, #4
    7950:	bf18      	it	ne
    7952:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
    7956:	d1e0      	bne.n	791a <__aeabi_fdiv+0x46>
    7958:	2afd      	cmp	r2, #253	; 0xfd
    795a:	f63f af50 	bhi.w	77fe <__aeabi_fmul+0x92>
    795e:	428b      	cmp	r3, r1
    7960:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    7964:	bf08      	it	eq
    7966:	f020 0001 	biceq.w	r0, r0, #1
    796a:	4770      	bx	lr
    796c:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    7970:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    7974:	327f      	adds	r2, #127	; 0x7f
    7976:	bfc2      	ittt	gt
    7978:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    797c:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    7980:	4770      	bxgt	lr
    7982:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    7986:	f04f 0300 	mov.w	r3, #0
    798a:	3a01      	subs	r2, #1
    798c:	e737      	b.n	77fe <__aeabi_fmul+0x92>
    798e:	f092 0f00 	teq	r2, #0
    7992:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    7996:	bf02      	ittt	eq
    7998:	0040      	lsleq	r0, r0, #1
    799a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    799e:	3a01      	subeq	r2, #1
    79a0:	d0f9      	beq.n	7996 <__aeabi_fdiv+0xc2>
    79a2:	ea40 000c 	orr.w	r0, r0, ip
    79a6:	f093 0f00 	teq	r3, #0
    79aa:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    79ae:	bf02      	ittt	eq
    79b0:	0049      	lsleq	r1, r1, #1
    79b2:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    79b6:	3b01      	subeq	r3, #1
    79b8:	d0f9      	beq.n	79ae <__aeabi_fdiv+0xda>
    79ba:	ea41 010c 	orr.w	r1, r1, ip
    79be:	e795      	b.n	78ec <__aeabi_fdiv+0x18>
    79c0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    79c4:	ea92 0f0c 	teq	r2, ip
    79c8:	d108      	bne.n	79dc <__aeabi_fdiv+0x108>
    79ca:	0242      	lsls	r2, r0, #9
    79cc:	f47f af7d 	bne.w	78ca <__aeabi_fmul+0x15e>
    79d0:	ea93 0f0c 	teq	r3, ip
    79d4:	f47f af70 	bne.w	78b8 <__aeabi_fmul+0x14c>
    79d8:	4608      	mov	r0, r1
    79da:	e776      	b.n	78ca <__aeabi_fmul+0x15e>
    79dc:	ea93 0f0c 	teq	r3, ip
    79e0:	d104      	bne.n	79ec <__aeabi_fdiv+0x118>
    79e2:	024b      	lsls	r3, r1, #9
    79e4:	f43f af4c 	beq.w	7880 <__aeabi_fmul+0x114>
    79e8:	4608      	mov	r0, r1
    79ea:	e76e      	b.n	78ca <__aeabi_fmul+0x15e>
    79ec:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    79f0:	bf18      	it	ne
    79f2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    79f6:	d1ca      	bne.n	798e <__aeabi_fdiv+0xba>
    79f8:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
    79fc:	f47f af5c 	bne.w	78b8 <__aeabi_fmul+0x14c>
    7a00:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
    7a04:	f47f af3c 	bne.w	7880 <__aeabi_fmul+0x114>
    7a08:	e75f      	b.n	78ca <__aeabi_fmul+0x15e>
    7a0a:	bf00      	nop

00007a0c <__gesf2>:
    7a0c:	f04f 3cff 	mov.w	ip, #4294967295
    7a10:	e006      	b.n	7a20 <__cmpsf2+0x4>
    7a12:	bf00      	nop

00007a14 <__lesf2>:
    7a14:	f04f 0c01 	mov.w	ip, #1
    7a18:	e002      	b.n	7a20 <__cmpsf2+0x4>
    7a1a:	bf00      	nop

00007a1c <__cmpsf2>:
    7a1c:	f04f 0c01 	mov.w	ip, #1
    7a20:	f84d cd04 	str.w	ip, [sp, #-4]!
    7a24:	ea4f 0240 	mov.w	r2, r0, lsl #1
    7a28:	ea4f 0341 	mov.w	r3, r1, lsl #1
    7a2c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    7a30:	bf18      	it	ne
    7a32:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    7a36:	d011      	beq.n	7a5c <__cmpsf2+0x40>
    7a38:	b001      	add	sp, #4
    7a3a:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
    7a3e:	bf18      	it	ne
    7a40:	ea90 0f01 	teqne	r0, r1
    7a44:	bf58      	it	pl
    7a46:	ebb2 0003 	subspl.w	r0, r2, r3
    7a4a:	bf88      	it	hi
    7a4c:	17c8      	asrhi	r0, r1, #31
    7a4e:	bf38      	it	cc
    7a50:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
    7a54:	bf18      	it	ne
    7a56:	f040 0001 	orrne.w	r0, r0, #1
    7a5a:	4770      	bx	lr
    7a5c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    7a60:	d102      	bne.n	7a68 <__cmpsf2+0x4c>
    7a62:	ea5f 2c40 	movs.w	ip, r0, lsl #9
    7a66:	d105      	bne.n	7a74 <__cmpsf2+0x58>
    7a68:	ea7f 6c23 	mvns.w	ip, r3, asr #24
    7a6c:	d1e4      	bne.n	7a38 <__cmpsf2+0x1c>
    7a6e:	ea5f 2c41 	movs.w	ip, r1, lsl #9
    7a72:	d0e1      	beq.n	7a38 <__cmpsf2+0x1c>
    7a74:	f85d 0b04 	ldr.w	r0, [sp], #4
    7a78:	4770      	bx	lr
    7a7a:	bf00      	nop

00007a7c <__aeabi_cfrcmple>:
    7a7c:	4684      	mov	ip, r0
    7a7e:	4608      	mov	r0, r1
    7a80:	4661      	mov	r1, ip
    7a82:	e7ff      	b.n	7a84 <__aeabi_cfcmpeq>

00007a84 <__aeabi_cfcmpeq>:
    7a84:	b50f      	push	{r0, r1, r2, r3, lr}
    7a86:	f7ff ffc9 	bl	7a1c <__cmpsf2>
    7a8a:	2800      	cmp	r0, #0
    7a8c:	bf48      	it	mi
    7a8e:	f110 0f00 	cmnmi.w	r0, #0
    7a92:	bd0f      	pop	{r0, r1, r2, r3, pc}

00007a94 <__aeabi_fcmpeq>:
    7a94:	f84d ed08 	str.w	lr, [sp, #-8]!
    7a98:	f7ff fff4 	bl	7a84 <__aeabi_cfcmpeq>
    7a9c:	bf0c      	ite	eq
    7a9e:	2001      	moveq	r0, #1
    7aa0:	2000      	movne	r0, #0
    7aa2:	f85d fb08 	ldr.w	pc, [sp], #8
    7aa6:	bf00      	nop

00007aa8 <__aeabi_fcmplt>:
    7aa8:	f84d ed08 	str.w	lr, [sp, #-8]!
    7aac:	f7ff ffea 	bl	7a84 <__aeabi_cfcmpeq>
    7ab0:	bf34      	ite	cc
    7ab2:	2001      	movcc	r0, #1
    7ab4:	2000      	movcs	r0, #0
    7ab6:	f85d fb08 	ldr.w	pc, [sp], #8
    7aba:	bf00      	nop

00007abc <__aeabi_fcmple>:
    7abc:	f84d ed08 	str.w	lr, [sp, #-8]!
    7ac0:	f7ff ffe0 	bl	7a84 <__aeabi_cfcmpeq>
    7ac4:	bf94      	ite	ls
    7ac6:	2001      	movls	r0, #1
    7ac8:	2000      	movhi	r0, #0
    7aca:	f85d fb08 	ldr.w	pc, [sp], #8
    7ace:	bf00      	nop

00007ad0 <__aeabi_fcmpge>:
    7ad0:	f84d ed08 	str.w	lr, [sp, #-8]!
    7ad4:	f7ff ffd2 	bl	7a7c <__aeabi_cfrcmple>
    7ad8:	bf94      	ite	ls
    7ada:	2001      	movls	r0, #1
    7adc:	2000      	movhi	r0, #0
    7ade:	f85d fb08 	ldr.w	pc, [sp], #8
    7ae2:	bf00      	nop

00007ae4 <__aeabi_fcmpgt>:
    7ae4:	f84d ed08 	str.w	lr, [sp, #-8]!
    7ae8:	f7ff ffc8 	bl	7a7c <__aeabi_cfrcmple>
    7aec:	bf34      	ite	cc
    7aee:	2001      	movcc	r0, #1
    7af0:	2000      	movcs	r0, #0
    7af2:	f85d fb08 	ldr.w	pc, [sp], #8
    7af6:	bf00      	nop

00007af8 <__aeabi_f2iz>:
    7af8:	ea4f 0240 	mov.w	r2, r0, lsl #1
    7afc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
    7b00:	d30f      	bcc.n	7b22 <__aeabi_f2iz+0x2a>
    7b02:	f04f 039e 	mov.w	r3, #158	; 0x9e
    7b06:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
    7b0a:	d90d      	bls.n	7b28 <__aeabi_f2iz+0x30>
    7b0c:	ea4f 2300 	mov.w	r3, r0, lsl #8
    7b10:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    7b14:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    7b18:	fa23 f002 	lsr.w	r0, r3, r2
    7b1c:	bf18      	it	ne
    7b1e:	4240      	negne	r0, r0
    7b20:	4770      	bx	lr
    7b22:	f04f 0000 	mov.w	r0, #0
    7b26:	4770      	bx	lr
    7b28:	f112 0f61 	cmn.w	r2, #97	; 0x61
    7b2c:	d101      	bne.n	7b32 <__aeabi_f2iz+0x3a>
    7b2e:	0242      	lsls	r2, r0, #9
    7b30:	d105      	bne.n	7b3e <__aeabi_f2iz+0x46>
    7b32:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
    7b36:	bf08      	it	eq
    7b38:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    7b3c:	4770      	bx	lr
    7b3e:	f04f 0000 	mov.w	r0, #0
    7b42:	4770      	bx	lr

00007b44 <__aeabi_f2uiz>:
    7b44:	0042      	lsls	r2, r0, #1
    7b46:	d20e      	bcs.n	7b66 <__aeabi_f2uiz+0x22>
    7b48:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
    7b4c:	d30b      	bcc.n	7b66 <__aeabi_f2uiz+0x22>
    7b4e:	f04f 039e 	mov.w	r3, #158	; 0x9e
    7b52:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
    7b56:	d409      	bmi.n	7b6c <__aeabi_f2uiz+0x28>
    7b58:	ea4f 2300 	mov.w	r3, r0, lsl #8
    7b5c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    7b60:	fa23 f002 	lsr.w	r0, r3, r2
    7b64:	4770      	bx	lr
    7b66:	f04f 0000 	mov.w	r0, #0
    7b6a:	4770      	bx	lr
    7b6c:	f112 0f61 	cmn.w	r2, #97	; 0x61
    7b70:	d101      	bne.n	7b76 <__aeabi_f2uiz+0x32>
    7b72:	0242      	lsls	r2, r0, #9
    7b74:	d102      	bne.n	7b7c <__aeabi_f2uiz+0x38>
    7b76:	f04f 30ff 	mov.w	r0, #4294967295
    7b7a:	4770      	bx	lr
    7b7c:	f04f 0000 	mov.w	r0, #0
    7b80:	4770      	bx	lr
    7b82:	bf00      	nop

00007b84 <atoi>:
    7b84:	220a      	movs	r2, #10
    7b86:	2100      	movs	r1, #0
    7b88:	f001 b8f8 	b.w	8d7c <strtol>

00007b8c <atol>:
    7b8c:	220a      	movs	r2, #10
    7b8e:	2100      	movs	r1, #0
    7b90:	f001 b8f4 	b.w	8d7c <strtol>

00007b94 <__cxa_atexit>:
    7b94:	4613      	mov	r3, r2
    7b96:	460a      	mov	r2, r1
    7b98:	4601      	mov	r1, r0
    7b9a:	2002      	movs	r0, #2
    7b9c:	f001 b912 	b.w	8dc4 <__register_exitproc>

00007ba0 <__errno>:
    7ba0:	4b01      	ldr	r3, [pc, #4]	; (7ba8 <__errno+0x8>)
    7ba2:	6818      	ldr	r0, [r3, #0]
    7ba4:	4770      	bx	lr
    7ba6:	bf00      	nop
    7ba8:	1fff8c40 	.word	0x1fff8c40

00007bac <__libc_init_array>:
    7bac:	b570      	push	{r4, r5, r6, lr}
    7bae:	4e0f      	ldr	r6, [pc, #60]	; (7bec <__libc_init_array+0x40>)
    7bb0:	4d0f      	ldr	r5, [pc, #60]	; (7bf0 <__libc_init_array+0x44>)
    7bb2:	1b76      	subs	r6, r6, r5
    7bb4:	10b6      	asrs	r6, r6, #2
    7bb6:	bf18      	it	ne
    7bb8:	2400      	movne	r4, #0
    7bba:	d005      	beq.n	7bc8 <__libc_init_array+0x1c>
    7bbc:	3401      	adds	r4, #1
    7bbe:	f855 3b04 	ldr.w	r3, [r5], #4
    7bc2:	4798      	blx	r3
    7bc4:	42a6      	cmp	r6, r4
    7bc6:	d1f9      	bne.n	7bbc <__libc_init_array+0x10>
    7bc8:	4e0a      	ldr	r6, [pc, #40]	; (7bf4 <__libc_init_array+0x48>)
    7bca:	4d0b      	ldr	r5, [pc, #44]	; (7bf8 <__libc_init_array+0x4c>)
    7bcc:	1b76      	subs	r6, r6, r5
    7bce:	f001 fe31 	bl	9834 <_init>
    7bd2:	10b6      	asrs	r6, r6, #2
    7bd4:	bf18      	it	ne
    7bd6:	2400      	movne	r4, #0
    7bd8:	d006      	beq.n	7be8 <__libc_init_array+0x3c>
    7bda:	3401      	adds	r4, #1
    7bdc:	f855 3b04 	ldr.w	r3, [r5], #4
    7be0:	4798      	blx	r3
    7be2:	42a6      	cmp	r6, r4
    7be4:	d1f9      	bne.n	7bda <__libc_init_array+0x2e>
    7be6:	bd70      	pop	{r4, r5, r6, pc}
    7be8:	bd70      	pop	{r4, r5, r6, pc}
    7bea:	bf00      	nop
    7bec:	00009840 	.word	0x00009840
    7bf0:	00009840 	.word	0x00009840
    7bf4:	00009864 	.word	0x00009864
    7bf8:	00009840 	.word	0x00009840

00007bfc <__locale_ctype_ptr_l>:
    7bfc:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
    7c00:	4770      	bx	lr
    7c02:	bf00      	nop

00007c04 <malloc>:
    7c04:	4b02      	ldr	r3, [pc, #8]	; (7c10 <malloc+0xc>)
    7c06:	4601      	mov	r1, r0
    7c08:	6818      	ldr	r0, [r3, #0]
    7c0a:	f000 b80b 	b.w	7c24 <_malloc_r>
    7c0e:	bf00      	nop
    7c10:	1fff8c40 	.word	0x1fff8c40

00007c14 <free>:
    7c14:	4b02      	ldr	r3, [pc, #8]	; (7c20 <free+0xc>)
    7c16:	4601      	mov	r1, r0
    7c18:	6818      	ldr	r0, [r3, #0]
    7c1a:	f001 b991 	b.w	8f40 <_free_r>
    7c1e:	bf00      	nop
    7c20:	1fff8c40 	.word	0x1fff8c40

00007c24 <_malloc_r>:
    7c24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7c28:	f101 050b 	add.w	r5, r1, #11
    7c2c:	2d16      	cmp	r5, #22
    7c2e:	b083      	sub	sp, #12
    7c30:	4606      	mov	r6, r0
    7c32:	f240 809f 	bls.w	7d74 <_malloc_r+0x150>
    7c36:	f035 0507 	bics.w	r5, r5, #7
    7c3a:	f100 80bf 	bmi.w	7dbc <_malloc_r+0x198>
    7c3e:	42a9      	cmp	r1, r5
    7c40:	f200 80bc 	bhi.w	7dbc <_malloc_r+0x198>
    7c44:	f000 fb6e 	bl	8324 <__malloc_lock>
    7c48:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    7c4c:	f0c0 829c 	bcc.w	8188 <_malloc_r+0x564>
    7c50:	0a6b      	lsrs	r3, r5, #9
    7c52:	f000 80ba 	beq.w	7dca <_malloc_r+0x1a6>
    7c56:	2b04      	cmp	r3, #4
    7c58:	f200 8183 	bhi.w	7f62 <_malloc_r+0x33e>
    7c5c:	09a8      	lsrs	r0, r5, #6
    7c5e:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    7c62:	ea4f 034e 	mov.w	r3, lr, lsl #1
    7c66:	3038      	adds	r0, #56	; 0x38
    7c68:	4fc4      	ldr	r7, [pc, #784]	; (7f7c <_malloc_r+0x358>)
    7c6a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    7c6e:	f1a3 0108 	sub.w	r1, r3, #8
    7c72:	685c      	ldr	r4, [r3, #4]
    7c74:	42a1      	cmp	r1, r4
    7c76:	d107      	bne.n	7c88 <_malloc_r+0x64>
    7c78:	e0ac      	b.n	7dd4 <_malloc_r+0x1b0>
    7c7a:	2a00      	cmp	r2, #0
    7c7c:	f280 80ac 	bge.w	7dd8 <_malloc_r+0x1b4>
    7c80:	68e4      	ldr	r4, [r4, #12]
    7c82:	42a1      	cmp	r1, r4
    7c84:	f000 80a6 	beq.w	7dd4 <_malloc_r+0x1b0>
    7c88:	6863      	ldr	r3, [r4, #4]
    7c8a:	f023 0303 	bic.w	r3, r3, #3
    7c8e:	1b5a      	subs	r2, r3, r5
    7c90:	2a0f      	cmp	r2, #15
    7c92:	ddf2      	ble.n	7c7a <_malloc_r+0x56>
    7c94:	49b9      	ldr	r1, [pc, #740]	; (7f7c <_malloc_r+0x358>)
    7c96:	693c      	ldr	r4, [r7, #16]
    7c98:	f101 0e08 	add.w	lr, r1, #8
    7c9c:	4574      	cmp	r4, lr
    7c9e:	f000 81b3 	beq.w	8008 <_malloc_r+0x3e4>
    7ca2:	6863      	ldr	r3, [r4, #4]
    7ca4:	f023 0303 	bic.w	r3, r3, #3
    7ca8:	1b5a      	subs	r2, r3, r5
    7caa:	2a0f      	cmp	r2, #15
    7cac:	f300 8199 	bgt.w	7fe2 <_malloc_r+0x3be>
    7cb0:	2a00      	cmp	r2, #0
    7cb2:	f8c1 e014 	str.w	lr, [r1, #20]
    7cb6:	f8c1 e010 	str.w	lr, [r1, #16]
    7cba:	f280 809e 	bge.w	7dfa <_malloc_r+0x1d6>
    7cbe:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    7cc2:	f080 8167 	bcs.w	7f94 <_malloc_r+0x370>
    7cc6:	08db      	lsrs	r3, r3, #3
    7cc8:	f103 0c01 	add.w	ip, r3, #1
    7ccc:	2201      	movs	r2, #1
    7cce:	109b      	asrs	r3, r3, #2
    7cd0:	fa02 f303 	lsl.w	r3, r2, r3
    7cd4:	684a      	ldr	r2, [r1, #4]
    7cd6:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    7cda:	f8c4 8008 	str.w	r8, [r4, #8]
    7cde:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    7ce2:	431a      	orrs	r2, r3
    7ce4:	f1a9 0308 	sub.w	r3, r9, #8
    7ce8:	60e3      	str	r3, [r4, #12]
    7cea:	604a      	str	r2, [r1, #4]
    7cec:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    7cf0:	f8c8 400c 	str.w	r4, [r8, #12]
    7cf4:	1083      	asrs	r3, r0, #2
    7cf6:	2401      	movs	r4, #1
    7cf8:	409c      	lsls	r4, r3
    7cfa:	4294      	cmp	r4, r2
    7cfc:	f200 808a 	bhi.w	7e14 <_malloc_r+0x1f0>
    7d00:	4214      	tst	r4, r2
    7d02:	d106      	bne.n	7d12 <_malloc_r+0xee>
    7d04:	f020 0003 	bic.w	r0, r0, #3
    7d08:	0064      	lsls	r4, r4, #1
    7d0a:	4214      	tst	r4, r2
    7d0c:	f100 0004 	add.w	r0, r0, #4
    7d10:	d0fa      	beq.n	7d08 <_malloc_r+0xe4>
    7d12:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    7d16:	46cc      	mov	ip, r9
    7d18:	4680      	mov	r8, r0
    7d1a:	f8dc 100c 	ldr.w	r1, [ip, #12]
    7d1e:	458c      	cmp	ip, r1
    7d20:	d107      	bne.n	7d32 <_malloc_r+0x10e>
    7d22:	e173      	b.n	800c <_malloc_r+0x3e8>
    7d24:	2a00      	cmp	r2, #0
    7d26:	f280 8181 	bge.w	802c <_malloc_r+0x408>
    7d2a:	68c9      	ldr	r1, [r1, #12]
    7d2c:	458c      	cmp	ip, r1
    7d2e:	f000 816d 	beq.w	800c <_malloc_r+0x3e8>
    7d32:	684b      	ldr	r3, [r1, #4]
    7d34:	f023 0303 	bic.w	r3, r3, #3
    7d38:	1b5a      	subs	r2, r3, r5
    7d3a:	2a0f      	cmp	r2, #15
    7d3c:	ddf2      	ble.n	7d24 <_malloc_r+0x100>
    7d3e:	460c      	mov	r4, r1
    7d40:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    7d44:	f854 8f08 	ldr.w	r8, [r4, #8]!
    7d48:	194b      	adds	r3, r1, r5
    7d4a:	f045 0501 	orr.w	r5, r5, #1
    7d4e:	604d      	str	r5, [r1, #4]
    7d50:	f042 0101 	orr.w	r1, r2, #1
    7d54:	f8c8 c00c 	str.w	ip, [r8, #12]
    7d58:	4630      	mov	r0, r6
    7d5a:	f8cc 8008 	str.w	r8, [ip, #8]
    7d5e:	617b      	str	r3, [r7, #20]
    7d60:	613b      	str	r3, [r7, #16]
    7d62:	f8c3 e00c 	str.w	lr, [r3, #12]
    7d66:	f8c3 e008 	str.w	lr, [r3, #8]
    7d6a:	6059      	str	r1, [r3, #4]
    7d6c:	509a      	str	r2, [r3, r2]
    7d6e:	f000 fadb 	bl	8328 <__malloc_unlock>
    7d72:	e01f      	b.n	7db4 <_malloc_r+0x190>
    7d74:	2910      	cmp	r1, #16
    7d76:	d821      	bhi.n	7dbc <_malloc_r+0x198>
    7d78:	f000 fad4 	bl	8324 <__malloc_lock>
    7d7c:	2510      	movs	r5, #16
    7d7e:	2306      	movs	r3, #6
    7d80:	2002      	movs	r0, #2
    7d82:	4f7e      	ldr	r7, [pc, #504]	; (7f7c <_malloc_r+0x358>)
    7d84:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    7d88:	f1a3 0208 	sub.w	r2, r3, #8
    7d8c:	685c      	ldr	r4, [r3, #4]
    7d8e:	4294      	cmp	r4, r2
    7d90:	f000 8145 	beq.w	801e <_malloc_r+0x3fa>
    7d94:	6863      	ldr	r3, [r4, #4]
    7d96:	68e1      	ldr	r1, [r4, #12]
    7d98:	68a5      	ldr	r5, [r4, #8]
    7d9a:	f023 0303 	bic.w	r3, r3, #3
    7d9e:	4423      	add	r3, r4
    7da0:	4630      	mov	r0, r6
    7da2:	685a      	ldr	r2, [r3, #4]
    7da4:	60e9      	str	r1, [r5, #12]
    7da6:	f042 0201 	orr.w	r2, r2, #1
    7daa:	608d      	str	r5, [r1, #8]
    7dac:	605a      	str	r2, [r3, #4]
    7dae:	f000 fabb 	bl	8328 <__malloc_unlock>
    7db2:	3408      	adds	r4, #8
    7db4:	4620      	mov	r0, r4
    7db6:	b003      	add	sp, #12
    7db8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7dbc:	2400      	movs	r4, #0
    7dbe:	230c      	movs	r3, #12
    7dc0:	4620      	mov	r0, r4
    7dc2:	6033      	str	r3, [r6, #0]
    7dc4:	b003      	add	sp, #12
    7dc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7dca:	2380      	movs	r3, #128	; 0x80
    7dcc:	f04f 0e40 	mov.w	lr, #64	; 0x40
    7dd0:	203f      	movs	r0, #63	; 0x3f
    7dd2:	e749      	b.n	7c68 <_malloc_r+0x44>
    7dd4:	4670      	mov	r0, lr
    7dd6:	e75d      	b.n	7c94 <_malloc_r+0x70>
    7dd8:	4423      	add	r3, r4
    7dda:	68e1      	ldr	r1, [r4, #12]
    7ddc:	685a      	ldr	r2, [r3, #4]
    7dde:	68a5      	ldr	r5, [r4, #8]
    7de0:	f042 0201 	orr.w	r2, r2, #1
    7de4:	60e9      	str	r1, [r5, #12]
    7de6:	4630      	mov	r0, r6
    7de8:	608d      	str	r5, [r1, #8]
    7dea:	605a      	str	r2, [r3, #4]
    7dec:	f000 fa9c 	bl	8328 <__malloc_unlock>
    7df0:	3408      	adds	r4, #8
    7df2:	4620      	mov	r0, r4
    7df4:	b003      	add	sp, #12
    7df6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7dfa:	4423      	add	r3, r4
    7dfc:	4630      	mov	r0, r6
    7dfe:	685a      	ldr	r2, [r3, #4]
    7e00:	f042 0201 	orr.w	r2, r2, #1
    7e04:	605a      	str	r2, [r3, #4]
    7e06:	f000 fa8f 	bl	8328 <__malloc_unlock>
    7e0a:	3408      	adds	r4, #8
    7e0c:	4620      	mov	r0, r4
    7e0e:	b003      	add	sp, #12
    7e10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e14:	68bc      	ldr	r4, [r7, #8]
    7e16:	6863      	ldr	r3, [r4, #4]
    7e18:	f023 0803 	bic.w	r8, r3, #3
    7e1c:	45a8      	cmp	r8, r5
    7e1e:	d304      	bcc.n	7e2a <_malloc_r+0x206>
    7e20:	ebc5 0308 	rsb	r3, r5, r8
    7e24:	2b0f      	cmp	r3, #15
    7e26:	f300 808c 	bgt.w	7f42 <_malloc_r+0x31e>
    7e2a:	4b55      	ldr	r3, [pc, #340]	; (7f80 <_malloc_r+0x35c>)
    7e2c:	f8df 9160 	ldr.w	r9, [pc, #352]	; 7f90 <_malloc_r+0x36c>
    7e30:	681a      	ldr	r2, [r3, #0]
    7e32:	f8d9 3000 	ldr.w	r3, [r9]
    7e36:	3301      	adds	r3, #1
    7e38:	442a      	add	r2, r5
    7e3a:	eb04 0a08 	add.w	sl, r4, r8
    7e3e:	f000 8160 	beq.w	8102 <_malloc_r+0x4de>
    7e42:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    7e46:	320f      	adds	r2, #15
    7e48:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    7e4c:	f022 020f 	bic.w	r2, r2, #15
    7e50:	4611      	mov	r1, r2
    7e52:	4630      	mov	r0, r6
    7e54:	9201      	str	r2, [sp, #4]
    7e56:	f000 fc61 	bl	871c <_sbrk_r>
    7e5a:	f1b0 3fff 	cmp.w	r0, #4294967295
    7e5e:	4683      	mov	fp, r0
    7e60:	9a01      	ldr	r2, [sp, #4]
    7e62:	f000 8158 	beq.w	8116 <_malloc_r+0x4f2>
    7e66:	4582      	cmp	sl, r0
    7e68:	f200 80fc 	bhi.w	8064 <_malloc_r+0x440>
    7e6c:	4b45      	ldr	r3, [pc, #276]	; (7f84 <_malloc_r+0x360>)
    7e6e:	6819      	ldr	r1, [r3, #0]
    7e70:	45da      	cmp	sl, fp
    7e72:	4411      	add	r1, r2
    7e74:	6019      	str	r1, [r3, #0]
    7e76:	f000 8153 	beq.w	8120 <_malloc_r+0x4fc>
    7e7a:	f8d9 0000 	ldr.w	r0, [r9]
    7e7e:	f8df e110 	ldr.w	lr, [pc, #272]	; 7f90 <_malloc_r+0x36c>
    7e82:	3001      	adds	r0, #1
    7e84:	bf1b      	ittet	ne
    7e86:	ebca 0a0b 	rsbne	sl, sl, fp
    7e8a:	4451      	addne	r1, sl
    7e8c:	f8ce b000 	streq.w	fp, [lr]
    7e90:	6019      	strne	r1, [r3, #0]
    7e92:	f01b 0107 	ands.w	r1, fp, #7
    7e96:	f000 8117 	beq.w	80c8 <_malloc_r+0x4a4>
    7e9a:	f1c1 0008 	rsb	r0, r1, #8
    7e9e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    7ea2:	4483      	add	fp, r0
    7ea4:	3108      	adds	r1, #8
    7ea6:	445a      	add	r2, fp
    7ea8:	f3c2 020b 	ubfx	r2, r2, #0, #12
    7eac:	ebc2 0901 	rsb	r9, r2, r1
    7eb0:	4649      	mov	r1, r9
    7eb2:	4630      	mov	r0, r6
    7eb4:	9301      	str	r3, [sp, #4]
    7eb6:	f000 fc31 	bl	871c <_sbrk_r>
    7eba:	1c43      	adds	r3, r0, #1
    7ebc:	9b01      	ldr	r3, [sp, #4]
    7ebe:	f000 813f 	beq.w	8140 <_malloc_r+0x51c>
    7ec2:	ebcb 0200 	rsb	r2, fp, r0
    7ec6:	444a      	add	r2, r9
    7ec8:	f042 0201 	orr.w	r2, r2, #1
    7ecc:	6819      	ldr	r1, [r3, #0]
    7ece:	f8c7 b008 	str.w	fp, [r7, #8]
    7ed2:	4449      	add	r1, r9
    7ed4:	42bc      	cmp	r4, r7
    7ed6:	f8cb 2004 	str.w	r2, [fp, #4]
    7eda:	6019      	str	r1, [r3, #0]
    7edc:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 7f84 <_malloc_r+0x360>
    7ee0:	d016      	beq.n	7f10 <_malloc_r+0x2ec>
    7ee2:	f1b8 0f0f 	cmp.w	r8, #15
    7ee6:	f240 80fd 	bls.w	80e4 <_malloc_r+0x4c0>
    7eea:	6862      	ldr	r2, [r4, #4]
    7eec:	f1a8 030c 	sub.w	r3, r8, #12
    7ef0:	f023 0307 	bic.w	r3, r3, #7
    7ef4:	18e0      	adds	r0, r4, r3
    7ef6:	f002 0201 	and.w	r2, r2, #1
    7efa:	f04f 0e05 	mov.w	lr, #5
    7efe:	431a      	orrs	r2, r3
    7f00:	2b0f      	cmp	r3, #15
    7f02:	6062      	str	r2, [r4, #4]
    7f04:	f8c0 e004 	str.w	lr, [r0, #4]
    7f08:	f8c0 e008 	str.w	lr, [r0, #8]
    7f0c:	f200 811c 	bhi.w	8148 <_malloc_r+0x524>
    7f10:	4b1d      	ldr	r3, [pc, #116]	; (7f88 <_malloc_r+0x364>)
    7f12:	68bc      	ldr	r4, [r7, #8]
    7f14:	681a      	ldr	r2, [r3, #0]
    7f16:	4291      	cmp	r1, r2
    7f18:	bf88      	it	hi
    7f1a:	6019      	strhi	r1, [r3, #0]
    7f1c:	4b1b      	ldr	r3, [pc, #108]	; (7f8c <_malloc_r+0x368>)
    7f1e:	681a      	ldr	r2, [r3, #0]
    7f20:	4291      	cmp	r1, r2
    7f22:	6862      	ldr	r2, [r4, #4]
    7f24:	bf88      	it	hi
    7f26:	6019      	strhi	r1, [r3, #0]
    7f28:	f022 0203 	bic.w	r2, r2, #3
    7f2c:	4295      	cmp	r5, r2
    7f2e:	eba2 0305 	sub.w	r3, r2, r5
    7f32:	d801      	bhi.n	7f38 <_malloc_r+0x314>
    7f34:	2b0f      	cmp	r3, #15
    7f36:	dc04      	bgt.n	7f42 <_malloc_r+0x31e>
    7f38:	4630      	mov	r0, r6
    7f3a:	f000 f9f5 	bl	8328 <__malloc_unlock>
    7f3e:	2400      	movs	r4, #0
    7f40:	e738      	b.n	7db4 <_malloc_r+0x190>
    7f42:	1962      	adds	r2, r4, r5
    7f44:	f043 0301 	orr.w	r3, r3, #1
    7f48:	f045 0501 	orr.w	r5, r5, #1
    7f4c:	6065      	str	r5, [r4, #4]
    7f4e:	4630      	mov	r0, r6
    7f50:	60ba      	str	r2, [r7, #8]
    7f52:	6053      	str	r3, [r2, #4]
    7f54:	f000 f9e8 	bl	8328 <__malloc_unlock>
    7f58:	3408      	adds	r4, #8
    7f5a:	4620      	mov	r0, r4
    7f5c:	b003      	add	sp, #12
    7f5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7f62:	2b14      	cmp	r3, #20
    7f64:	d971      	bls.n	804a <_malloc_r+0x426>
    7f66:	2b54      	cmp	r3, #84	; 0x54
    7f68:	f200 80a4 	bhi.w	80b4 <_malloc_r+0x490>
    7f6c:	0b28      	lsrs	r0, r5, #12
    7f6e:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    7f72:	ea4f 034e 	mov.w	r3, lr, lsl #1
    7f76:	306e      	adds	r0, #110	; 0x6e
    7f78:	e676      	b.n	7c68 <_malloc_r+0x44>
    7f7a:	bf00      	nop
    7f7c:	1fff8db0 	.word	0x1fff8db0
    7f80:	1fffb614 	.word	0x1fffb614
    7f84:	1fffb618 	.word	0x1fffb618
    7f88:	1fffb610 	.word	0x1fffb610
    7f8c:	1fffb60c 	.word	0x1fffb60c
    7f90:	1fff91bc 	.word	0x1fff91bc
    7f94:	0a5a      	lsrs	r2, r3, #9
    7f96:	2a04      	cmp	r2, #4
    7f98:	d95e      	bls.n	8058 <_malloc_r+0x434>
    7f9a:	2a14      	cmp	r2, #20
    7f9c:	f200 80b3 	bhi.w	8106 <_malloc_r+0x4e2>
    7fa0:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    7fa4:	0049      	lsls	r1, r1, #1
    7fa6:	325b      	adds	r2, #91	; 0x5b
    7fa8:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    7fac:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    7fb0:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 8190 <_malloc_r+0x56c>
    7fb4:	f1ac 0c08 	sub.w	ip, ip, #8
    7fb8:	458c      	cmp	ip, r1
    7fba:	f000 8088 	beq.w	80ce <_malloc_r+0x4aa>
    7fbe:	684a      	ldr	r2, [r1, #4]
    7fc0:	f022 0203 	bic.w	r2, r2, #3
    7fc4:	4293      	cmp	r3, r2
    7fc6:	d202      	bcs.n	7fce <_malloc_r+0x3aa>
    7fc8:	6889      	ldr	r1, [r1, #8]
    7fca:	458c      	cmp	ip, r1
    7fcc:	d1f7      	bne.n	7fbe <_malloc_r+0x39a>
    7fce:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    7fd2:	687a      	ldr	r2, [r7, #4]
    7fd4:	f8c4 c00c 	str.w	ip, [r4, #12]
    7fd8:	60a1      	str	r1, [r4, #8]
    7fda:	f8cc 4008 	str.w	r4, [ip, #8]
    7fde:	60cc      	str	r4, [r1, #12]
    7fe0:	e688      	b.n	7cf4 <_malloc_r+0xd0>
    7fe2:	1963      	adds	r3, r4, r5
    7fe4:	f042 0701 	orr.w	r7, r2, #1
    7fe8:	f045 0501 	orr.w	r5, r5, #1
    7fec:	6065      	str	r5, [r4, #4]
    7fee:	4630      	mov	r0, r6
    7ff0:	614b      	str	r3, [r1, #20]
    7ff2:	610b      	str	r3, [r1, #16]
    7ff4:	f8c3 e00c 	str.w	lr, [r3, #12]
    7ff8:	f8c3 e008 	str.w	lr, [r3, #8]
    7ffc:	605f      	str	r7, [r3, #4]
    7ffe:	509a      	str	r2, [r3, r2]
    8000:	3408      	adds	r4, #8
    8002:	f000 f991 	bl	8328 <__malloc_unlock>
    8006:	e6d5      	b.n	7db4 <_malloc_r+0x190>
    8008:	684a      	ldr	r2, [r1, #4]
    800a:	e673      	b.n	7cf4 <_malloc_r+0xd0>
    800c:	f108 0801 	add.w	r8, r8, #1
    8010:	f018 0f03 	tst.w	r8, #3
    8014:	f10c 0c08 	add.w	ip, ip, #8
    8018:	f47f ae7f 	bne.w	7d1a <_malloc_r+0xf6>
    801c:	e030      	b.n	8080 <_malloc_r+0x45c>
    801e:	68dc      	ldr	r4, [r3, #12]
    8020:	42a3      	cmp	r3, r4
    8022:	bf08      	it	eq
    8024:	3002      	addeq	r0, #2
    8026:	f43f ae35 	beq.w	7c94 <_malloc_r+0x70>
    802a:	e6b3      	b.n	7d94 <_malloc_r+0x170>
    802c:	440b      	add	r3, r1
    802e:	460c      	mov	r4, r1
    8030:	685a      	ldr	r2, [r3, #4]
    8032:	68c9      	ldr	r1, [r1, #12]
    8034:	f854 5f08 	ldr.w	r5, [r4, #8]!
    8038:	f042 0201 	orr.w	r2, r2, #1
    803c:	605a      	str	r2, [r3, #4]
    803e:	4630      	mov	r0, r6
    8040:	60e9      	str	r1, [r5, #12]
    8042:	608d      	str	r5, [r1, #8]
    8044:	f000 f970 	bl	8328 <__malloc_unlock>
    8048:	e6b4      	b.n	7db4 <_malloc_r+0x190>
    804a:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    804e:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    8052:	ea4f 034e 	mov.w	r3, lr, lsl #1
    8056:	e607      	b.n	7c68 <_malloc_r+0x44>
    8058:	099a      	lsrs	r2, r3, #6
    805a:	f102 0139 	add.w	r1, r2, #57	; 0x39
    805e:	0049      	lsls	r1, r1, #1
    8060:	3238      	adds	r2, #56	; 0x38
    8062:	e7a1      	b.n	7fa8 <_malloc_r+0x384>
    8064:	42bc      	cmp	r4, r7
    8066:	4b4a      	ldr	r3, [pc, #296]	; (8190 <_malloc_r+0x56c>)
    8068:	f43f af00 	beq.w	7e6c <_malloc_r+0x248>
    806c:	689c      	ldr	r4, [r3, #8]
    806e:	6862      	ldr	r2, [r4, #4]
    8070:	f022 0203 	bic.w	r2, r2, #3
    8074:	e75a      	b.n	7f2c <_malloc_r+0x308>
    8076:	f859 3908 	ldr.w	r3, [r9], #-8
    807a:	4599      	cmp	r9, r3
    807c:	f040 8082 	bne.w	8184 <_malloc_r+0x560>
    8080:	f010 0f03 	tst.w	r0, #3
    8084:	f100 30ff 	add.w	r0, r0, #4294967295
    8088:	d1f5      	bne.n	8076 <_malloc_r+0x452>
    808a:	687b      	ldr	r3, [r7, #4]
    808c:	ea23 0304 	bic.w	r3, r3, r4
    8090:	607b      	str	r3, [r7, #4]
    8092:	0064      	lsls	r4, r4, #1
    8094:	429c      	cmp	r4, r3
    8096:	f63f aebd 	bhi.w	7e14 <_malloc_r+0x1f0>
    809a:	2c00      	cmp	r4, #0
    809c:	f43f aeba 	beq.w	7e14 <_malloc_r+0x1f0>
    80a0:	421c      	tst	r4, r3
    80a2:	4640      	mov	r0, r8
    80a4:	f47f ae35 	bne.w	7d12 <_malloc_r+0xee>
    80a8:	0064      	lsls	r4, r4, #1
    80aa:	421c      	tst	r4, r3
    80ac:	f100 0004 	add.w	r0, r0, #4
    80b0:	d0fa      	beq.n	80a8 <_malloc_r+0x484>
    80b2:	e62e      	b.n	7d12 <_malloc_r+0xee>
    80b4:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    80b8:	d818      	bhi.n	80ec <_malloc_r+0x4c8>
    80ba:	0be8      	lsrs	r0, r5, #15
    80bc:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    80c0:	ea4f 034e 	mov.w	r3, lr, lsl #1
    80c4:	3077      	adds	r0, #119	; 0x77
    80c6:	e5cf      	b.n	7c68 <_malloc_r+0x44>
    80c8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    80cc:	e6eb      	b.n	7ea6 <_malloc_r+0x282>
    80ce:	2101      	movs	r1, #1
    80d0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    80d4:	1092      	asrs	r2, r2, #2
    80d6:	fa01 f202 	lsl.w	r2, r1, r2
    80da:	431a      	orrs	r2, r3
    80dc:	f8c8 2004 	str.w	r2, [r8, #4]
    80e0:	4661      	mov	r1, ip
    80e2:	e777      	b.n	7fd4 <_malloc_r+0x3b0>
    80e4:	2301      	movs	r3, #1
    80e6:	f8cb 3004 	str.w	r3, [fp, #4]
    80ea:	e725      	b.n	7f38 <_malloc_r+0x314>
    80ec:	f240 5254 	movw	r2, #1364	; 0x554
    80f0:	4293      	cmp	r3, r2
    80f2:	d820      	bhi.n	8136 <_malloc_r+0x512>
    80f4:	0ca8      	lsrs	r0, r5, #18
    80f6:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    80fa:	ea4f 034e 	mov.w	r3, lr, lsl #1
    80fe:	307c      	adds	r0, #124	; 0x7c
    8100:	e5b2      	b.n	7c68 <_malloc_r+0x44>
    8102:	3210      	adds	r2, #16
    8104:	e6a4      	b.n	7e50 <_malloc_r+0x22c>
    8106:	2a54      	cmp	r2, #84	; 0x54
    8108:	d826      	bhi.n	8158 <_malloc_r+0x534>
    810a:	0b1a      	lsrs	r2, r3, #12
    810c:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    8110:	0049      	lsls	r1, r1, #1
    8112:	326e      	adds	r2, #110	; 0x6e
    8114:	e748      	b.n	7fa8 <_malloc_r+0x384>
    8116:	68bc      	ldr	r4, [r7, #8]
    8118:	6862      	ldr	r2, [r4, #4]
    811a:	f022 0203 	bic.w	r2, r2, #3
    811e:	e705      	b.n	7f2c <_malloc_r+0x308>
    8120:	f3ca 000b 	ubfx	r0, sl, #0, #12
    8124:	2800      	cmp	r0, #0
    8126:	f47f aea8 	bne.w	7e7a <_malloc_r+0x256>
    812a:	4442      	add	r2, r8
    812c:	68bb      	ldr	r3, [r7, #8]
    812e:	f042 0201 	orr.w	r2, r2, #1
    8132:	605a      	str	r2, [r3, #4]
    8134:	e6ec      	b.n	7f10 <_malloc_r+0x2ec>
    8136:	23fe      	movs	r3, #254	; 0xfe
    8138:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    813c:	207e      	movs	r0, #126	; 0x7e
    813e:	e593      	b.n	7c68 <_malloc_r+0x44>
    8140:	2201      	movs	r2, #1
    8142:	f04f 0900 	mov.w	r9, #0
    8146:	e6c1      	b.n	7ecc <_malloc_r+0x2a8>
    8148:	f104 0108 	add.w	r1, r4, #8
    814c:	4630      	mov	r0, r6
    814e:	f000 fef7 	bl	8f40 <_free_r>
    8152:	f8d9 1000 	ldr.w	r1, [r9]
    8156:	e6db      	b.n	7f10 <_malloc_r+0x2ec>
    8158:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    815c:	d805      	bhi.n	816a <_malloc_r+0x546>
    815e:	0bda      	lsrs	r2, r3, #15
    8160:	f102 0178 	add.w	r1, r2, #120	; 0x78
    8164:	0049      	lsls	r1, r1, #1
    8166:	3277      	adds	r2, #119	; 0x77
    8168:	e71e      	b.n	7fa8 <_malloc_r+0x384>
    816a:	f240 5154 	movw	r1, #1364	; 0x554
    816e:	428a      	cmp	r2, r1
    8170:	d805      	bhi.n	817e <_malloc_r+0x55a>
    8172:	0c9a      	lsrs	r2, r3, #18
    8174:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    8178:	0049      	lsls	r1, r1, #1
    817a:	327c      	adds	r2, #124	; 0x7c
    817c:	e714      	b.n	7fa8 <_malloc_r+0x384>
    817e:	21fe      	movs	r1, #254	; 0xfe
    8180:	227e      	movs	r2, #126	; 0x7e
    8182:	e711      	b.n	7fa8 <_malloc_r+0x384>
    8184:	687b      	ldr	r3, [r7, #4]
    8186:	e784      	b.n	8092 <_malloc_r+0x46e>
    8188:	08e8      	lsrs	r0, r5, #3
    818a:	1c43      	adds	r3, r0, #1
    818c:	005b      	lsls	r3, r3, #1
    818e:	e5f8      	b.n	7d82 <_malloc_r+0x15e>
    8190:	1fff8db0 	.word	0x1fff8db0

00008194 <__ascii_mbtowc>:
    8194:	b082      	sub	sp, #8
    8196:	b149      	cbz	r1, 81ac <__ascii_mbtowc+0x18>
    8198:	b15a      	cbz	r2, 81b2 <__ascii_mbtowc+0x1e>
    819a:	b16b      	cbz	r3, 81b8 <__ascii_mbtowc+0x24>
    819c:	7813      	ldrb	r3, [r2, #0]
    819e:	600b      	str	r3, [r1, #0]
    81a0:	7812      	ldrb	r2, [r2, #0]
    81a2:	1c10      	adds	r0, r2, #0
    81a4:	bf18      	it	ne
    81a6:	2001      	movne	r0, #1
    81a8:	b002      	add	sp, #8
    81aa:	4770      	bx	lr
    81ac:	a901      	add	r1, sp, #4
    81ae:	2a00      	cmp	r2, #0
    81b0:	d1f3      	bne.n	819a <__ascii_mbtowc+0x6>
    81b2:	4610      	mov	r0, r2
    81b4:	b002      	add	sp, #8
    81b6:	4770      	bx	lr
    81b8:	f06f 0001 	mvn.w	r0, #1
    81bc:	e7f4      	b.n	81a8 <__ascii_mbtowc+0x14>
    81be:	bf00      	nop

000081c0 <memmove>:
    81c0:	4288      	cmp	r0, r1
    81c2:	b5f0      	push	{r4, r5, r6, r7, lr}
    81c4:	d90d      	bls.n	81e2 <memmove+0x22>
    81c6:	188b      	adds	r3, r1, r2
    81c8:	4298      	cmp	r0, r3
    81ca:	d20a      	bcs.n	81e2 <memmove+0x22>
    81cc:	1881      	adds	r1, r0, r2
    81ce:	2a00      	cmp	r2, #0
    81d0:	d051      	beq.n	8276 <memmove+0xb6>
    81d2:	1a9a      	subs	r2, r3, r2
    81d4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    81d8:	f801 4d01 	strb.w	r4, [r1, #-1]!
    81dc:	4293      	cmp	r3, r2
    81de:	d1f9      	bne.n	81d4 <memmove+0x14>
    81e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    81e2:	2a0f      	cmp	r2, #15
    81e4:	d948      	bls.n	8278 <memmove+0xb8>
    81e6:	ea41 0300 	orr.w	r3, r1, r0
    81ea:	079b      	lsls	r3, r3, #30
    81ec:	d146      	bne.n	827c <memmove+0xbc>
    81ee:	f100 0410 	add.w	r4, r0, #16
    81f2:	f101 0310 	add.w	r3, r1, #16
    81f6:	4615      	mov	r5, r2
    81f8:	f853 6c10 	ldr.w	r6, [r3, #-16]
    81fc:	f844 6c10 	str.w	r6, [r4, #-16]
    8200:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    8204:	f844 6c0c 	str.w	r6, [r4, #-12]
    8208:	f853 6c08 	ldr.w	r6, [r3, #-8]
    820c:	f844 6c08 	str.w	r6, [r4, #-8]
    8210:	3d10      	subs	r5, #16
    8212:	f853 6c04 	ldr.w	r6, [r3, #-4]
    8216:	f844 6c04 	str.w	r6, [r4, #-4]
    821a:	2d0f      	cmp	r5, #15
    821c:	f103 0310 	add.w	r3, r3, #16
    8220:	f104 0410 	add.w	r4, r4, #16
    8224:	d8e8      	bhi.n	81f8 <memmove+0x38>
    8226:	f1a2 0310 	sub.w	r3, r2, #16
    822a:	f023 030f 	bic.w	r3, r3, #15
    822e:	f002 0e0f 	and.w	lr, r2, #15
    8232:	3310      	adds	r3, #16
    8234:	f1be 0f03 	cmp.w	lr, #3
    8238:	4419      	add	r1, r3
    823a:	4403      	add	r3, r0
    823c:	d921      	bls.n	8282 <memmove+0xc2>
    823e:	1f1e      	subs	r6, r3, #4
    8240:	460d      	mov	r5, r1
    8242:	4674      	mov	r4, lr
    8244:	3c04      	subs	r4, #4
    8246:	f855 7b04 	ldr.w	r7, [r5], #4
    824a:	f846 7f04 	str.w	r7, [r6, #4]!
    824e:	2c03      	cmp	r4, #3
    8250:	d8f8      	bhi.n	8244 <memmove+0x84>
    8252:	f1ae 0404 	sub.w	r4, lr, #4
    8256:	f024 0403 	bic.w	r4, r4, #3
    825a:	3404      	adds	r4, #4
    825c:	4423      	add	r3, r4
    825e:	4421      	add	r1, r4
    8260:	f002 0203 	and.w	r2, r2, #3
    8264:	b162      	cbz	r2, 8280 <memmove+0xc0>
    8266:	3b01      	subs	r3, #1
    8268:	440a      	add	r2, r1
    826a:	f811 4b01 	ldrb.w	r4, [r1], #1
    826e:	f803 4f01 	strb.w	r4, [r3, #1]!
    8272:	428a      	cmp	r2, r1
    8274:	d1f9      	bne.n	826a <memmove+0xaa>
    8276:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8278:	4603      	mov	r3, r0
    827a:	e7f3      	b.n	8264 <memmove+0xa4>
    827c:	4603      	mov	r3, r0
    827e:	e7f2      	b.n	8266 <memmove+0xa6>
    8280:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8282:	4672      	mov	r2, lr
    8284:	e7ee      	b.n	8264 <memmove+0xa4>
    8286:	bf00      	nop

00008288 <memset>:
    8288:	b470      	push	{r4, r5, r6}
    828a:	0784      	lsls	r4, r0, #30
    828c:	d046      	beq.n	831c <memset+0x94>
    828e:	1e54      	subs	r4, r2, #1
    8290:	2a00      	cmp	r2, #0
    8292:	d041      	beq.n	8318 <memset+0x90>
    8294:	b2cd      	uxtb	r5, r1
    8296:	4603      	mov	r3, r0
    8298:	e002      	b.n	82a0 <memset+0x18>
    829a:	1e62      	subs	r2, r4, #1
    829c:	b3e4      	cbz	r4, 8318 <memset+0x90>
    829e:	4614      	mov	r4, r2
    82a0:	f803 5b01 	strb.w	r5, [r3], #1
    82a4:	079a      	lsls	r2, r3, #30
    82a6:	d1f8      	bne.n	829a <memset+0x12>
    82a8:	2c03      	cmp	r4, #3
    82aa:	d92e      	bls.n	830a <memset+0x82>
    82ac:	b2cd      	uxtb	r5, r1
    82ae:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    82b2:	2c0f      	cmp	r4, #15
    82b4:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    82b8:	d919      	bls.n	82ee <memset+0x66>
    82ba:	f103 0210 	add.w	r2, r3, #16
    82be:	4626      	mov	r6, r4
    82c0:	3e10      	subs	r6, #16
    82c2:	2e0f      	cmp	r6, #15
    82c4:	f842 5c10 	str.w	r5, [r2, #-16]
    82c8:	f842 5c0c 	str.w	r5, [r2, #-12]
    82cc:	f842 5c08 	str.w	r5, [r2, #-8]
    82d0:	f842 5c04 	str.w	r5, [r2, #-4]
    82d4:	f102 0210 	add.w	r2, r2, #16
    82d8:	d8f2      	bhi.n	82c0 <memset+0x38>
    82da:	f1a4 0210 	sub.w	r2, r4, #16
    82de:	f022 020f 	bic.w	r2, r2, #15
    82e2:	f004 040f 	and.w	r4, r4, #15
    82e6:	3210      	adds	r2, #16
    82e8:	2c03      	cmp	r4, #3
    82ea:	4413      	add	r3, r2
    82ec:	d90d      	bls.n	830a <memset+0x82>
    82ee:	461e      	mov	r6, r3
    82f0:	4622      	mov	r2, r4
    82f2:	3a04      	subs	r2, #4
    82f4:	2a03      	cmp	r2, #3
    82f6:	f846 5b04 	str.w	r5, [r6], #4
    82fa:	d8fa      	bhi.n	82f2 <memset+0x6a>
    82fc:	1f22      	subs	r2, r4, #4
    82fe:	f022 0203 	bic.w	r2, r2, #3
    8302:	3204      	adds	r2, #4
    8304:	4413      	add	r3, r2
    8306:	f004 0403 	and.w	r4, r4, #3
    830a:	b12c      	cbz	r4, 8318 <memset+0x90>
    830c:	b2c9      	uxtb	r1, r1
    830e:	441c      	add	r4, r3
    8310:	f803 1b01 	strb.w	r1, [r3], #1
    8314:	42a3      	cmp	r3, r4
    8316:	d1fb      	bne.n	8310 <memset+0x88>
    8318:	bc70      	pop	{r4, r5, r6}
    831a:	4770      	bx	lr
    831c:	4614      	mov	r4, r2
    831e:	4603      	mov	r3, r0
    8320:	e7c2      	b.n	82a8 <memset+0x20>
    8322:	bf00      	nop

00008324 <__malloc_lock>:
    8324:	4770      	bx	lr
    8326:	bf00      	nop

00008328 <__malloc_unlock>:
    8328:	4770      	bx	lr
    832a:	bf00      	nop

0000832c <realloc>:
    832c:	4b02      	ldr	r3, [pc, #8]	; (8338 <realloc+0xc>)
    832e:	460a      	mov	r2, r1
    8330:	4601      	mov	r1, r0
    8332:	6818      	ldr	r0, [r3, #0]
    8334:	f000 b802 	b.w	833c <_realloc_r>
    8338:	1fff8c40 	.word	0x1fff8c40

0000833c <_realloc_r>:
    833c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8340:	4617      	mov	r7, r2
    8342:	b083      	sub	sp, #12
    8344:	2900      	cmp	r1, #0
    8346:	f000 80c1 	beq.w	84cc <_realloc_r+0x190>
    834a:	460e      	mov	r6, r1
    834c:	4681      	mov	r9, r0
    834e:	f107 050b 	add.w	r5, r7, #11
    8352:	f7ff ffe7 	bl	8324 <__malloc_lock>
    8356:	f856 ec04 	ldr.w	lr, [r6, #-4]
    835a:	2d16      	cmp	r5, #22
    835c:	f02e 0403 	bic.w	r4, lr, #3
    8360:	f1a6 0808 	sub.w	r8, r6, #8
    8364:	d840      	bhi.n	83e8 <_realloc_r+0xac>
    8366:	2210      	movs	r2, #16
    8368:	4615      	mov	r5, r2
    836a:	42af      	cmp	r7, r5
    836c:	d841      	bhi.n	83f2 <_realloc_r+0xb6>
    836e:	4294      	cmp	r4, r2
    8370:	da75      	bge.n	845e <_realloc_r+0x122>
    8372:	4bc9      	ldr	r3, [pc, #804]	; (8698 <_realloc_r+0x35c>)
    8374:	6899      	ldr	r1, [r3, #8]
    8376:	eb08 0004 	add.w	r0, r8, r4
    837a:	4288      	cmp	r0, r1
    837c:	6841      	ldr	r1, [r0, #4]
    837e:	f000 80d9 	beq.w	8534 <_realloc_r+0x1f8>
    8382:	f021 0301 	bic.w	r3, r1, #1
    8386:	4403      	add	r3, r0
    8388:	685b      	ldr	r3, [r3, #4]
    838a:	07db      	lsls	r3, r3, #31
    838c:	d57d      	bpl.n	848a <_realloc_r+0x14e>
    838e:	f01e 0f01 	tst.w	lr, #1
    8392:	d035      	beq.n	8400 <_realloc_r+0xc4>
    8394:	4639      	mov	r1, r7
    8396:	4648      	mov	r0, r9
    8398:	f7ff fc44 	bl	7c24 <_malloc_r>
    839c:	4607      	mov	r7, r0
    839e:	b1e0      	cbz	r0, 83da <_realloc_r+0x9e>
    83a0:	f856 3c04 	ldr.w	r3, [r6, #-4]
    83a4:	f023 0301 	bic.w	r3, r3, #1
    83a8:	4443      	add	r3, r8
    83aa:	f1a0 0208 	sub.w	r2, r0, #8
    83ae:	429a      	cmp	r2, r3
    83b0:	f000 8144 	beq.w	863c <_realloc_r+0x300>
    83b4:	1f22      	subs	r2, r4, #4
    83b6:	2a24      	cmp	r2, #36	; 0x24
    83b8:	f200 8131 	bhi.w	861e <_realloc_r+0x2e2>
    83bc:	2a13      	cmp	r2, #19
    83be:	f200 8104 	bhi.w	85ca <_realloc_r+0x28e>
    83c2:	4603      	mov	r3, r0
    83c4:	4632      	mov	r2, r6
    83c6:	6811      	ldr	r1, [r2, #0]
    83c8:	6019      	str	r1, [r3, #0]
    83ca:	6851      	ldr	r1, [r2, #4]
    83cc:	6059      	str	r1, [r3, #4]
    83ce:	6892      	ldr	r2, [r2, #8]
    83d0:	609a      	str	r2, [r3, #8]
    83d2:	4631      	mov	r1, r6
    83d4:	4648      	mov	r0, r9
    83d6:	f000 fdb3 	bl	8f40 <_free_r>
    83da:	4648      	mov	r0, r9
    83dc:	f7ff ffa4 	bl	8328 <__malloc_unlock>
    83e0:	4638      	mov	r0, r7
    83e2:	b003      	add	sp, #12
    83e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    83e8:	f025 0507 	bic.w	r5, r5, #7
    83ec:	2d00      	cmp	r5, #0
    83ee:	462a      	mov	r2, r5
    83f0:	dabb      	bge.n	836a <_realloc_r+0x2e>
    83f2:	230c      	movs	r3, #12
    83f4:	2000      	movs	r0, #0
    83f6:	f8c9 3000 	str.w	r3, [r9]
    83fa:	b003      	add	sp, #12
    83fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8400:	f856 3c08 	ldr.w	r3, [r6, #-8]
    8404:	ebc3 0a08 	rsb	sl, r3, r8
    8408:	f8da 3004 	ldr.w	r3, [sl, #4]
    840c:	f023 0c03 	bic.w	ip, r3, #3
    8410:	eb04 030c 	add.w	r3, r4, ip
    8414:	4293      	cmp	r3, r2
    8416:	dbbd      	blt.n	8394 <_realloc_r+0x58>
    8418:	4657      	mov	r7, sl
    841a:	f8da 100c 	ldr.w	r1, [sl, #12]
    841e:	f857 0f08 	ldr.w	r0, [r7, #8]!
    8422:	1f22      	subs	r2, r4, #4
    8424:	2a24      	cmp	r2, #36	; 0x24
    8426:	60c1      	str	r1, [r0, #12]
    8428:	6088      	str	r0, [r1, #8]
    842a:	f200 8117 	bhi.w	865c <_realloc_r+0x320>
    842e:	2a13      	cmp	r2, #19
    8430:	f240 8112 	bls.w	8658 <_realloc_r+0x31c>
    8434:	6831      	ldr	r1, [r6, #0]
    8436:	f8ca 1008 	str.w	r1, [sl, #8]
    843a:	6871      	ldr	r1, [r6, #4]
    843c:	f8ca 100c 	str.w	r1, [sl, #12]
    8440:	2a1b      	cmp	r2, #27
    8442:	f200 812b 	bhi.w	869c <_realloc_r+0x360>
    8446:	3608      	adds	r6, #8
    8448:	f10a 0210 	add.w	r2, sl, #16
    844c:	6831      	ldr	r1, [r6, #0]
    844e:	6011      	str	r1, [r2, #0]
    8450:	6871      	ldr	r1, [r6, #4]
    8452:	6051      	str	r1, [r2, #4]
    8454:	68b1      	ldr	r1, [r6, #8]
    8456:	6091      	str	r1, [r2, #8]
    8458:	463e      	mov	r6, r7
    845a:	461c      	mov	r4, r3
    845c:	46d0      	mov	r8, sl
    845e:	1b63      	subs	r3, r4, r5
    8460:	2b0f      	cmp	r3, #15
    8462:	d81d      	bhi.n	84a0 <_realloc_r+0x164>
    8464:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8468:	f003 0301 	and.w	r3, r3, #1
    846c:	4323      	orrs	r3, r4
    846e:	4444      	add	r4, r8
    8470:	f8c8 3004 	str.w	r3, [r8, #4]
    8474:	6863      	ldr	r3, [r4, #4]
    8476:	f043 0301 	orr.w	r3, r3, #1
    847a:	6063      	str	r3, [r4, #4]
    847c:	4648      	mov	r0, r9
    847e:	f7ff ff53 	bl	8328 <__malloc_unlock>
    8482:	4630      	mov	r0, r6
    8484:	b003      	add	sp, #12
    8486:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    848a:	f021 0103 	bic.w	r1, r1, #3
    848e:	4421      	add	r1, r4
    8490:	4291      	cmp	r1, r2
    8492:	db21      	blt.n	84d8 <_realloc_r+0x19c>
    8494:	68c3      	ldr	r3, [r0, #12]
    8496:	6882      	ldr	r2, [r0, #8]
    8498:	460c      	mov	r4, r1
    849a:	60d3      	str	r3, [r2, #12]
    849c:	609a      	str	r2, [r3, #8]
    849e:	e7de      	b.n	845e <_realloc_r+0x122>
    84a0:	f8d8 2004 	ldr.w	r2, [r8, #4]
    84a4:	eb08 0105 	add.w	r1, r8, r5
    84a8:	f002 0201 	and.w	r2, r2, #1
    84ac:	4315      	orrs	r5, r2
    84ae:	f043 0201 	orr.w	r2, r3, #1
    84b2:	440b      	add	r3, r1
    84b4:	f8c8 5004 	str.w	r5, [r8, #4]
    84b8:	604a      	str	r2, [r1, #4]
    84ba:	685a      	ldr	r2, [r3, #4]
    84bc:	f042 0201 	orr.w	r2, r2, #1
    84c0:	3108      	adds	r1, #8
    84c2:	605a      	str	r2, [r3, #4]
    84c4:	4648      	mov	r0, r9
    84c6:	f000 fd3b 	bl	8f40 <_free_r>
    84ca:	e7d7      	b.n	847c <_realloc_r+0x140>
    84cc:	4611      	mov	r1, r2
    84ce:	b003      	add	sp, #12
    84d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    84d4:	f7ff bba6 	b.w	7c24 <_malloc_r>
    84d8:	f01e 0f01 	tst.w	lr, #1
    84dc:	f47f af5a 	bne.w	8394 <_realloc_r+0x58>
    84e0:	f856 3c08 	ldr.w	r3, [r6, #-8]
    84e4:	ebc3 0a08 	rsb	sl, r3, r8
    84e8:	f8da 3004 	ldr.w	r3, [sl, #4]
    84ec:	f023 0c03 	bic.w	ip, r3, #3
    84f0:	eb01 0e0c 	add.w	lr, r1, ip
    84f4:	4596      	cmp	lr, r2
    84f6:	db8b      	blt.n	8410 <_realloc_r+0xd4>
    84f8:	68c3      	ldr	r3, [r0, #12]
    84fa:	6882      	ldr	r2, [r0, #8]
    84fc:	4657      	mov	r7, sl
    84fe:	60d3      	str	r3, [r2, #12]
    8500:	609a      	str	r2, [r3, #8]
    8502:	f857 1f08 	ldr.w	r1, [r7, #8]!
    8506:	f8da 300c 	ldr.w	r3, [sl, #12]
    850a:	60cb      	str	r3, [r1, #12]
    850c:	1f22      	subs	r2, r4, #4
    850e:	2a24      	cmp	r2, #36	; 0x24
    8510:	6099      	str	r1, [r3, #8]
    8512:	f200 8099 	bhi.w	8648 <_realloc_r+0x30c>
    8516:	2a13      	cmp	r2, #19
    8518:	d962      	bls.n	85e0 <_realloc_r+0x2a4>
    851a:	6833      	ldr	r3, [r6, #0]
    851c:	f8ca 3008 	str.w	r3, [sl, #8]
    8520:	6873      	ldr	r3, [r6, #4]
    8522:	f8ca 300c 	str.w	r3, [sl, #12]
    8526:	2a1b      	cmp	r2, #27
    8528:	f200 80a0 	bhi.w	866c <_realloc_r+0x330>
    852c:	3608      	adds	r6, #8
    852e:	f10a 0310 	add.w	r3, sl, #16
    8532:	e056      	b.n	85e2 <_realloc_r+0x2a6>
    8534:	f021 0b03 	bic.w	fp, r1, #3
    8538:	44a3      	add	fp, r4
    853a:	f105 0010 	add.w	r0, r5, #16
    853e:	4583      	cmp	fp, r0
    8540:	da59      	bge.n	85f6 <_realloc_r+0x2ba>
    8542:	f01e 0f01 	tst.w	lr, #1
    8546:	f47f af25 	bne.w	8394 <_realloc_r+0x58>
    854a:	f856 1c08 	ldr.w	r1, [r6, #-8]
    854e:	ebc1 0a08 	rsb	sl, r1, r8
    8552:	f8da 1004 	ldr.w	r1, [sl, #4]
    8556:	f021 0c03 	bic.w	ip, r1, #3
    855a:	44e3      	add	fp, ip
    855c:	4558      	cmp	r0, fp
    855e:	f73f af57 	bgt.w	8410 <_realloc_r+0xd4>
    8562:	4657      	mov	r7, sl
    8564:	f8da 100c 	ldr.w	r1, [sl, #12]
    8568:	f857 0f08 	ldr.w	r0, [r7, #8]!
    856c:	1f22      	subs	r2, r4, #4
    856e:	2a24      	cmp	r2, #36	; 0x24
    8570:	60c1      	str	r1, [r0, #12]
    8572:	6088      	str	r0, [r1, #8]
    8574:	f200 80b4 	bhi.w	86e0 <_realloc_r+0x3a4>
    8578:	2a13      	cmp	r2, #19
    857a:	f240 80a5 	bls.w	86c8 <_realloc_r+0x38c>
    857e:	6831      	ldr	r1, [r6, #0]
    8580:	f8ca 1008 	str.w	r1, [sl, #8]
    8584:	6871      	ldr	r1, [r6, #4]
    8586:	f8ca 100c 	str.w	r1, [sl, #12]
    858a:	2a1b      	cmp	r2, #27
    858c:	f200 80af 	bhi.w	86ee <_realloc_r+0x3b2>
    8590:	3608      	adds	r6, #8
    8592:	f10a 0210 	add.w	r2, sl, #16
    8596:	6831      	ldr	r1, [r6, #0]
    8598:	6011      	str	r1, [r2, #0]
    859a:	6871      	ldr	r1, [r6, #4]
    859c:	6051      	str	r1, [r2, #4]
    859e:	68b1      	ldr	r1, [r6, #8]
    85a0:	6091      	str	r1, [r2, #8]
    85a2:	eb0a 0105 	add.w	r1, sl, r5
    85a6:	ebc5 020b 	rsb	r2, r5, fp
    85aa:	f042 0201 	orr.w	r2, r2, #1
    85ae:	6099      	str	r1, [r3, #8]
    85b0:	604a      	str	r2, [r1, #4]
    85b2:	f8da 3004 	ldr.w	r3, [sl, #4]
    85b6:	f003 0301 	and.w	r3, r3, #1
    85ba:	431d      	orrs	r5, r3
    85bc:	4648      	mov	r0, r9
    85be:	f8ca 5004 	str.w	r5, [sl, #4]
    85c2:	f7ff feb1 	bl	8328 <__malloc_unlock>
    85c6:	4638      	mov	r0, r7
    85c8:	e75c      	b.n	8484 <_realloc_r+0x148>
    85ca:	6833      	ldr	r3, [r6, #0]
    85cc:	6003      	str	r3, [r0, #0]
    85ce:	6873      	ldr	r3, [r6, #4]
    85d0:	6043      	str	r3, [r0, #4]
    85d2:	2a1b      	cmp	r2, #27
    85d4:	d827      	bhi.n	8626 <_realloc_r+0x2ea>
    85d6:	f100 0308 	add.w	r3, r0, #8
    85da:	f106 0208 	add.w	r2, r6, #8
    85de:	e6f2      	b.n	83c6 <_realloc_r+0x8a>
    85e0:	463b      	mov	r3, r7
    85e2:	6832      	ldr	r2, [r6, #0]
    85e4:	601a      	str	r2, [r3, #0]
    85e6:	6872      	ldr	r2, [r6, #4]
    85e8:	605a      	str	r2, [r3, #4]
    85ea:	68b2      	ldr	r2, [r6, #8]
    85ec:	609a      	str	r2, [r3, #8]
    85ee:	463e      	mov	r6, r7
    85f0:	4674      	mov	r4, lr
    85f2:	46d0      	mov	r8, sl
    85f4:	e733      	b.n	845e <_realloc_r+0x122>
    85f6:	eb08 0105 	add.w	r1, r8, r5
    85fa:	ebc5 0b0b 	rsb	fp, r5, fp
    85fe:	f04b 0201 	orr.w	r2, fp, #1
    8602:	6099      	str	r1, [r3, #8]
    8604:	604a      	str	r2, [r1, #4]
    8606:	f856 3c04 	ldr.w	r3, [r6, #-4]
    860a:	f003 0301 	and.w	r3, r3, #1
    860e:	431d      	orrs	r5, r3
    8610:	4648      	mov	r0, r9
    8612:	f846 5c04 	str.w	r5, [r6, #-4]
    8616:	f7ff fe87 	bl	8328 <__malloc_unlock>
    861a:	4630      	mov	r0, r6
    861c:	e732      	b.n	8484 <_realloc_r+0x148>
    861e:	4631      	mov	r1, r6
    8620:	f7ff fdce 	bl	81c0 <memmove>
    8624:	e6d5      	b.n	83d2 <_realloc_r+0x96>
    8626:	68b3      	ldr	r3, [r6, #8]
    8628:	6083      	str	r3, [r0, #8]
    862a:	68f3      	ldr	r3, [r6, #12]
    862c:	60c3      	str	r3, [r0, #12]
    862e:	2a24      	cmp	r2, #36	; 0x24
    8630:	d028      	beq.n	8684 <_realloc_r+0x348>
    8632:	f100 0310 	add.w	r3, r0, #16
    8636:	f106 0210 	add.w	r2, r6, #16
    863a:	e6c4      	b.n	83c6 <_realloc_r+0x8a>
    863c:	f850 3c04 	ldr.w	r3, [r0, #-4]
    8640:	f023 0303 	bic.w	r3, r3, #3
    8644:	441c      	add	r4, r3
    8646:	e70a      	b.n	845e <_realloc_r+0x122>
    8648:	4631      	mov	r1, r6
    864a:	4638      	mov	r0, r7
    864c:	4674      	mov	r4, lr
    864e:	46d0      	mov	r8, sl
    8650:	f7ff fdb6 	bl	81c0 <memmove>
    8654:	463e      	mov	r6, r7
    8656:	e702      	b.n	845e <_realloc_r+0x122>
    8658:	463a      	mov	r2, r7
    865a:	e6f7      	b.n	844c <_realloc_r+0x110>
    865c:	4631      	mov	r1, r6
    865e:	4638      	mov	r0, r7
    8660:	461c      	mov	r4, r3
    8662:	46d0      	mov	r8, sl
    8664:	f7ff fdac 	bl	81c0 <memmove>
    8668:	463e      	mov	r6, r7
    866a:	e6f8      	b.n	845e <_realloc_r+0x122>
    866c:	68b3      	ldr	r3, [r6, #8]
    866e:	f8ca 3010 	str.w	r3, [sl, #16]
    8672:	68f3      	ldr	r3, [r6, #12]
    8674:	f8ca 3014 	str.w	r3, [sl, #20]
    8678:	2a24      	cmp	r2, #36	; 0x24
    867a:	d01b      	beq.n	86b4 <_realloc_r+0x378>
    867c:	3610      	adds	r6, #16
    867e:	f10a 0318 	add.w	r3, sl, #24
    8682:	e7ae      	b.n	85e2 <_realloc_r+0x2a6>
    8684:	6933      	ldr	r3, [r6, #16]
    8686:	6103      	str	r3, [r0, #16]
    8688:	6973      	ldr	r3, [r6, #20]
    868a:	6143      	str	r3, [r0, #20]
    868c:	f106 0218 	add.w	r2, r6, #24
    8690:	f100 0318 	add.w	r3, r0, #24
    8694:	e697      	b.n	83c6 <_realloc_r+0x8a>
    8696:	bf00      	nop
    8698:	1fff8db0 	.word	0x1fff8db0
    869c:	68b1      	ldr	r1, [r6, #8]
    869e:	f8ca 1010 	str.w	r1, [sl, #16]
    86a2:	68f1      	ldr	r1, [r6, #12]
    86a4:	f8ca 1014 	str.w	r1, [sl, #20]
    86a8:	2a24      	cmp	r2, #36	; 0x24
    86aa:	d00f      	beq.n	86cc <_realloc_r+0x390>
    86ac:	3610      	adds	r6, #16
    86ae:	f10a 0218 	add.w	r2, sl, #24
    86b2:	e6cb      	b.n	844c <_realloc_r+0x110>
    86b4:	6933      	ldr	r3, [r6, #16]
    86b6:	f8ca 3018 	str.w	r3, [sl, #24]
    86ba:	6973      	ldr	r3, [r6, #20]
    86bc:	f8ca 301c 	str.w	r3, [sl, #28]
    86c0:	3618      	adds	r6, #24
    86c2:	f10a 0320 	add.w	r3, sl, #32
    86c6:	e78c      	b.n	85e2 <_realloc_r+0x2a6>
    86c8:	463a      	mov	r2, r7
    86ca:	e764      	b.n	8596 <_realloc_r+0x25a>
    86cc:	6932      	ldr	r2, [r6, #16]
    86ce:	f8ca 2018 	str.w	r2, [sl, #24]
    86d2:	6972      	ldr	r2, [r6, #20]
    86d4:	f8ca 201c 	str.w	r2, [sl, #28]
    86d8:	3618      	adds	r6, #24
    86da:	f10a 0220 	add.w	r2, sl, #32
    86de:	e6b5      	b.n	844c <_realloc_r+0x110>
    86e0:	4631      	mov	r1, r6
    86e2:	4638      	mov	r0, r7
    86e4:	9301      	str	r3, [sp, #4]
    86e6:	f7ff fd6b 	bl	81c0 <memmove>
    86ea:	9b01      	ldr	r3, [sp, #4]
    86ec:	e759      	b.n	85a2 <_realloc_r+0x266>
    86ee:	68b1      	ldr	r1, [r6, #8]
    86f0:	f8ca 1010 	str.w	r1, [sl, #16]
    86f4:	68f1      	ldr	r1, [r6, #12]
    86f6:	f8ca 1014 	str.w	r1, [sl, #20]
    86fa:	2a24      	cmp	r2, #36	; 0x24
    86fc:	d003      	beq.n	8706 <_realloc_r+0x3ca>
    86fe:	3610      	adds	r6, #16
    8700:	f10a 0218 	add.w	r2, sl, #24
    8704:	e747      	b.n	8596 <_realloc_r+0x25a>
    8706:	6932      	ldr	r2, [r6, #16]
    8708:	f8ca 2018 	str.w	r2, [sl, #24]
    870c:	6972      	ldr	r2, [r6, #20]
    870e:	f8ca 201c 	str.w	r2, [sl, #28]
    8712:	3618      	adds	r6, #24
    8714:	f10a 0220 	add.w	r2, sl, #32
    8718:	e73d      	b.n	8596 <_realloc_r+0x25a>
    871a:	bf00      	nop

0000871c <_sbrk_r>:
    871c:	b538      	push	{r3, r4, r5, lr}
    871e:	4c07      	ldr	r4, [pc, #28]	; (873c <_sbrk_r+0x20>)
    8720:	2300      	movs	r3, #0
    8722:	4605      	mov	r5, r0
    8724:	4608      	mov	r0, r1
    8726:	6023      	str	r3, [r4, #0]
    8728:	f7fc f92c 	bl	4984 <_sbrk>
    872c:	1c43      	adds	r3, r0, #1
    872e:	d000      	beq.n	8732 <_sbrk_r+0x16>
    8730:	bd38      	pop	{r3, r4, r5, pc}
    8732:	6823      	ldr	r3, [r4, #0]
    8734:	2b00      	cmp	r3, #0
    8736:	d0fb      	beq.n	8730 <_sbrk_r+0x14>
    8738:	602b      	str	r3, [r5, #0]
    873a:	bd38      	pop	{r3, r4, r5, pc}
    873c:	1fffb654 	.word	0x1fffb654
    8740:	eba2 0003 	sub.w	r0, r2, r3
    8744:	4770      	bx	lr
    8746:	bf00      	nop

00008748 <strcmp>:
    8748:	7802      	ldrb	r2, [r0, #0]
    874a:	780b      	ldrb	r3, [r1, #0]
    874c:	2a01      	cmp	r2, #1
    874e:	bf28      	it	cs
    8750:	429a      	cmpcs	r2, r3
    8752:	d1f5      	bne.n	8740 <_sbrk_r+0x24>
    8754:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    8758:	ea40 0401 	orr.w	r4, r0, r1
    875c:	e9cd 6702 	strd	r6, r7, [sp, #8]
    8760:	f06f 0c00 	mvn.w	ip, #0
    8764:	ea4f 7244 	mov.w	r2, r4, lsl #29
    8768:	b312      	cbz	r2, 87b0 <strcmp+0x68>
    876a:	ea80 0401 	eor.w	r4, r0, r1
    876e:	f014 0f07 	tst.w	r4, #7
    8772:	d16a      	bne.n	884a <strcmp+0x102>
    8774:	f000 0407 	and.w	r4, r0, #7
    8778:	f020 0007 	bic.w	r0, r0, #7
    877c:	f004 0503 	and.w	r5, r4, #3
    8780:	f021 0107 	bic.w	r1, r1, #7
    8784:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    8788:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    878c:	f014 0f04 	tst.w	r4, #4
    8790:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    8794:	fa0c f405 	lsl.w	r4, ip, r5
    8798:	ea62 0204 	orn	r2, r2, r4
    879c:	ea66 0604 	orn	r6, r6, r4
    87a0:	d00a      	beq.n	87b8 <strcmp+0x70>
    87a2:	ea63 0304 	orn	r3, r3, r4
    87a6:	4662      	mov	r2, ip
    87a8:	ea67 0704 	orn	r7, r7, r4
    87ac:	4666      	mov	r6, ip
    87ae:	e003      	b.n	87b8 <strcmp+0x70>
    87b0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    87b4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    87b8:	fa82 f54c 	uadd8	r5, r2, ip
    87bc:	ea82 0406 	eor.w	r4, r2, r6
    87c0:	faa4 f48c 	sel	r4, r4, ip
    87c4:	bb6c      	cbnz	r4, 8822 <strcmp+0xda>
    87c6:	fa83 f54c 	uadd8	r5, r3, ip
    87ca:	ea83 0507 	eor.w	r5, r3, r7
    87ce:	faa5 f58c 	sel	r5, r5, ip
    87d2:	b995      	cbnz	r5, 87fa <strcmp+0xb2>
    87d4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    87d8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    87dc:	fa82 f54c 	uadd8	r5, r2, ip
    87e0:	ea82 0406 	eor.w	r4, r2, r6
    87e4:	faa4 f48c 	sel	r4, r4, ip
    87e8:	fa83 f54c 	uadd8	r5, r3, ip
    87ec:	ea83 0507 	eor.w	r5, r3, r7
    87f0:	faa5 f58c 	sel	r5, r5, ip
    87f4:	4325      	orrs	r5, r4
    87f6:	d0db      	beq.n	87b0 <strcmp+0x68>
    87f8:	b99c      	cbnz	r4, 8822 <strcmp+0xda>
    87fa:	ba2d      	rev	r5, r5
    87fc:	fab5 f485 	clz	r4, r5
    8800:	f024 0407 	bic.w	r4, r4, #7
    8804:	fa27 f104 	lsr.w	r1, r7, r4
    8808:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    880c:	fa23 f304 	lsr.w	r3, r3, r4
    8810:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    8814:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    8818:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    881c:	eba0 0001 	sub.w	r0, r0, r1
    8820:	4770      	bx	lr
    8822:	ba24      	rev	r4, r4
    8824:	fab4 f484 	clz	r4, r4
    8828:	f024 0407 	bic.w	r4, r4, #7
    882c:	fa26 f104 	lsr.w	r1, r6, r4
    8830:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    8834:	fa22 f204 	lsr.w	r2, r2, r4
    8838:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    883c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    8840:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8844:	eba0 0001 	sub.w	r0, r0, r1
    8848:	4770      	bx	lr
    884a:	f014 0f03 	tst.w	r4, #3
    884e:	d13c      	bne.n	88ca <strcmp+0x182>
    8850:	f010 0403 	ands.w	r4, r0, #3
    8854:	d128      	bne.n	88a8 <strcmp+0x160>
    8856:	f850 2b08 	ldr.w	r2, [r0], #8
    885a:	f851 3b08 	ldr.w	r3, [r1], #8
    885e:	fa82 f54c 	uadd8	r5, r2, ip
    8862:	ea82 0503 	eor.w	r5, r2, r3
    8866:	faa5 f58c 	sel	r5, r5, ip
    886a:	b95d      	cbnz	r5, 8884 <strcmp+0x13c>
    886c:	f850 2c04 	ldr.w	r2, [r0, #-4]
    8870:	f851 3c04 	ldr.w	r3, [r1, #-4]
    8874:	fa82 f54c 	uadd8	r5, r2, ip
    8878:	ea82 0503 	eor.w	r5, r2, r3
    887c:	faa5 f58c 	sel	r5, r5, ip
    8880:	2d00      	cmp	r5, #0
    8882:	d0e8      	beq.n	8856 <strcmp+0x10e>
    8884:	ba2d      	rev	r5, r5
    8886:	fab5 f485 	clz	r4, r5
    888a:	f024 0407 	bic.w	r4, r4, #7
    888e:	fa23 f104 	lsr.w	r1, r3, r4
    8892:	fa22 f204 	lsr.w	r2, r2, r4
    8896:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    889a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    889e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    88a2:	eba0 0001 	sub.w	r0, r0, r1
    88a6:	4770      	bx	lr
    88a8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    88ac:	f020 0003 	bic.w	r0, r0, #3
    88b0:	f850 2b08 	ldr.w	r2, [r0], #8
    88b4:	f021 0103 	bic.w	r1, r1, #3
    88b8:	f851 3b08 	ldr.w	r3, [r1], #8
    88bc:	fa0c f404 	lsl.w	r4, ip, r4
    88c0:	ea62 0204 	orn	r2, r2, r4
    88c4:	ea63 0304 	orn	r3, r3, r4
    88c8:	e7c9      	b.n	885e <strcmp+0x116>
    88ca:	f010 0403 	ands.w	r4, r0, #3
    88ce:	d01a      	beq.n	8906 <strcmp+0x1be>
    88d0:	eba1 0104 	sub.w	r1, r1, r4
    88d4:	f020 0003 	bic.w	r0, r0, #3
    88d8:	07e4      	lsls	r4, r4, #31
    88da:	f850 2b04 	ldr.w	r2, [r0], #4
    88de:	d006      	beq.n	88ee <strcmp+0x1a6>
    88e0:	d20f      	bcs.n	8902 <strcmp+0x1ba>
    88e2:	788b      	ldrb	r3, [r1, #2]
    88e4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    88e8:	1ae4      	subs	r4, r4, r3
    88ea:	d106      	bne.n	88fa <strcmp+0x1b2>
    88ec:	b12b      	cbz	r3, 88fa <strcmp+0x1b2>
    88ee:	78cb      	ldrb	r3, [r1, #3]
    88f0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    88f4:	1ae4      	subs	r4, r4, r3
    88f6:	d100      	bne.n	88fa <strcmp+0x1b2>
    88f8:	b91b      	cbnz	r3, 8902 <strcmp+0x1ba>
    88fa:	4620      	mov	r0, r4
    88fc:	f85d 4b10 	ldr.w	r4, [sp], #16
    8900:	4770      	bx	lr
    8902:	f101 0104 	add.w	r1, r1, #4
    8906:	f850 2b04 	ldr.w	r2, [r0], #4
    890a:	07cc      	lsls	r4, r1, #31
    890c:	f021 0103 	bic.w	r1, r1, #3
    8910:	f851 3b04 	ldr.w	r3, [r1], #4
    8914:	d848      	bhi.n	89a8 <strcmp+0x260>
    8916:	d224      	bcs.n	8962 <strcmp+0x21a>
    8918:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    891c:	fa82 f54c 	uadd8	r5, r2, ip
    8920:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    8924:	faa5 f58c 	sel	r5, r5, ip
    8928:	d10a      	bne.n	8940 <strcmp+0x1f8>
    892a:	b965      	cbnz	r5, 8946 <strcmp+0x1fe>
    892c:	f851 3b04 	ldr.w	r3, [r1], #4
    8930:	ea84 0402 	eor.w	r4, r4, r2
    8934:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    8938:	d10e      	bne.n	8958 <strcmp+0x210>
    893a:	f850 2b04 	ldr.w	r2, [r0], #4
    893e:	e7eb      	b.n	8918 <strcmp+0x1d0>
    8940:	ea4f 2313 	mov.w	r3, r3, lsr #8
    8944:	e055      	b.n	89f2 <strcmp+0x2aa>
    8946:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    894a:	d14d      	bne.n	89e8 <strcmp+0x2a0>
    894c:	7808      	ldrb	r0, [r1, #0]
    894e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8952:	f1c0 0000 	rsb	r0, r0, #0
    8956:	4770      	bx	lr
    8958:	ea4f 6212 	mov.w	r2, r2, lsr #24
    895c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    8960:	e047      	b.n	89f2 <strcmp+0x2aa>
    8962:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    8966:	fa82 f54c 	uadd8	r5, r2, ip
    896a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    896e:	faa5 f58c 	sel	r5, r5, ip
    8972:	d10a      	bne.n	898a <strcmp+0x242>
    8974:	b965      	cbnz	r5, 8990 <strcmp+0x248>
    8976:	f851 3b04 	ldr.w	r3, [r1], #4
    897a:	ea84 0402 	eor.w	r4, r4, r2
    897e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    8982:	d10c      	bne.n	899e <strcmp+0x256>
    8984:	f850 2b04 	ldr.w	r2, [r0], #4
    8988:	e7eb      	b.n	8962 <strcmp+0x21a>
    898a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    898e:	e030      	b.n	89f2 <strcmp+0x2aa>
    8990:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    8994:	d128      	bne.n	89e8 <strcmp+0x2a0>
    8996:	880b      	ldrh	r3, [r1, #0]
    8998:	ea4f 4212 	mov.w	r2, r2, lsr #16
    899c:	e029      	b.n	89f2 <strcmp+0x2aa>
    899e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    89a2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    89a6:	e024      	b.n	89f2 <strcmp+0x2aa>
    89a8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    89ac:	fa82 f54c 	uadd8	r5, r2, ip
    89b0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    89b4:	faa5 f58c 	sel	r5, r5, ip
    89b8:	d10a      	bne.n	89d0 <strcmp+0x288>
    89ba:	b965      	cbnz	r5, 89d6 <strcmp+0x28e>
    89bc:	f851 3b04 	ldr.w	r3, [r1], #4
    89c0:	ea84 0402 	eor.w	r4, r4, r2
    89c4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    89c8:	d109      	bne.n	89de <strcmp+0x296>
    89ca:	f850 2b04 	ldr.w	r2, [r0], #4
    89ce:	e7eb      	b.n	89a8 <strcmp+0x260>
    89d0:	ea4f 6313 	mov.w	r3, r3, lsr #24
    89d4:	e00d      	b.n	89f2 <strcmp+0x2aa>
    89d6:	f015 0fff 	tst.w	r5, #255	; 0xff
    89da:	d105      	bne.n	89e8 <strcmp+0x2a0>
    89dc:	680b      	ldr	r3, [r1, #0]
    89de:	ea4f 2212 	mov.w	r2, r2, lsr #8
    89e2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    89e6:	e004      	b.n	89f2 <strcmp+0x2aa>
    89e8:	f04f 0000 	mov.w	r0, #0
    89ec:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    89f0:	4770      	bx	lr
    89f2:	ba12      	rev	r2, r2
    89f4:	ba1b      	rev	r3, r3
    89f6:	fa82 f44c 	uadd8	r4, r2, ip
    89fa:	ea82 0403 	eor.w	r4, r2, r3
    89fe:	faa4 f58c 	sel	r5, r4, ip
    8a02:	fab5 f485 	clz	r4, r5
    8a06:	fa02 f204 	lsl.w	r2, r2, r4
    8a0a:	fa03 f304 	lsl.w	r3, r3, r4
    8a0e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    8a12:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8a16:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    8a1a:	4770      	bx	lr

00008a1c <strcpy>:
    8a1c:	ea80 0201 	eor.w	r2, r0, r1
    8a20:	4684      	mov	ip, r0
    8a22:	f012 0f03 	tst.w	r2, #3
    8a26:	d14f      	bne.n	8ac8 <strcpy+0xac>
    8a28:	f011 0f03 	tst.w	r1, #3
    8a2c:	d132      	bne.n	8a94 <strcpy+0x78>
    8a2e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    8a32:	f011 0f04 	tst.w	r1, #4
    8a36:	f851 3b04 	ldr.w	r3, [r1], #4
    8a3a:	d00b      	beq.n	8a54 <strcpy+0x38>
    8a3c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    8a40:	439a      	bics	r2, r3
    8a42:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    8a46:	bf04      	itt	eq
    8a48:	f84c 3b04 	streq.w	r3, [ip], #4
    8a4c:	f851 3b04 	ldreq.w	r3, [r1], #4
    8a50:	d116      	bne.n	8a80 <strcpy+0x64>
    8a52:	bf00      	nop
    8a54:	f851 4b04 	ldr.w	r4, [r1], #4
    8a58:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    8a5c:	439a      	bics	r2, r3
    8a5e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    8a62:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    8a66:	d10b      	bne.n	8a80 <strcpy+0x64>
    8a68:	f84c 3b04 	str.w	r3, [ip], #4
    8a6c:	43a2      	bics	r2, r4
    8a6e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    8a72:	bf04      	itt	eq
    8a74:	f851 3b04 	ldreq.w	r3, [r1], #4
    8a78:	f84c 4b04 	streq.w	r4, [ip], #4
    8a7c:	d0ea      	beq.n	8a54 <strcpy+0x38>
    8a7e:	4623      	mov	r3, r4
    8a80:	f80c 3b01 	strb.w	r3, [ip], #1
    8a84:	f013 0fff 	tst.w	r3, #255	; 0xff
    8a88:	ea4f 2333 	mov.w	r3, r3, ror #8
    8a8c:	d1f8      	bne.n	8a80 <strcpy+0x64>
    8a8e:	f85d 4b04 	ldr.w	r4, [sp], #4
    8a92:	4770      	bx	lr
    8a94:	f011 0f01 	tst.w	r1, #1
    8a98:	d006      	beq.n	8aa8 <strcpy+0x8c>
    8a9a:	f811 2b01 	ldrb.w	r2, [r1], #1
    8a9e:	f80c 2b01 	strb.w	r2, [ip], #1
    8aa2:	2a00      	cmp	r2, #0
    8aa4:	bf08      	it	eq
    8aa6:	4770      	bxeq	lr
    8aa8:	f011 0f02 	tst.w	r1, #2
    8aac:	d0bf      	beq.n	8a2e <strcpy+0x12>
    8aae:	f831 2b02 	ldrh.w	r2, [r1], #2
    8ab2:	f012 0fff 	tst.w	r2, #255	; 0xff
    8ab6:	bf16      	itet	ne
    8ab8:	f82c 2b02 	strhne.w	r2, [ip], #2
    8abc:	f88c 2000 	strbeq.w	r2, [ip]
    8ac0:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    8ac4:	d1b3      	bne.n	8a2e <strcpy+0x12>
    8ac6:	4770      	bx	lr
    8ac8:	f811 2b01 	ldrb.w	r2, [r1], #1
    8acc:	f80c 2b01 	strb.w	r2, [ip], #1
    8ad0:	2a00      	cmp	r2, #0
    8ad2:	d1f9      	bne.n	8ac8 <strcpy+0xac>
    8ad4:	4770      	bx	lr
    8ad6:	bf00      	nop
    8ad8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8adc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8ae0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8ae4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8ae8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8aec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8af0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8af4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8af8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8afc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00008b00 <strlen>:
    8b00:	f890 f000 	pld	[r0]
    8b04:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    8b08:	f020 0107 	bic.w	r1, r0, #7
    8b0c:	f06f 0c00 	mvn.w	ip, #0
    8b10:	f010 0407 	ands.w	r4, r0, #7
    8b14:	f891 f020 	pld	[r1, #32]
    8b18:	f040 8049 	bne.w	8bae <strlen+0xae>
    8b1c:	f04f 0400 	mov.w	r4, #0
    8b20:	f06f 0007 	mvn.w	r0, #7
    8b24:	e9d1 2300 	ldrd	r2, r3, [r1]
    8b28:	f891 f040 	pld	[r1, #64]	; 0x40
    8b2c:	f100 0008 	add.w	r0, r0, #8
    8b30:	fa82 f24c 	uadd8	r2, r2, ip
    8b34:	faa4 f28c 	sel	r2, r4, ip
    8b38:	fa83 f34c 	uadd8	r3, r3, ip
    8b3c:	faa2 f38c 	sel	r3, r2, ip
    8b40:	bb4b      	cbnz	r3, 8b96 <strlen+0x96>
    8b42:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    8b46:	fa82 f24c 	uadd8	r2, r2, ip
    8b4a:	f100 0008 	add.w	r0, r0, #8
    8b4e:	faa4 f28c 	sel	r2, r4, ip
    8b52:	fa83 f34c 	uadd8	r3, r3, ip
    8b56:	faa2 f38c 	sel	r3, r2, ip
    8b5a:	b9e3      	cbnz	r3, 8b96 <strlen+0x96>
    8b5c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    8b60:	fa82 f24c 	uadd8	r2, r2, ip
    8b64:	f100 0008 	add.w	r0, r0, #8
    8b68:	faa4 f28c 	sel	r2, r4, ip
    8b6c:	fa83 f34c 	uadd8	r3, r3, ip
    8b70:	faa2 f38c 	sel	r3, r2, ip
    8b74:	b97b      	cbnz	r3, 8b96 <strlen+0x96>
    8b76:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    8b7a:	f101 0120 	add.w	r1, r1, #32
    8b7e:	fa82 f24c 	uadd8	r2, r2, ip
    8b82:	f100 0008 	add.w	r0, r0, #8
    8b86:	faa4 f28c 	sel	r2, r4, ip
    8b8a:	fa83 f34c 	uadd8	r3, r3, ip
    8b8e:	faa2 f38c 	sel	r3, r2, ip
    8b92:	2b00      	cmp	r3, #0
    8b94:	d0c6      	beq.n	8b24 <strlen+0x24>
    8b96:	2a00      	cmp	r2, #0
    8b98:	bf04      	itt	eq
    8b9a:	3004      	addeq	r0, #4
    8b9c:	461a      	moveq	r2, r3
    8b9e:	ba12      	rev	r2, r2
    8ba0:	fab2 f282 	clz	r2, r2
    8ba4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    8ba8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    8bac:	4770      	bx	lr
    8bae:	e9d1 2300 	ldrd	r2, r3, [r1]
    8bb2:	f004 0503 	and.w	r5, r4, #3
    8bb6:	f1c4 0000 	rsb	r0, r4, #0
    8bba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    8bbe:	f014 0f04 	tst.w	r4, #4
    8bc2:	f891 f040 	pld	[r1, #64]	; 0x40
    8bc6:	fa0c f505 	lsl.w	r5, ip, r5
    8bca:	ea62 0205 	orn	r2, r2, r5
    8bce:	bf1c      	itt	ne
    8bd0:	ea63 0305 	ornne	r3, r3, r5
    8bd4:	4662      	movne	r2, ip
    8bd6:	f04f 0400 	mov.w	r4, #0
    8bda:	e7a9      	b.n	8b30 <strlen+0x30>

00008bdc <strncpy>:
    8bdc:	ea40 0301 	orr.w	r3, r0, r1
    8be0:	079b      	lsls	r3, r3, #30
    8be2:	b470      	push	{r4, r5, r6}
    8be4:	d12b      	bne.n	8c3e <strncpy+0x62>
    8be6:	2a03      	cmp	r2, #3
    8be8:	d929      	bls.n	8c3e <strncpy+0x62>
    8bea:	460c      	mov	r4, r1
    8bec:	4603      	mov	r3, r0
    8bee:	4621      	mov	r1, r4
    8bf0:	f854 6b04 	ldr.w	r6, [r4], #4
    8bf4:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    8bf8:	ea25 0506 	bic.w	r5, r5, r6
    8bfc:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    8c00:	d106      	bne.n	8c10 <strncpy+0x34>
    8c02:	3a04      	subs	r2, #4
    8c04:	2a03      	cmp	r2, #3
    8c06:	f843 6b04 	str.w	r6, [r3], #4
    8c0a:	4621      	mov	r1, r4
    8c0c:	d8ef      	bhi.n	8bee <strncpy+0x12>
    8c0e:	b1a2      	cbz	r2, 8c3a <strncpy+0x5e>
    8c10:	780c      	ldrb	r4, [r1, #0]
    8c12:	701c      	strb	r4, [r3, #0]
    8c14:	3a01      	subs	r2, #1
    8c16:	3301      	adds	r3, #1
    8c18:	3101      	adds	r1, #1
    8c1a:	b13c      	cbz	r4, 8c2c <strncpy+0x50>
    8c1c:	b16a      	cbz	r2, 8c3a <strncpy+0x5e>
    8c1e:	f811 4b01 	ldrb.w	r4, [r1], #1
    8c22:	f803 4b01 	strb.w	r4, [r3], #1
    8c26:	3a01      	subs	r2, #1
    8c28:	2c00      	cmp	r4, #0
    8c2a:	d1f7      	bne.n	8c1c <strncpy+0x40>
    8c2c:	b12a      	cbz	r2, 8c3a <strncpy+0x5e>
    8c2e:	441a      	add	r2, r3
    8c30:	2100      	movs	r1, #0
    8c32:	f803 1b01 	strb.w	r1, [r3], #1
    8c36:	429a      	cmp	r2, r3
    8c38:	d1fb      	bne.n	8c32 <strncpy+0x56>
    8c3a:	bc70      	pop	{r4, r5, r6}
    8c3c:	4770      	bx	lr
    8c3e:	4603      	mov	r3, r0
    8c40:	e7e5      	b.n	8c0e <strncpy+0x32>
    8c42:	bf00      	nop

00008c44 <_strtol_l.isra.0>:
    8c44:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8c48:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    8c4c:	460f      	mov	r7, r1
    8c4e:	4680      	mov	r8, r0
    8c50:	4616      	mov	r6, r2
    8c52:	461d      	mov	r5, r3
    8c54:	468b      	mov	fp, r1
    8c56:	e000      	b.n	8c5a <_strtol_l.isra.0+0x16>
    8c58:	46a3      	mov	fp, r4
    8c5a:	465c      	mov	r4, fp
    8c5c:	4648      	mov	r0, r9
    8c5e:	f814 ab01 	ldrb.w	sl, [r4], #1
    8c62:	f7fe ffcb 	bl	7bfc <__locale_ctype_ptr_l>
    8c66:	4450      	add	r0, sl
    8c68:	7841      	ldrb	r1, [r0, #1]
    8c6a:	f001 0108 	and.w	r1, r1, #8
    8c6e:	f001 0cff 	and.w	ip, r1, #255	; 0xff
    8c72:	2900      	cmp	r1, #0
    8c74:	d1f0      	bne.n	8c58 <_strtol_l.isra.0+0x14>
    8c76:	4652      	mov	r2, sl
    8c78:	2a2d      	cmp	r2, #45	; 0x2d
    8c7a:	d061      	beq.n	8d40 <_strtol_l.isra.0+0xfc>
    8c7c:	2a2b      	cmp	r2, #43	; 0x2b
    8c7e:	bf04      	itt	eq
    8c80:	f89b 2001 	ldrbeq.w	r2, [fp, #1]
    8c84:	f10b 0402 	addeq.w	r4, fp, #2
    8c88:	2d00      	cmp	r5, #0
    8c8a:	d043      	beq.n	8d14 <_strtol_l.isra.0+0xd0>
    8c8c:	2d10      	cmp	r5, #16
    8c8e:	d065      	beq.n	8d5c <_strtol_l.isra.0+0x118>
    8c90:	46a9      	mov	r9, r5
    8c92:	f1bc 0f00 	cmp.w	ip, #0
    8c96:	bf0c      	ite	eq
    8c98:	f06f 4a00 	mvneq.w	sl, #2147483648	; 0x80000000
    8c9c:	f04f 4a00 	movne.w	sl, #2147483648	; 0x80000000
    8ca0:	2100      	movs	r1, #0
    8ca2:	fbba fef9 	udiv	lr, sl, r9
    8ca6:	4608      	mov	r0, r1
    8ca8:	fb09 aa1e 	mls	sl, r9, lr, sl
    8cac:	e005      	b.n	8cba <_strtol_l.isra.0+0x76>
    8cae:	d029      	beq.n	8d04 <_strtol_l.isra.0+0xc0>
    8cb0:	fb09 3000 	mla	r0, r9, r0, r3
    8cb4:	2101      	movs	r1, #1
    8cb6:	f814 2b01 	ldrb.w	r2, [r4], #1
    8cba:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    8cbe:	2b09      	cmp	r3, #9
    8cc0:	d905      	bls.n	8cce <_strtol_l.isra.0+0x8a>
    8cc2:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
    8cc6:	2b19      	cmp	r3, #25
    8cc8:	d80a      	bhi.n	8ce0 <_strtol_l.isra.0+0x9c>
    8cca:	f1a2 0337 	sub.w	r3, r2, #55	; 0x37
    8cce:	429d      	cmp	r5, r3
    8cd0:	dd0e      	ble.n	8cf0 <_strtol_l.isra.0+0xac>
    8cd2:	1c4a      	adds	r2, r1, #1
    8cd4:	d0ef      	beq.n	8cb6 <_strtol_l.isra.0+0x72>
    8cd6:	4586      	cmp	lr, r0
    8cd8:	d2e9      	bcs.n	8cae <_strtol_l.isra.0+0x6a>
    8cda:	f04f 31ff 	mov.w	r1, #4294967295
    8cde:	e7ea      	b.n	8cb6 <_strtol_l.isra.0+0x72>
    8ce0:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
    8ce4:	2b19      	cmp	r3, #25
    8ce6:	d803      	bhi.n	8cf0 <_strtol_l.isra.0+0xac>
    8ce8:	f1a2 0357 	sub.w	r3, r2, #87	; 0x57
    8cec:	429d      	cmp	r5, r3
    8cee:	dcf0      	bgt.n	8cd2 <_strtol_l.isra.0+0x8e>
    8cf0:	1c4b      	adds	r3, r1, #1
    8cf2:	d015      	beq.n	8d20 <_strtol_l.isra.0+0xdc>
    8cf4:	f1bc 0f00 	cmp.w	ip, #0
    8cf8:	d110      	bne.n	8d1c <_strtol_l.isra.0+0xd8>
    8cfa:	b14e      	cbz	r6, 8d10 <_strtol_l.isra.0+0xcc>
    8cfc:	b9e1      	cbnz	r1, 8d38 <_strtol_l.isra.0+0xf4>
    8cfe:	6037      	str	r7, [r6, #0]
    8d00:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d04:	459a      	cmp	sl, r3
    8d06:	dad3      	bge.n	8cb0 <_strtol_l.isra.0+0x6c>
    8d08:	4670      	mov	r0, lr
    8d0a:	f04f 31ff 	mov.w	r1, #4294967295
    8d0e:	e7d2      	b.n	8cb6 <_strtol_l.isra.0+0x72>
    8d10:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d14:	2a30      	cmp	r2, #48	; 0x30
    8d16:	d01a      	beq.n	8d4e <_strtol_l.isra.0+0x10a>
    8d18:	250a      	movs	r5, #10
    8d1a:	e7b9      	b.n	8c90 <_strtol_l.isra.0+0x4c>
    8d1c:	4240      	negs	r0, r0
    8d1e:	e7ec      	b.n	8cfa <_strtol_l.isra.0+0xb6>
    8d20:	f1bc 0f00 	cmp.w	ip, #0
    8d24:	f04f 0322 	mov.w	r3, #34	; 0x22
    8d28:	bf0c      	ite	eq
    8d2a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    8d2e:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
    8d32:	f8c8 3000 	str.w	r3, [r8]
    8d36:	b1f6      	cbz	r6, 8d76 <_strtol_l.isra.0+0x132>
    8d38:	1e67      	subs	r7, r4, #1
    8d3a:	6037      	str	r7, [r6, #0]
    8d3c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d40:	f10b 0402 	add.w	r4, fp, #2
    8d44:	f89b 2001 	ldrb.w	r2, [fp, #1]
    8d48:	f04f 0c01 	mov.w	ip, #1
    8d4c:	e79c      	b.n	8c88 <_strtol_l.isra.0+0x44>
    8d4e:	7823      	ldrb	r3, [r4, #0]
    8d50:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    8d54:	2b58      	cmp	r3, #88	; 0x58
    8d56:	d008      	beq.n	8d6a <_strtol_l.isra.0+0x126>
    8d58:	2508      	movs	r5, #8
    8d5a:	e799      	b.n	8c90 <_strtol_l.isra.0+0x4c>
    8d5c:	2a30      	cmp	r2, #48	; 0x30
    8d5e:	d197      	bne.n	8c90 <_strtol_l.isra.0+0x4c>
    8d60:	7823      	ldrb	r3, [r4, #0]
    8d62:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    8d66:	2b58      	cmp	r3, #88	; 0x58
    8d68:	d192      	bne.n	8c90 <_strtol_l.isra.0+0x4c>
    8d6a:	f04f 0910 	mov.w	r9, #16
    8d6e:	7862      	ldrb	r2, [r4, #1]
    8d70:	464d      	mov	r5, r9
    8d72:	3402      	adds	r4, #2
    8d74:	e78d      	b.n	8c92 <_strtol_l.isra.0+0x4e>
    8d76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d7a:	bf00      	nop

00008d7c <strtol>:
    8d7c:	b530      	push	{r4, r5, lr}
    8d7e:	4c08      	ldr	r4, [pc, #32]	; (8da0 <strtol+0x24>)
    8d80:	4b08      	ldr	r3, [pc, #32]	; (8da4 <strtol+0x28>)
    8d82:	6825      	ldr	r5, [r4, #0]
    8d84:	6b6c      	ldr	r4, [r5, #52]	; 0x34
    8d86:	b083      	sub	sp, #12
    8d88:	2c00      	cmp	r4, #0
    8d8a:	bf08      	it	eq
    8d8c:	461c      	moveq	r4, r3
    8d8e:	9400      	str	r4, [sp, #0]
    8d90:	4613      	mov	r3, r2
    8d92:	460a      	mov	r2, r1
    8d94:	4601      	mov	r1, r0
    8d96:	4628      	mov	r0, r5
    8d98:	f7ff ff54 	bl	8c44 <_strtol_l.isra.0>
    8d9c:	b003      	add	sp, #12
    8d9e:	bd30      	pop	{r4, r5, pc}
    8da0:	1fff8c40 	.word	0x1fff8c40
    8da4:	1fff8c44 	.word	0x1fff8c44

00008da8 <__ascii_wctomb>:
    8da8:	b121      	cbz	r1, 8db4 <__ascii_wctomb+0xc>
    8daa:	2aff      	cmp	r2, #255	; 0xff
    8dac:	d804      	bhi.n	8db8 <__ascii_wctomb+0x10>
    8dae:	700a      	strb	r2, [r1, #0]
    8db0:	2001      	movs	r0, #1
    8db2:	4770      	bx	lr
    8db4:	4608      	mov	r0, r1
    8db6:	4770      	bx	lr
    8db8:	238a      	movs	r3, #138	; 0x8a
    8dba:	6003      	str	r3, [r0, #0]
    8dbc:	f04f 30ff 	mov.w	r0, #4294967295
    8dc0:	4770      	bx	lr
    8dc2:	bf00      	nop

00008dc4 <__register_exitproc>:
    8dc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8dc8:	4c25      	ldr	r4, [pc, #148]	; (8e60 <__register_exitproc+0x9c>)
    8dca:	6825      	ldr	r5, [r4, #0]
    8dcc:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    8dd0:	4606      	mov	r6, r0
    8dd2:	4688      	mov	r8, r1
    8dd4:	4692      	mov	sl, r2
    8dd6:	4699      	mov	r9, r3
    8dd8:	b3c4      	cbz	r4, 8e4c <__register_exitproc+0x88>
    8dda:	6860      	ldr	r0, [r4, #4]
    8ddc:	281f      	cmp	r0, #31
    8dde:	dc17      	bgt.n	8e10 <__register_exitproc+0x4c>
    8de0:	1c43      	adds	r3, r0, #1
    8de2:	b176      	cbz	r6, 8e02 <__register_exitproc+0x3e>
    8de4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    8de8:	2201      	movs	r2, #1
    8dea:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    8dee:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    8df2:	4082      	lsls	r2, r0
    8df4:	4311      	orrs	r1, r2
    8df6:	2e02      	cmp	r6, #2
    8df8:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    8dfc:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    8e00:	d01e      	beq.n	8e40 <__register_exitproc+0x7c>
    8e02:	3002      	adds	r0, #2
    8e04:	6063      	str	r3, [r4, #4]
    8e06:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    8e0a:	2000      	movs	r0, #0
    8e0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8e10:	4b14      	ldr	r3, [pc, #80]	; (8e64 <__register_exitproc+0xa0>)
    8e12:	b303      	cbz	r3, 8e56 <__register_exitproc+0x92>
    8e14:	f44f 70c8 	mov.w	r0, #400	; 0x190
    8e18:	f7fe fef4 	bl	7c04 <malloc>
    8e1c:	4604      	mov	r4, r0
    8e1e:	b1d0      	cbz	r0, 8e56 <__register_exitproc+0x92>
    8e20:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    8e24:	2700      	movs	r7, #0
    8e26:	e880 0088 	stmia.w	r0, {r3, r7}
    8e2a:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    8e2e:	4638      	mov	r0, r7
    8e30:	2301      	movs	r3, #1
    8e32:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    8e36:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    8e3a:	2e00      	cmp	r6, #0
    8e3c:	d0e1      	beq.n	8e02 <__register_exitproc+0x3e>
    8e3e:	e7d1      	b.n	8de4 <__register_exitproc+0x20>
    8e40:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    8e44:	430a      	orrs	r2, r1
    8e46:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    8e4a:	e7da      	b.n	8e02 <__register_exitproc+0x3e>
    8e4c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    8e50:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    8e54:	e7c1      	b.n	8dda <__register_exitproc+0x16>
    8e56:	f04f 30ff 	mov.w	r0, #4294967295
    8e5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8e5e:	bf00      	nop
    8e60:	0000971c 	.word	0x0000971c
    8e64:	00007c05 	.word	0x00007c05

00008e68 <register_fini>:
    8e68:	4b02      	ldr	r3, [pc, #8]	; (8e74 <register_fini+0xc>)
    8e6a:	b113      	cbz	r3, 8e72 <register_fini+0xa>
    8e6c:	4802      	ldr	r0, [pc, #8]	; (8e78 <register_fini+0x10>)
    8e6e:	f7f9 bb2b 	b.w	24c8 <atexit>
    8e72:	4770      	bx	lr
    8e74:	00000000 	.word	0x00000000
    8e78:	00008e7d 	.word	0x00008e7d

00008e7c <__libc_fini_array>:
    8e7c:	b538      	push	{r3, r4, r5, lr}
    8e7e:	4d07      	ldr	r5, [pc, #28]	; (8e9c <__libc_fini_array+0x20>)
    8e80:	4c07      	ldr	r4, [pc, #28]	; (8ea0 <__libc_fini_array+0x24>)
    8e82:	1b2c      	subs	r4, r5, r4
    8e84:	10a4      	asrs	r4, r4, #2
    8e86:	d005      	beq.n	8e94 <__libc_fini_array+0x18>
    8e88:	3c01      	subs	r4, #1
    8e8a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    8e8e:	4798      	blx	r3
    8e90:	2c00      	cmp	r4, #0
    8e92:	d1f9      	bne.n	8e88 <__libc_fini_array+0xc>
    8e94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    8e98:	f000 bce4 	b.w	9864 <__init_array_end>
	...

00008ea4 <_malloc_trim_r>:
    8ea4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8ea6:	4f23      	ldr	r7, [pc, #140]	; (8f34 <_malloc_trim_r+0x90>)
    8ea8:	460c      	mov	r4, r1
    8eaa:	4606      	mov	r6, r0
    8eac:	f7ff fa3a 	bl	8324 <__malloc_lock>
    8eb0:	68bb      	ldr	r3, [r7, #8]
    8eb2:	685d      	ldr	r5, [r3, #4]
    8eb4:	f025 0503 	bic.w	r5, r5, #3
    8eb8:	1b29      	subs	r1, r5, r4
    8eba:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    8ebe:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    8ec2:	f021 010f 	bic.w	r1, r1, #15
    8ec6:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    8eca:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    8ece:	db07      	blt.n	8ee0 <_malloc_trim_r+0x3c>
    8ed0:	2100      	movs	r1, #0
    8ed2:	4630      	mov	r0, r6
    8ed4:	f7ff fc22 	bl	871c <_sbrk_r>
    8ed8:	68bb      	ldr	r3, [r7, #8]
    8eda:	442b      	add	r3, r5
    8edc:	4298      	cmp	r0, r3
    8ede:	d004      	beq.n	8eea <_malloc_trim_r+0x46>
    8ee0:	4630      	mov	r0, r6
    8ee2:	f7ff fa21 	bl	8328 <__malloc_unlock>
    8ee6:	2000      	movs	r0, #0
    8ee8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8eea:	4261      	negs	r1, r4
    8eec:	4630      	mov	r0, r6
    8eee:	f7ff fc15 	bl	871c <_sbrk_r>
    8ef2:	3001      	adds	r0, #1
    8ef4:	d00d      	beq.n	8f12 <_malloc_trim_r+0x6e>
    8ef6:	4b10      	ldr	r3, [pc, #64]	; (8f38 <_malloc_trim_r+0x94>)
    8ef8:	68ba      	ldr	r2, [r7, #8]
    8efa:	6819      	ldr	r1, [r3, #0]
    8efc:	1b2d      	subs	r5, r5, r4
    8efe:	f045 0501 	orr.w	r5, r5, #1
    8f02:	4630      	mov	r0, r6
    8f04:	1b09      	subs	r1, r1, r4
    8f06:	6055      	str	r5, [r2, #4]
    8f08:	6019      	str	r1, [r3, #0]
    8f0a:	f7ff fa0d 	bl	8328 <__malloc_unlock>
    8f0e:	2001      	movs	r0, #1
    8f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8f12:	2100      	movs	r1, #0
    8f14:	4630      	mov	r0, r6
    8f16:	f7ff fc01 	bl	871c <_sbrk_r>
    8f1a:	68ba      	ldr	r2, [r7, #8]
    8f1c:	1a83      	subs	r3, r0, r2
    8f1e:	2b0f      	cmp	r3, #15
    8f20:	ddde      	ble.n	8ee0 <_malloc_trim_r+0x3c>
    8f22:	4c06      	ldr	r4, [pc, #24]	; (8f3c <_malloc_trim_r+0x98>)
    8f24:	4904      	ldr	r1, [pc, #16]	; (8f38 <_malloc_trim_r+0x94>)
    8f26:	6824      	ldr	r4, [r4, #0]
    8f28:	f043 0301 	orr.w	r3, r3, #1
    8f2c:	1b00      	subs	r0, r0, r4
    8f2e:	6053      	str	r3, [r2, #4]
    8f30:	6008      	str	r0, [r1, #0]
    8f32:	e7d5      	b.n	8ee0 <_malloc_trim_r+0x3c>
    8f34:	1fff8db0 	.word	0x1fff8db0
    8f38:	1fffb618 	.word	0x1fffb618
    8f3c:	1fff91bc 	.word	0x1fff91bc

00008f40 <_free_r>:
    8f40:	2900      	cmp	r1, #0
    8f42:	d045      	beq.n	8fd0 <_free_r+0x90>
    8f44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8f48:	460d      	mov	r5, r1
    8f4a:	4680      	mov	r8, r0
    8f4c:	f7ff f9ea 	bl	8324 <__malloc_lock>
    8f50:	f855 7c04 	ldr.w	r7, [r5, #-4]
    8f54:	496a      	ldr	r1, [pc, #424]	; (9100 <_free_r+0x1c0>)
    8f56:	f027 0301 	bic.w	r3, r7, #1
    8f5a:	f1a5 0408 	sub.w	r4, r5, #8
    8f5e:	18e2      	adds	r2, r4, r3
    8f60:	688e      	ldr	r6, [r1, #8]
    8f62:	6850      	ldr	r0, [r2, #4]
    8f64:	42b2      	cmp	r2, r6
    8f66:	f020 0003 	bic.w	r0, r0, #3
    8f6a:	d062      	beq.n	9032 <_free_r+0xf2>
    8f6c:	07fe      	lsls	r6, r7, #31
    8f6e:	6050      	str	r0, [r2, #4]
    8f70:	d40b      	bmi.n	8f8a <_free_r+0x4a>
    8f72:	f855 7c08 	ldr.w	r7, [r5, #-8]
    8f76:	1be4      	subs	r4, r4, r7
    8f78:	f101 0e08 	add.w	lr, r1, #8
    8f7c:	68a5      	ldr	r5, [r4, #8]
    8f7e:	4575      	cmp	r5, lr
    8f80:	443b      	add	r3, r7
    8f82:	d06f      	beq.n	9064 <_free_r+0x124>
    8f84:	68e7      	ldr	r7, [r4, #12]
    8f86:	60ef      	str	r7, [r5, #12]
    8f88:	60bd      	str	r5, [r7, #8]
    8f8a:	1815      	adds	r5, r2, r0
    8f8c:	686d      	ldr	r5, [r5, #4]
    8f8e:	07ed      	lsls	r5, r5, #31
    8f90:	d542      	bpl.n	9018 <_free_r+0xd8>
    8f92:	f043 0201 	orr.w	r2, r3, #1
    8f96:	6062      	str	r2, [r4, #4]
    8f98:	50e3      	str	r3, [r4, r3]
    8f9a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    8f9e:	d218      	bcs.n	8fd2 <_free_r+0x92>
    8fa0:	08db      	lsrs	r3, r3, #3
    8fa2:	1c5a      	adds	r2, r3, #1
    8fa4:	684d      	ldr	r5, [r1, #4]
    8fa6:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    8faa:	60a7      	str	r7, [r4, #8]
    8fac:	2001      	movs	r0, #1
    8fae:	109b      	asrs	r3, r3, #2
    8fb0:	fa00 f303 	lsl.w	r3, r0, r3
    8fb4:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    8fb8:	431d      	orrs	r5, r3
    8fba:	3808      	subs	r0, #8
    8fbc:	60e0      	str	r0, [r4, #12]
    8fbe:	604d      	str	r5, [r1, #4]
    8fc0:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    8fc4:	60fc      	str	r4, [r7, #12]
    8fc6:	4640      	mov	r0, r8
    8fc8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    8fcc:	f7ff b9ac 	b.w	8328 <__malloc_unlock>
    8fd0:	4770      	bx	lr
    8fd2:	0a5a      	lsrs	r2, r3, #9
    8fd4:	2a04      	cmp	r2, #4
    8fd6:	d853      	bhi.n	9080 <_free_r+0x140>
    8fd8:	099a      	lsrs	r2, r3, #6
    8fda:	f102 0739 	add.w	r7, r2, #57	; 0x39
    8fde:	007f      	lsls	r7, r7, #1
    8fe0:	f102 0538 	add.w	r5, r2, #56	; 0x38
    8fe4:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    8fe8:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    8fec:	4944      	ldr	r1, [pc, #272]	; (9100 <_free_r+0x1c0>)
    8fee:	3808      	subs	r0, #8
    8ff0:	4290      	cmp	r0, r2
    8ff2:	d04d      	beq.n	9090 <_free_r+0x150>
    8ff4:	6851      	ldr	r1, [r2, #4]
    8ff6:	f021 0103 	bic.w	r1, r1, #3
    8ffa:	428b      	cmp	r3, r1
    8ffc:	d202      	bcs.n	9004 <_free_r+0xc4>
    8ffe:	6892      	ldr	r2, [r2, #8]
    9000:	4290      	cmp	r0, r2
    9002:	d1f7      	bne.n	8ff4 <_free_r+0xb4>
    9004:	68d0      	ldr	r0, [r2, #12]
    9006:	60e0      	str	r0, [r4, #12]
    9008:	60a2      	str	r2, [r4, #8]
    900a:	6084      	str	r4, [r0, #8]
    900c:	60d4      	str	r4, [r2, #12]
    900e:	4640      	mov	r0, r8
    9010:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    9014:	f7ff b988 	b.w	8328 <__malloc_unlock>
    9018:	6895      	ldr	r5, [r2, #8]
    901a:	4f3a      	ldr	r7, [pc, #232]	; (9104 <_free_r+0x1c4>)
    901c:	42bd      	cmp	r5, r7
    901e:	4403      	add	r3, r0
    9020:	d03f      	beq.n	90a2 <_free_r+0x162>
    9022:	68d0      	ldr	r0, [r2, #12]
    9024:	60e8      	str	r0, [r5, #12]
    9026:	f043 0201 	orr.w	r2, r3, #1
    902a:	6085      	str	r5, [r0, #8]
    902c:	6062      	str	r2, [r4, #4]
    902e:	50e3      	str	r3, [r4, r3]
    9030:	e7b3      	b.n	8f9a <_free_r+0x5a>
    9032:	07ff      	lsls	r7, r7, #31
    9034:	4403      	add	r3, r0
    9036:	d407      	bmi.n	9048 <_free_r+0x108>
    9038:	f855 2c08 	ldr.w	r2, [r5, #-8]
    903c:	1aa4      	subs	r4, r4, r2
    903e:	4413      	add	r3, r2
    9040:	68a0      	ldr	r0, [r4, #8]
    9042:	68e2      	ldr	r2, [r4, #12]
    9044:	60c2      	str	r2, [r0, #12]
    9046:	6090      	str	r0, [r2, #8]
    9048:	4a2f      	ldr	r2, [pc, #188]	; (9108 <_free_r+0x1c8>)
    904a:	6812      	ldr	r2, [r2, #0]
    904c:	f043 0001 	orr.w	r0, r3, #1
    9050:	4293      	cmp	r3, r2
    9052:	6060      	str	r0, [r4, #4]
    9054:	608c      	str	r4, [r1, #8]
    9056:	d3b6      	bcc.n	8fc6 <_free_r+0x86>
    9058:	4b2c      	ldr	r3, [pc, #176]	; (910c <_free_r+0x1cc>)
    905a:	4640      	mov	r0, r8
    905c:	6819      	ldr	r1, [r3, #0]
    905e:	f7ff ff21 	bl	8ea4 <_malloc_trim_r>
    9062:	e7b0      	b.n	8fc6 <_free_r+0x86>
    9064:	1811      	adds	r1, r2, r0
    9066:	6849      	ldr	r1, [r1, #4]
    9068:	07c9      	lsls	r1, r1, #31
    906a:	d444      	bmi.n	90f6 <_free_r+0x1b6>
    906c:	6891      	ldr	r1, [r2, #8]
    906e:	68d2      	ldr	r2, [r2, #12]
    9070:	60ca      	str	r2, [r1, #12]
    9072:	4403      	add	r3, r0
    9074:	f043 0001 	orr.w	r0, r3, #1
    9078:	6091      	str	r1, [r2, #8]
    907a:	6060      	str	r0, [r4, #4]
    907c:	50e3      	str	r3, [r4, r3]
    907e:	e7a2      	b.n	8fc6 <_free_r+0x86>
    9080:	2a14      	cmp	r2, #20
    9082:	d817      	bhi.n	90b4 <_free_r+0x174>
    9084:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    9088:	007f      	lsls	r7, r7, #1
    908a:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    908e:	e7a9      	b.n	8fe4 <_free_r+0xa4>
    9090:	10aa      	asrs	r2, r5, #2
    9092:	684b      	ldr	r3, [r1, #4]
    9094:	2501      	movs	r5, #1
    9096:	fa05 f202 	lsl.w	r2, r5, r2
    909a:	4313      	orrs	r3, r2
    909c:	604b      	str	r3, [r1, #4]
    909e:	4602      	mov	r2, r0
    90a0:	e7b1      	b.n	9006 <_free_r+0xc6>
    90a2:	f043 0201 	orr.w	r2, r3, #1
    90a6:	614c      	str	r4, [r1, #20]
    90a8:	610c      	str	r4, [r1, #16]
    90aa:	60e5      	str	r5, [r4, #12]
    90ac:	60a5      	str	r5, [r4, #8]
    90ae:	6062      	str	r2, [r4, #4]
    90b0:	50e3      	str	r3, [r4, r3]
    90b2:	e788      	b.n	8fc6 <_free_r+0x86>
    90b4:	2a54      	cmp	r2, #84	; 0x54
    90b6:	d806      	bhi.n	90c6 <_free_r+0x186>
    90b8:	0b1a      	lsrs	r2, r3, #12
    90ba:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    90be:	007f      	lsls	r7, r7, #1
    90c0:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    90c4:	e78e      	b.n	8fe4 <_free_r+0xa4>
    90c6:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    90ca:	d806      	bhi.n	90da <_free_r+0x19a>
    90cc:	0bda      	lsrs	r2, r3, #15
    90ce:	f102 0778 	add.w	r7, r2, #120	; 0x78
    90d2:	007f      	lsls	r7, r7, #1
    90d4:	f102 0577 	add.w	r5, r2, #119	; 0x77
    90d8:	e784      	b.n	8fe4 <_free_r+0xa4>
    90da:	f240 5054 	movw	r0, #1364	; 0x554
    90de:	4282      	cmp	r2, r0
    90e0:	d806      	bhi.n	90f0 <_free_r+0x1b0>
    90e2:	0c9a      	lsrs	r2, r3, #18
    90e4:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    90e8:	007f      	lsls	r7, r7, #1
    90ea:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    90ee:	e779      	b.n	8fe4 <_free_r+0xa4>
    90f0:	27fe      	movs	r7, #254	; 0xfe
    90f2:	257e      	movs	r5, #126	; 0x7e
    90f4:	e776      	b.n	8fe4 <_free_r+0xa4>
    90f6:	f043 0201 	orr.w	r2, r3, #1
    90fa:	6062      	str	r2, [r4, #4]
    90fc:	50e3      	str	r3, [r4, r3]
    90fe:	e762      	b.n	8fc6 <_free_r+0x86>
    9100:	1fff8db0 	.word	0x1fff8db0
    9104:	1fff8db8 	.word	0x1fff8db8
    9108:	1fff91b8 	.word	0x1fff91b8
    910c:	1fffb614 	.word	0x1fffb614

00009110 <vtable for COctoWS2811Controller<(EOrder)66, (unsigned char)0>>:
	...
    9118:	000009c5 00000a91 00000471 000008bd     ........q.......
    9128:	00000475 0000046d 00000591 0000203a     u...m.......: ..
    9138:	30303030 00000000 74746553 20676e69     0000....Setting 
    9148:	74746170 206e7265 626d756e 00007265     pattern number..
    9158:	74746553 20676e69 20706f74 69736f70     Setting top posi
    9168:	6e6f6974 00000000 74746553 20676e69     tion....Setting 
    9178:	74746f62 70206d6f 7469736f 006e6f69     bottom position.
    9188:	74746553 20676e69 65666665 6e207463     Setting effect n
    9198:	65626d75 00000072 74746553 20676e69     umber...Setting 
    91a8:	65646f6d 6d756e20 00726562 61736944     mode number.Disa
    91b8:	6e696c62 75412067 4d206f74 2e65646f     bling Auto Mode.
    91c8:	00000000 74746553 20676e69 6f747541     ....Setting Auto
    91d8:	74615020 6e726574 646f4d20 00002e65      Pattern Mode...
    91e8:	74746553 20676e69 6f747541 646f4d20     Setting Auto Mod
    91f8:	6f4d2065 002e6564 74746553 20676e69     e Mode..Setting 
    9208:	6f747541 74615020 6e726574 646f4d20     Auto Pattern Mod
    9218:	6f4d2065 002e6564 74746553 20676e69     e Mode..Setting 
    9228:	6f747541 656c5320 4d207065 2e65646f     Auto Sleep Mode.
    9238:	00000000 656d6f53 6e696874 65772067     ....Something we
    9248:	7720746e 676e6f72 61657220 676e6964     nt wrong reading
    9258:	72657320 206c6169 6d6d6f63 00646e61      serial command.
    9268:	656d6f53 6e696874 65772067 7720746e     Something went w
    9278:	676e6f72 61657220 676e6964 72657320     rong reading ser
    9288:	2c6c6169 6d6f6320 646e616d 73617720     ial, command was
    9298:	616c6220 002e6b6e 74746553 20676e69      blank..Setting 
    92a8:	6c616e41 4520676f 63656666 00000074     Analog Effect...
    92b8:	74746553 20676e69 6c616e41 5020676f     Setting Analog P
    92c8:	65747461 00006e72 65636552 64657669     attern..Received
    92d8:	706e6920 73207475 6e697274 00000067      input string...
    92e8:	0000007c 454e4f4e 00000000 004c4c41     |...NONE....ALL.
    92f8:	45454857 0000534c 45454857 0000004c     WHEELS..WHEEL...
    9308:	4b4f5053 00005345 4b4f5053 00000045     SPOKES..SPOKE...
    9318:	69726553 70206c61 2074726f 6e65706f     Serial port open
    9328:	002e6465 50444d56 7c315f56 4d565f31     ed..VMDPV_1|1_VM
    9338:	0a565044 00000000 50444d56 ff005f52     DPV.....VMDPR_..
    9348:	50444d56 00005f45 003a323a 0000003a     VMDPE_..:2:.:...
    9358:	444d565f 00004550 50444d56 00005f43     _VMDPE..VMDPC_..
    9368:	444d565f 00004350 6f727245 41203a72     _VMDPC..Error: A
    9378:	6d657474 74207470 6573206f 20612074     ttempt to set a 
    9388:	64616572 6c6e6f2d 61762079 62616972     read-only variab
    9398:	6f20656c 61642072 74206174 20657079     le or data type 
    93a8:	20746f6e 70707573 6574726f 000a0d64     not supported...

000093b8 <ones>:
    93b8:	ffffffff 00000003 0000283d 00000000     ........=(......
    93c8:	00000004 00003095 00000000 00000003     .....0..........
    93d8:	00003c41 00000000 00000003 00003801     A<...........8..
    93e8:	00000000 00000003 0000322d 00000000     ........-2......
    93f8:	00000003 00002a65 00000000 00000004     ....e*..........
    9408:	00003401 00000000 00000002 000039f5     .4...........9..
    9418:	00000000 00000004 00002cc1 00000000     .........,......
    9428:	0000000a 00002655 00000000 00002651     ....U&......Q&..
    9438:	00000000 00002989 00000000              .....)......

00009444 <sin16_C(unsigned short)::base>:
    9444:	18f90000 471c30fb 6a6d5a82 7d897641     .....0.G.ZmjAv.}

00009454 <b_m16_interleave>:
    9454:	29313100 0a751b5a                       .11)Z.u.

0000945c <CSWTCH.128>:
    945c:	00000004 00000005 00000006              ............

00009468 <sin16_C(unsigned short)::slope>:
    9468:	262c3031 040e171f 4e525450 00000000     10,&....PTRN....
    9478:	54434645 00000000 45444f4d 00000000     EFCT....MODE....
    9488:	54495242 00000000 4c505250 00000000     BRIT....PRPL....
    9498:	574c4c59 00000000 45554c42 00000000     YLLW....BLUE....
    94a8:	4e455247 00000000 5252494d 00000000     GREN....MIRR....
    94b8:	50504f54 00000000 50544f42 00000000     TOPP....BOTP....
    94c8:	48544f42 00000000 54504e41 00000000     BOTH....ANPT....
    94d8:	46454e41 00000000 53554150 00000000     ANEF....PAUS....
    94e8:	43415541 00000000 4f4e5541 00000000     AUAC....AUNO....
    94f8:	4c535541 00000000 54505541 00000000     AUSL....AUPT....
    9508:	4f4d5541 00000000 4d505541 00000000     AUMO....AUPM....
    9518:	4b414c42 ffffff00                       BLAK....

00009520 <digital_pin_to_info_PGM>:
    9520:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    9530:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    9540:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    9550:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    9560:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    9570:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    9580:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    9590:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    95a0:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    95b0:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    95c0:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    95d0:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    95e0:	43fe0014 40049014 43fe084c 4004a04c     ...C...@L..CL..@
    95f0:	43fe2004 4004d004 43fe1024 4004b024     . .C...@$..C$..@
    9600:	43fe1020 4004b020 43fe1028 4004b028      ..C ..@(..C(..@
    9610:	43fe102c 4004b02c 43fe2000 4004d000     ,..C,..@. .C...@
    9620:	43fe0848 4004a048 43fe0010 40049010     H..CH..@...C...@

00009630 <vtable for HardwareSerial>:
	...
    9638:	000068cd 000068f1 00006981 0000697d     .h...h...i..}i..
    9648:	00006979 00006975 00006971 00006895     yi..ui..qi...h..
    9658:	00006951 0000694d 00006945 0000693d     Qi..Mi..Ei..=i..
    9668:	00006935 00006925 00006915 00006911     5i..%i...i...i..
    9678:	00006909 00006901 00006875 0000687d     .i...i..uh..}h..
    9688:	00006885 0000688d 000068d9 000068c1     .h...h...h...h..
    9698:	ffff0a0d                                ....

0000969c <vtable for usb_serial_class>:
	...
    96a4:	00006abd 00006ab5 00006ab1 00006aad     .j...j...j...j..
    96b4:	00006aa9 00006aa5 00006aa1 00006a9d     .j...j...j...j..

000096c4 <usb_endpoint_config_table>:
    96c4:	15191500                                ....

000096c8 <usb_descriptor_list>:
    96c8:	00000100 1fff8774 00000012 00000200     ....t...........
    96d8:	1fff87a0 00000043 00000300 1fff87fc     ....C...........
    96e8:	00000000 04090301 1fff8788 00000000     ................
    96f8:	04090302 1fff87e4 00000000 04090303     ................
    9708:	1fff8800 00000000 00000000 00000000     ................
    9718:	00000000                                ....

0000971c <_global_impure_ptr>:
    971c:	1fff8818 00000043 49534f50 00000058     ....C...POSIX...
    972c:	0000002e                                ....

00009730 <_ctype_>:
    9730:	20202000 20202020 28282020 20282828     .         ((((( 
    9740:	20202020 20202020 20202020 20202020                     
    9750:	10108820 10101010 10101010 10101010      ...............
    9760:	04040410 04040404 10040404 10101010     ................
    9770:	41411010 41414141 01010101 01010101     ..AAAAAA........
    9780:	01010101 01010101 01010101 10101010     ................
    9790:	42421010 42424242 02020202 02020202     ..BBBBBB........
    97a0:	02020202 02020202 02020202 10101010     ................
    97b0:	00000020 00000000 00000000 00000000      ...............
	...
    9830:	ffffff00                                ....

00009834 <_init>:
    9834:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9836:	bf00      	nop
    9838:	bcf8      	pop	{r3, r4, r5, r6, r7}
    983a:	bc08      	pop	{r3}
    983c:	469e      	mov	lr, r3
    983e:	4770      	bx	lr

00009840 <__init_array_start>:
    9840:	00008e69 	.word	0x00008e69

00009844 <__frame_dummy_init_array_entry>:
    9844:	00000435 000018bd 00001e61 000021c9     5.......a....!..
    9854:	000024cd 0000452d 00004539 00004759     .$..-E..9E..YG..

Disassembly of section .fini:

00009864 <_fini>:
    9864:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9866:	bf00      	nop
